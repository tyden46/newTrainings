<div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

<div class="book-summary">

  - [Análisis de secuencias de 16S con
    DADA2](http://www.castrolab.org/isme/dada2/dada2.html)

  - 
  - [****0.1** Acerca del curso](#workshop)

  - [****1** Introducción al análisis por 16S rRNA con DADA2 y
    mothur](#introduccion-al-analisis-por-16s-rrna-con-dada2-y-mothur)
    
      - [****1.1** Configurar sesión de R](#configurar-sesion-de-r)
      - [****1.2** DADA2](#dada2)

  - 
  - [CASTRO LAB](http://www.castrolab.org)

  - [ISME LA 2019](https://isme-la2019.org)

</div>

<div class="book-body">

<div class="body-inner">

<div class="book-header" role="navigation">

# **[Análisis de secuencias de 16S con DADA2](./)

</div>

<div class="page-wrapper" tabindex="-1" role="main">

<div class="page-inner">

<div id="section-" class="section normal">

<div id="header">

*ISME Latin America, Septiembre 2019*

</div>

<div id="workshop" class="section level2">

## <span class="header-section-number">0.1</span> Acerca del curso

El tutorial a continuación fue creado especialmente para guiar el
trabajo práctico del [**curso pre-congreso ISME Latin
America 2019**](https://isme-la2019.org/curso-pre-congreso/): **Análisis
de datos bioinformáticos para metagenomas y amplicones usando R**. A
realizarse el próximo 9 y 10 de septiembre en la [Universidad Técnica
Federico Santa María](https://www.usm.cl), Valparaíso, Chile.

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

El curso cuenta con **6 unidades**. Ahora, usted se encuentra en la
unidad: **Análisis de secuencias de 16S con DADA2**
![](images/bioinformatics.png)

> **Otras unidades del curso son**:
> 
> [**Introducción a R: Manipulación de datos y
> visualización**](http://www.castrolab.org/isme/introR/introR.html)
> ![](images/r.png)
> 
> [**Introducción a phyloseq y a análisis de
> diversidad**](http://www.castrolab.org/isme/biodiversity/biodiversity.html)
> ![](images/bacteria.png)
> 
> [**Búsqueda de genes de interés en datos de metagenómica
> *shotgun***](http://www.castrolab.org/isme/gene_search/gene_search.html)
> ![](images/gene_search.png)
> 
> [**Visualización y curación de genomas ensamblados desde metagenomas
> (MAGs)**](http://www.castrolab.org/isme/mags/mags.html)
> ![](images/genome.png)
> 
> [**Redes de co-ocurrencia de
> microorganismos**](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)
> ![](images/network.png)

-----

  - Profesor: **Dr. Eduardo Castro-Nallar** (<eduardo.castro@unab.cl>)

  - Ayudantes:
    
      - **Dr. Florence Gutzwiller** (<florence.gutzwiller@gmail.com>)
      - **M.Sc. Katterinne N. Mendez** (<mendez.katterinne@gmail.com>)

**[CASTRO LAB](http://www.castrolab.org)**

[Centro de Bioinformática y Biología Integrativa](http://www.cbib.cl) |
[Universidad Andrés Bello](https://www.unab.cl)

![](images/UNAB_CBIB_horizontal.png)

[Santiago, Chile](https://goo.gl/maps/BCe9hWcRZJKkhaDP8)

</div>

<div id="introduccion-al-analisis-por-16s-rrna-con-dada2-y-mothur" class="section level1">

# <span class="header-section-number">1</span> Introducción al análisis por 16S rRNA con DADA2 y mothur

Lo primero que tenemos que hacer es instalar y cargar los paquetes que
vamos a usar en esta sección. Algunos están alojados en el repositorio
[CRAN](https://cran.rediris.es), otros en el repositorio
[Bioconductor](https://www.bioconductor.org), y otros en el repositorio
[GitHub](https://github.com).

<div id="configurar-sesion-de-r" class="section level2">

## <span class="header-section-number">1.1</span> Configurar sesión de R

Para trabajar en R, hay tres primeros pasos que debemos seguir: (1)
cargar a los paquetes necesarios a la sesión actual, (2) configurar el
directorio de trabajo, (3) importar datos de entrada a la sesión actual.

Los siguientes 3 *scripts* te mostrarán una manera eficiente de instalar
y cargar la lista de paquetes según su repositorio de origen, ya que
cada repositorio tiene su propia función para instlar sus paquetes.

  - Primero, enlistar los paquetes necesarios en diferentes vectores
    dependiendo de su repositorio de origen.

<div class="sourceCode">

``` sourceCode r
# Definir paquetes
## Repositorio CRAN
cran_packages <- c("bookdown", "knitr", "tidyverse", "plyr", "grid", "gridExtra", "kableExtra", "xtable", "ggpubr")
## Repositorio Bioconductor
bioc_packages <- c("phyloseq", "dada2", "DECIPHER", "phangorn", "ggpubr", "BiocManager","DESeq2", "microbiome", "philr")
## Repositorio GitHub
git_source <- c("twbattaglia/btools", "gmteunisse/Fantaxtic", "MadsAlbertsen/ampvis2", "opisthokonta/tsnemicrobiota")
# fuente/nombre del paquete
git_packages <- c("btools", "fantaxtic", "ampvis2", "tsnemicrobiota") # nombre del paquete
```

</div>

  - Segundo, instalar los paquetes definidos arriba usando la función
    correspondiente a cada repositorio.

<div class="sourceCode">

``` sourceCode r
# Instalar paquetes CRAN
.inst <- cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(cran_packages[!.inst])
}
# Intalar paquetes BioConductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
.inst <- bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(bioc_packages[!.inst])
}
# Instalar paquetes GitHub
.inst <- git_source %in% installed.packages()
if(any(!.inst)) {
  devtools::install_github(git_source[!.inst])
}
```

</div>

  - Tercero, cargar los paquetes requeridos a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
sapply(c(cran_packages, bioc_packages, git_packages), require, character.only = TRUE)
```

</div>

El paso de instalación de paquetes es necesario solamente una vez.
Excepto si se quiere actualizar la versión del paquete, o bien, R ha
sido desinstalado e instalado nuevamente o actualizado su versión.

Si ya tienes los paquetes instalados en tu computadora, sólo necesitas
enlistar (*1er script*) y cargar (*3er script*) los paquetes. También,
puedes cargarlos a la sesión actual de R usando la función `library()`,
así:

    # Cargar paquetes
    library(tidyverse)
    library(plyr)
    library(grid)
    library(gridExtra)
    library(kableExtr)
    library(xtable)
    library(ggpubr)
    library(phyloseq)
    library(dada2)
    library(DECIPHER)
    library(phangorn)
    library(ggpubr)
    library(BiocManager)
    library(DESeq2)
    library(microbiome)
    library(philr)
    library(btools)
    library(fantaxtic)
    library(ampvis2)
    library(tsnemicrobiota)

</div>

<div id="dada2" class="section level2">

## <span class="header-section-number">1.2</span> DADA2

> Este tutorial se basa fuertemente en el trabajo de otros
> investigadores publicado en Callahan BJ, Sankaran K, Fukuyama JA et
> al. [Bioconductor Workflow for Microbiome Data Analysis: from raw
> reads to community
> analyses](https://doi.org/10.12688/f1000research.8986.2) \[version 2;
> peer review: 3 approved\]. F1000Research 2016, 5:1492

En esta sección vamos a explorar un set de datos de 98 muestras de piel
de ballenas, jorobadas, azules y otras. Las muestras fueron obtenidas al
amplificar y secuenciar un fragmento de la región variable 4 (V4) del
gen 16S rRNA gene. Las secuencias están disponibles en este
[link](https://www.dropbox.com/sh/vkc1p96ney0x6kh/AADjo1ayo3ic5OhzNE2WRac1a?dl=0)
y también en la base de datos de NCBI SRA bajo el número de acceso
[PRJNA428495](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA428495).

Entonces, lo que vamos a hacer es correr nuestros datos según la
pipeline [DADA2](https://www.nature.com/articles/nmeth.3869). DADA2
ofrece ventajas con respecto a la estrategia de formar clusters (OTUs)
en varios aspectos que incluyen mayor resolución, nombres consistentes
entre diferentes análisis, mejor estimación de abundancias relativas,
etc. Los siguientes artículos ofrecen una discusión más detallada al
respecto ( [artículo](https://www.nature.com/articles/ismej2017119) y
[artículo](http://fiererlab.org/2017/05/02/lumping-versus-splitting-is-it-time-for-microbial-ecologists-to-abandon-otus/)).

  - Lo primero que vamos a hacer es *descargar* las **reads** que están
    contenidas en la carpeta `whale_pe/`, descárgala
    [AQUÍ](https://www.dropbox.com/s/es3ehm61z0hlmb6/whale_pe.zip?dl=0).

  - Ahora, vamos a configurar el directorio donde están las **reads**:

<div class="sourceCode">

``` sourceCode r
set.seed(100) 
# Configuramos un número de semilla para que los resultados 
# sean comparables entre estudiantes

# Simplemente cambiamos este path al que corresponda según donde están las reads
miseq_path <- "~/Dropbox/CastroLab_database/workshops_data/whale_pe/"
list.files(miseq_path)
```

</div>

Asegúrate de modificar la ruta:
`~/Dropbox/CastroLab_database/workshops_data/whale_pe/` a la ruta de
directorios según tu computadora.

  - En DADA2 las reads se trabajan inicialmente por separado, es decir,
    la copia forward o R1 separada de la copia reverse o R2. Por esto,
    nos tenemos que asegurar que ambos archivos estén ordenados. Luego,
    manipulamos el nombre de los archivos para generar automáticamente
    el nombre de las muestras en nuestro análisis:

<div class="sourceCode">

``` sourceCode r
fnFs <- sort(list.files(miseq_path, pattern="_1.fastq"))
fnRs <- sort(list.files(miseq_path, pattern="_2.fastq"))

# Extracción del nombre de las muestras
sampleNames <- sapply(strsplit(fnFs, "_"), `[`, 1)
# Especificamos el path completo para evitar errores de ambigüedad
fnFs <- file.path(miseq_path, fnFs)
fnRs <- file.path(miseq_path, fnRs)
```

</div>

  - El paquete DADA2 tiene muchas funciones útiles para el
    preprocesamiento de los datos. Acá lo que hacemos es visualizar el
    perfil de calidad de las muestras para cada par de 5’ a 3’:

<div class="sourceCode">

``` sourceCode r
plotQualityProfile(fnFs[1:2])
plotQualityProfile(fnRs[1:2])
```

</div>

<div class="figure">

![](images/plotQuality.png)

</div>

  - Ahora vamos a proceder con el filtrado y corte de las reads de
    acuerdo a lo observado en los gráficos de calidad. Primero creamos
    un directorio donde vamos a poner las reads una vez realizado el
    control de calidad, y luego realizamos el dicho control. En
    específico usamos los argumentos `trunLen =`, `maxN=`, `maxEE=` y
    `rm.phix=` para indicar el corte promedio de cada read, el número
    máximo de bases indeterminadas, el número máximo de errores, y si
    es que queremos remover secuencias pertenecientes al control interno
    de Illumina.

<div class="sourceCode">

``` sourceCode r
# Creamos un directorio para poner las reads "limpias"
filt_path <- file.path(miseq_path, "filtered") 
if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sampleNames, "_F_filt.fastq.gz"))
filtRs <- file.path(filt_path, paste0(sampleNames, "_R_filt.fastq.gz"))

# Y finalmente procedemos con el control de calidad
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(250,200),
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE) 
# Si usan Windows, configuren multithread=FALSE
```

</div>

  - DADA2 genera un modelo probabilístico de errores con el cual puede
    filtrar reads erróneas y así usar las restantes directamente para la
    etapa de clasificación taxonómica. Esta parte del método es la que
    nos permite tener una mayor resolución en comparación a los análisis
    basados en OTUs. Como las muestras probablemente tienen reads
    idénticas, no es eficiente usar cada una de ellas para los pasos
    río abajo. Por esto, DADA2 recomienda *de-replicar* las muestras
    para así disminuir la redundancia y avanzar eficientemente.

<div class="sourceCode">

``` sourceCode r
derepFs <- derepFastq(filtFs, verbose=TRUE)
derepRs <- derepFastq(filtRs, verbose=TRUE)

# Acá simplemente agregamos los nombres de las muestras al objeto de-replicado
names(derepFs) <- sampleNames
names(derepRs) <- sampleNames
```

</div>

  - Una vez con las muestras de-replicadas procedemos a generar un
    modelo de errores. Para mayor detalle sobre este crucial paso
    revisen el artículo original
    [aquí](https://www.nature.com/articles/nmeth.3869).

<div class="sourceCode">

``` sourceCode r
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)

# Graficamos los errores para cada par
plotErrors(errF)
plotErrors(errR)
```

</div>

<div class="figure">

![](images/plotErrors.png)

</div>

Cada panel en el gráfico nos indica la frecuencia de error de
nuecleótido a nucleótido para todas las combinaciones. Naturalmente,
las bases con mayor puntaje de calidad exhiben una menor frecuencia de
error.

  - Con esta información entonces procedemos al paso más importante de
    la pipeline, i.e., la inferencia de las *Amplicon Sequence Variants*
    (ASVs).

<div class="sourceCode">

``` sourceCode r
dadaFs <- dada(derepFs, err=errF, multithread=TRUE, pool = TRUE)
dadaRs <- dada(derepRs, err=errR, multithread=TRUE, pool = TRUE)
```

</div>

  - Ahora nos queda hacer un poco de aseo: primero unimos las reads R1 y
    R2, luego generamos una tabla de secuencias que vamos a utilizar más
    tarde, y finalmente removemos secuencias artefactuales producto de
    la amplificación por PCR.

<div class="sourceCode">

``` sourceCode r
# Unimos las reads
mergers <- mergePairs(dadaFs, derepFs, dadaRs, derepRs)
# Generamos una tabla de secuencias
seqtabAll <- makeSequenceTable(mergers[!grepl("Mock", names(mergers))])
table(nchar(getSequences(seqtabAll)))
# Removemos las secuencias quiméricas
seqtabNoC <- removeBimeraDenovo(seqtabAll)
```

</div>

La tabla de secuencias sin las quimeras, es la tabla que usamos para
realizar la clasificación taxonómica. En principio, podríamos usar
cualquiera de las tres bases de datos más populares para clasificación
de secuencias del 16S rRNA, i.e., *GreenGenes*, *RDP* o *SILVA*.

  - En nuestro práctico vamos a utilizar SILVA, en particular, la
    versión 132.

  - Antes de continuar, descarga los archivos de la base de datos SILVA
    que vamos a utilizar: `silva_nr_v132_train_set.fa`
    [AQUÍ](https://www.dropbox.com/s/0yaxvi0qkuuas1w/silva_nr_v132_train_set.fa?dl=0)
    y `silva_species_assignment_v132.fa`
    [AQUÍ](https://www.dropbox.com/s/oyeh1w2w6qc83p1/silva_species_assignment_v132.fa?dl=0).

<div class="sourceCode">

``` sourceCode r
fastaRef <- "~/Dropbox/CastroLab_database/workshops_data/silva_nr_v132_train_set.fa"
taxTab <- assignTaxonomy(seqtabNoC, refFasta = fastaRef, multithread=TRUE)

# En el caso de querer agregar el rango taxonómico de especies, simplemente usamos una base de datos extra, la cual contiene esta información. 
taxTabExtra <- addSpecies(taxTab, "~/Dropbox/CastroLab_database/workshops_data/silva_species_assignment_v132.fa", verbose=TRUE)
unname(head(taxTab)) -> tabla
colnames(tabla) <- c("Kingdom", "Phylum", "Order", "Class", "Family", "Genus")
```

</div>

Ya que nuestro perfil taxonómico se construye con secuencias homólogas
del 16S rRNA gene, podemos usar estas secuencias para inferir un árbol
filogenético. Existen muchos paquetes de r que pueden hacer esto y aquí
escogemos *phangorn* para hacer una inferencia basada en Maximum
Likelihood.

  - Primero alineamos las secuencias:

<div class="sourceCode">

``` sourceCode r
seqs <- getSequences(seqtabNoC)
# Este paso propaga los nombres de las secuencias al árbol
names(seqs) <- seqs
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA,verbose=FALSE)
```

</div>

  - Y con ese alineamiento inferimos un árbol de partida o *starting
    tree* para inicializar la búsqueda por ML. También ajustamos un
    modelo de sustitución nucleotídica para parametrizar la tasa de
    cambio de un nucleótido a otro y asó poder inferir correctamente el
    largo de las ramas y la topología del árbol.

<div class="sourceCode">

``` sourceCode r
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm) 
fit = pml(treeNJ, data=phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
        rearrangement = "stochastic", control = pml.control(trace = 0))
```

</div>

<div class="sourceCode">

``` sourceCode r
detach("package:phangorn", unload=TRUE)
```

</div>

Ahora, tenemos todos los ingredientes para formar un objeto de R que
contenga todo lo que nos importa en un experimento metagenómico, i.e.,
una tabla de cuentas que indica el número de reads por seceuncia del 16S
rRNA gene, una tabla con el linaje taxonómico de esas secuencias, un
árbol filogenético que relaciona esas secuencias entre sí, y
finalmente, una tabla con variables asociadas a nuestras muestras,
también llamada **metadata**.

  - Descarga la metadata
    [AQUÍ](https://www.dropbox.com/s/dafb0g5zn8c8n41/metadata.csv?dl=0).

  - Con estos elementos procedemos a generar un objeto **phyloseq**:

<div class="sourceCode">

``` sourceCode r
samdf <- read.csv("~/Dropbox/CastroLab_database/workshops_data/metadata.csv", header=TRUE, row.names = 1)
rownames(seqtabNoC) %in% rownames(samdf)
all(rownames(seqtabAll) %in% samdf$run)

ps <- phyloseq(otu_table(seqtabNoC, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxTab),
               phy_tree(fitGTR$tree))
ps <- prune_samples(sample_names(ps) != "Mock", ps) # Remover potenciales muestras sintéticas
ps
```

</div>

  - Y el producto final del análisis por DADA2 es entonces un objeto
    *phyloseq*:

| Slot           | Descripción        | Resultado                               |
| :------------- | :----------------- | :-------------------------------------- |
| otu\_table()   | OTU Table:         | \[ 1476 taxa and 98 samples \]          |
| sample\_data() | Sample Data:       | \[ 98 samples by 13 sample variables \] |
| tax\_table()   | Taxonomy Table:    | \[ 1476 taxa by 6 taxonomic ranks \]    |
| phy\_tree()    | Phylogenetic Tree: | \[ 1476 tips and 1474 internal nodes \] |

-----

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

</div>

</div>

</div>

</div>

</div>

</div>

</div>

</div>

<div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

<div class="book-summary">

  - [Búsqueda de genes de interés en datos de metagenómica
    shotgun](http://castrolab.org/isme/gene_search/gene_search.html)

  - 
  - [****0.1** Acerca del curso](#workshop)

  - [****1** Datos de entrada](#datos-de-entrada)
    
      - [****1.1** Pre-procesamiento de los
        datos](#pre-procesamiento-de-los-datos)
      - [****1.2** Preparar la base de
        datos](#preparar-la-base-de-datos)
      - [****1.3** Identificar proteinas de interés en los
        metagenomas](#identificar-proteinas-de-interes-en-los-metagenomas)
      - [****1.4** Preparar FASTA con los genes presentes en los
        metagenomas](#preparar-fasta-con-los-genes-presentes-en-los-metagenomas)
      - [****1.5** Mapeo de *reads*](#mapeo-de-reads)

  - [****2** Configurar sesión de R](#configurar-sesion-de-r)

  - [****3** Análisis de abundancia de genes de
    interés](#analisis-de-abundancia-de-genes-de-interes)
    
      - [****3.1** Obtener la metadata](#obtener-la-metadata)
      - [****3.2** Preparar tabla de
        cuentas](#preparar-tabla-de-cuentas)
      - [****3.3** Abundancia de genes por muestra](#abundance)
      - [****3.4** Test estadístico de abundancia
        diferencial](#test-estadistico-de-abundancia-diferencial)
      - [****3.5** Evaluación cualitativa de abundancia de
        genes](#evaluacion-cualitativa-de-abundancia-de-genes)

  - [****4** Conclusiones acerca del metabolismo del nitrógeno en
    OMZ](#conclusiones-acerca-del-metabolismo-del-nitrogeno-en-omz)

  - 
  - [CASTRO LAB](http://www.castrolab.org)

  - [ISME LA 2019](https://isme-la2019.org)

</div>

<div class="book-body">

<div class="body-inner">

<div class="book-header" role="navigation">

# **[Búsqueda de genes de interés en datos de metagenómica shotgun](./)

</div>

<div class="page-wrapper" tabindex="-1" role="main">

<div class="page-inner">

<div id="section-" class="section normal">

<div id="header">

*ISME Latin America, Septiembre 2019*

</div>

<div id="workshop" class="section level2">

## <span class="header-section-number">0.1</span> Acerca del curso

El tutorial a continuación fue creado especialmente para guiar el
trabajo práctico del [**curso pre-congreso ISME Latin
America 2019**](https://isme-la2019.org/curso-pre-congreso/): **Análisis
de datos bioinformáticos para metagenomas y amplicones usando R**. A
realizarse el próximo 9 y 10 de septiembre en la [Universidad Técnica
Federico Santa María](https://www.usm.cl), Valparaíso, Chile.

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

El curso cuenta con **6 unidades**. Ahora, usted se encuentra en la
unidad: **Búsqueda de genes de interés en datos de metagenómica
*shotgun*** ![](images/gene_search.png)

> **Otras unidades del curso son**:
> 
> [**Introducción a R: Manipulación de datos y
> visualización**](http://www.castrolab.org/isme/introR/introR.html)
> ![](images/r.png)
> 
> [**Análisis de secuencias de 16S con
> DADA2**](http://www.castrolab.org/isme/dada2/dada2.html)
> ![](images/bioinformatics.png)
> 
> [**Introducción a phyloseq y a análisis de
> diversidad**](http://www.castrolab.org/isme/biodiversity/biodiversity.html)
> ![](images/bacteria.png)
> 
> [**Visualización y curación de genomas ensamblados desde metagenomas
> (MAGs)**](http://www.castrolab.org/isme/mags/mags.html)
> ![](images/genome.png)
> 
> [**Redes de co-ocurrencia de
> microorganismos**](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)
> ![](images/network.png)

-----

  - Profesor: **Dr. Eduardo Castro-Nallar** (<eduardo.castro@unab.cl>)

  - Ayudantes:
    
      - **Dr. Florence Gutzwiller** (<florence.gutzwiller@gmail.com>)
      - **M.Sc. Katterinne N. Mendez** (<mendez.katterinne@gmail.com>)

**[CASTRO LAB](http://www.castrolab.org)**

[Centro de Bioinformática y Biología Integrativa](http://www.cbib.cl) |
[Universidad Andrés Bello](https://www.unab.cl)

![](images/UNAB_CBIB_horizontal.png)

[Santiago, Chile](https://goo.gl/maps/BCe9hWcRZJKkhaDP8)

</div>

<div id="datos-de-entrada" class="section level1">

# <span class="header-section-number">1</span> Datos de entrada

Los datos a trabajar en esta unidad corresponden a **4 metagenomas
marinos** colectados desde la **zona mínima de oxígeno OMZ (*Oxygen
Minimum Zone*)** que se encuentra en las costas de Perú y Chile. Los
metagenomas fueron colectados en dos profundidades (100 y 150 metros) en
una región de la OMZ frente a Valparaíso, Chile.

  - Descripción de las muestras:

| Muestra | Profundidad \[m\] | Fecha de muestreo |
| :-----: | :---------------: | :---------------: |
|   EC5   |        100        |      Sep-15       |
|  EC11   |        150        |      Feb-18       |
|  EC100  |        100        |      Jan-15       |
|  EC19   |        150        |      Jul-18       |

Los datos de entrada provienen de la secuenciación de tipo *shotgun* del
ADN total extraído de las muestras de agua.

<div id="pre-procesamiento-de-los-datos" class="section level2">

## <span class="header-section-number">1.1</span> Pre-procesamiento de los datos

El primer paso en la busqueda de genes de interés es el ensamble de los
*reads* en *contigs* mas largos. Eso permite trabajar con sequencias más
largas, en lugar de las *reads* cortas que hacen los procesos de
computación mas intensivos.

Para ensemblar las *reads*, necesitamos primero controlar la calidad,
cortar los adaptadores y remover los reads de baja calidad con el
programa *Prinseq*.

Elegimos los parámetros basados en el largo y calidad de las *reads* y
las necesidades del análisis. Definimos un largo de *read* mínimo de 70
bases (`-min_len 70`), una calidad promedio mínima de 20
(`-min_qual_mean 20`), y una calidad media de 10 sobre una *sliding
windows* desde el 3’ (`-trim_qual_window 10`), con un paso de 5
posiciones (`-trim_qual_step 5`). Filtramos las *reads* con bases
indeterminadas (Ns) (`-ns_max_p 0`). También, removemos las sequencias
de baja complejidad (`-lc_threshold 32`). Finalmente, removemos 10
nucleotidos a la izquierda y 20 a la derecha.

<div class="sourceCode">

``` sourceCode bash
for i in $list_sample
do
prinseq-lite.pl -verbose -fastq $rawdir/${i}_1.fastq -fastq2 $rawdir/${i}_2.fastq -min_len 70 -min_qual_mean 20 -ns_max_p 0 -lc_method dust -lc_threshold 32 -trim_left 10 -trim_right 10 -trim_qual_right 20 -trim_qual_window 10 -trim_qual_step 5 -out_format 3
done
```

</div>

Despues de eso, las *reads* limpias son ensambladas usando *MetaSPAdes*
(versión v3.12.0). Las opciones `-t` and `-m` permiten especificar el
número de cpus y memoria RAM disponible. La opción `-k` permite
especificar el largo de los k-mer por los cuales pasan las iteraciones.
La elección del largo de k-mer es basada en el largo de las *reads* y la
sensibilidad necesaria, lo que también puede influir en el tiempo de
computación. Hacer iteraciones pasando por k-mer cortos hasta k-mer
largos es una buena manera de mejorar el ensamble cuando la capacidad
computacional lo permite.

<div class="sourceCode">

``` sourceCode bash
metaspades.py -1 $filtereddir/concat_samples_1.fastq -2 $filtereddir/concat_samples_2.fastq -s $filtereddir/concat_samples_singletons.fastq -t 80 -m 1000  -k 21,33,55,77,99,127 -o $assemblydir/concat_samples
```

</div>

Finalmente, y teniendo los metagenomas ensamblados, usamos *Prokka* para
anotar cada metagenoma y predecir regiones codificantes (CDS), lo cual
nos entrega un set de sequencias proteicas predichas para cada muestra.

</div>

<div id="preparar-la-base-de-datos" class="section level2">

## <span class="header-section-number">1.2</span> Preparar la base de datos

Para la construccion de la base de datos de proteínas de interés, se
utilizó una lista de las proteínas más relevantes en los procesos del
ciclo del nitrogeno conducidos por las comunidades microbianas marinas.

Usando como referencia el articulo [Nitrogen Cycle of the Open Ocean:
From Genes to
Ecosystems](https://doi.org/10.1146/annurev-marine-120709-142819), se
generó una lista de proteínas para ser buscadas en la base de datos
[Identical protein groups](https://www.ncbi.nlm.nih.gov/ipg/?term=)
`nifH, nifD, nifK, amoC, amoA, amoB, hao, norA, norB, narD, narG, narH,
narI, narJ, napA, napB, napD, napE, nirB, nirC, nirK, nirU, nirN, nirO,
nirS, nosZ, nasA, nasB, nasC, nasD, narB, nrfA, nrfB, nrfC, nrfD, nrfE,
gdhA, gltB`

Por cada uno de los genes, se descargaron todas las proteínas completas
correspondientes (no se incluyen secuencias parciales), que se
concatenaron en un FASTA común. Luego, usando *MMseq2*, se genera una
base de datos local con el comando `mmseqs createdb`, la cual se agrupa
por similitud de secuencias con el comando `mmseqs cluster` con las
opciones `-e 1 --max-seqs 1000 -c 0.0001 --min-seq-id 0.0001
--cluster-mode 1 --kmer-per-seq 1 --alignment-mode 3`, para luego
obtener la secuencias representativas de cada grupo con `mmseqs
createseqfiledb` y `mmseqs result2repseq`, estas secuencias
representativas reemplazarán la base de datos local de mmseq2 para el
resto de los analisis.

Para cada archivo FASTA de proteínas predichas de los 4 metagenomas, se
compara contra la base de datos local utilizando mmseq2, obteniendo un
resultado tabulado de cada proteína que tiene algún homólogo en la base
de datos local.

</div>

<div id="identificar-proteinas-de-interes-en-los-metagenomas" class="section level2">

## <span class="header-section-number">1.3</span> Identificar proteinas de interés en los metagenomas

Finalmente, comparamos cada archivo conteniendo las proteínas predichas
por muestra con la base de datos usando *mmseq2*, creando una tabla de
cada proteína teniendo homólogo en la base de datos local. Este archivo
conteniendo los identificadores de las proteínas será usado para obtener
sequencias nucleotídicas, desde las cuales calcularemos la abundancia de
cada gen.

</div>

<div id="preparar-fasta-con-los-genes-presentes-en-los-metagenomas" class="section level2">

## <span class="header-section-number">1.4</span> Preparar FASTA con los genes presentes en los metagenomas

Una vez encontrado cuál gen ortólogo esta presente en los metagenomas,
queremos encontrar las sequencias nucleotídicas correspondientes, para
poder mapear las *reads*. Por eso, compilamos todos los identificadores
de proteínas en un archivo y, uno por uno, buscamos sequencias
nucleotídicas correspondientes usando `tblastn`. En caso de que no se
encuentre una sequencia con identidad sobre 70% o cobertura sobre 80%,
la proteína se descarta de la lista.

En paralelo, preparamos una tabla con el nombre de los genes
correspondientes a cada identificador de los genes ortólogos y con eso,
podemos luego traducir la abundancia de cada variante en abundancia de
cada gen de interés, y tambien visualizar la variabilidad existente en
las muestras por cada uno de los genes de interés.

</div>

<div id="mapeo-de-reads" class="section level2">

## <span class="header-section-number">1.5</span> Mapeo de *reads*

Usamos *Bowtie2* para mapear las *reads* sobre los genes contenidos en
el archivo FASTA. Dado que no todas las sequencias nucleotídicas
alcanzaron a tener 100% de identidad con las proteínas identificadas,
tenemos que relajar los parametros de alineamiento, permitiendo mas
*mismatch* y alineamientos incompletos.

Permitamos un *mismatch* (`-N 1`) y usamos alineamiento local
(`--local`).

<div class="sourceCode">

``` sourceCode bash
for i in $samples
do
bowtie2 -x $fasta_dir/goi -1 $read_dir/${i}_OK_1.fastq -2 $read_dir/${i}_OK_2.fastq -U $read_dir/${i}_OK_singletons.fastq -N 1 --local  |  samtools view -bh | samtools sort -o $bam_dir/${i}.bam
done
```

</div>

Después de que obtenemos las *reads* mapeadas, usamos la funcion
`idxstats` de Samtools para obtener el valor de cuentas *reads* mapeadas
en cada gen.

<div class="sourceCode">

``` sourceCode bash
for i in $samples
do
samtools index $bam_dir/${i}.bam
samtools idxstats $bam_dir/${i}.bam > $bam_dir/${i}.idxstats
done
```

</div>

Ahora que estos archivos han sido creados, podemos comenzar con los
análisis en R.

</div>

</div>

<div id="configurar-sesion-de-r" class="section level1">

# <span class="header-section-number">2</span> Configurar sesión de R

Primero, cargamos los paquetes de R necesarios.

Los siguientes 3 *scripts* te mostrarán una manera eficiente de instalar
y cargar la lista de paquetes según su repositorio de origen, ya que
cada repositorio tiene su propia función para instalar sus paquetes.

  - Primero, enlistar los paquetes necesarios en diferentes vectores
    dependiendo de su repositorio de origen.

<div class="sourceCode">

``` sourceCode r
# Definir paquetes
# Repositorio CRAN
cran_packages <- c("ggplot2", "gplots", "reshape2")
# Repositorio Bioconductor
bioc_packages <- "DESeq2"
```

</div>

  - Segundo, instalar los paquetes definidos arriba usando la función
    correspondiente a cada repositorio.

<div class="sourceCode">

``` sourceCode r
# Instalar paquetes CRAN
.inst <- cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(cran_packages[!.inst])
}
# Intalar paquetes BioConductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
.inst <- bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(bioc_packages[!.inst])
}
```

</div>

  - Tercero, cargar los paquetes requeridos a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
sapply(c(cran_packages, bioc_packages), require, character.only = TRUE)
```

</div>

    ##  ggplot2   gplots reshape2   DESeq2 
    ##     TRUE     TRUE     TRUE     TRUE

El paso de instalación de paquetes es necesario solamente una vez.
Excepto si se quiere actualizar la versión del paquete, o bien, R ha
sido desinstalado e instalado nuevamente o actualizado su versión.

Si ya tienes los paquetes instalados en tu computadora, sólo necesitas
enlistar (*1er script*) y cargar (*3er script*) los paquetes. También,
puedes cargarlos a la sesión actual de R usando la función `library()`,
así:

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
library(ggplot2)
library(gplots)
library(reshape2)
library(DESeq2)
```

</div>

</div>

<div id="analisis-de-abundancia-de-genes-de-interes" class="section level1">

# <span class="header-section-number">3</span> Análisis de abundancia de genes de interés

Primero, **descarga y descomprime el directorio de los datos *input***
[**AQUÍ**](https://www.dropbox.com/s/y64htz1op0456y5/gene_search_input_files.zip?dl=0).

  - Define la ruta de directorios en tu computadora hasta el directorio
    *input* `gene_search_input_files/`:

<div class="sourceCode">

``` sourceCode r
base_path <- "/path/to/gene_search_input_files/"
```

</div>

<div class="sourceCode">

``` sourceCode r
base_path <- "./"
```

</div>

  - Ahora, definimos la ruta a cada directorio que contiene datos
    *input*:

<div class="sourceCode">

``` sourceCode r
reads_directory <- paste(base_path , "reads/", sep = "")
fasta_directory <- paste(base_path , "fasta/", sep = "")
bam_directory <- paste(base_path , "bam/", sep = "")
```

</div>

<div id="obtener-la-metadata" class="section level2">

## <span class="header-section-number">3.1</span> Obtener la metadata

  - Leemos la tabla que contiene los datos asociados a cada muestra
    (*metadata*) en el objeto llamado `metadata`.

<div class="sourceCode">

``` sourceCode r
path <- paste(base_path, "metadata.csv", sep = "")
metadata <- read.table(path, sep = "\t", header=T)
metadata
```

</div>

    ##   Sample Depth_m Sampling_date
    ## 1    EC5     100        Sep-15
    ## 2   EC11     150        Feb-18
    ## 3  EC100     100        Jan-15
    ## 4   EC19     150        Jul-18

</div>

<div id="preparar-tabla-de-cuentas" class="section level2">

## <span class="header-section-number">3.2</span> Preparar tabla de cuentas

  - Comenzamos enlistando los archivos `.idxstats` presentes en el
    directorio. Debería haber un archivo por muestra.

<div class="sourceCode">

``` sourceCode r
stat_list <- list.files(bam_directory, pattern = "\\.idxstats$")
stat_list
```

</div>

    ## [1] "EC100.idxstats" "EC11.idxstats"  "EC19.idxstats"  "EC5.idxstats"

Después, vamos a cargar estos archivos, uno a la vez, y construiremos la
tabla de cuentas.

Los archivos `.idxstats` contienen el identificador del gen, seguido por
el largo del gen, el número de *reads* mapeados y número de *reads* no
mapeados.

Empezamos con leer la tabla y añadir nombre a las columnas. Dado que el
tamaño del gen varía, necesitamos normalizar los valores de cuentas por
el largo del gen, dado que genes mas largos permiten mapear más *reads*
que genes más cortos con la misma abundancia.

Una vez normalizados los valores de abundancia, necesitamos añadir este
valor a una tabla general. Multiplicamos el valor normalizado por
1000000 para tener valores en un rango mas manejable.

Una de las líneas de los archivos `.idxstat` comienza con `*` y esta
usada para añadir información que no pertenece a la tabla, por lo mismo,
la removemos.

<div class="sourceCode">

``` sourceCode r
for (i in c(1:length(stat_list)))
{
sample_stat <- read.table(paste(bam_directory,stat_list[i], sep=""), header = F)
colnames(sample_stat) <- c("id","length","mapped","unmapped")
sample_stat <- sample_stat[! sample_stat$id == "*",]
sample_stat$count <- sample_stat$mapped / sample_stat$length *1000000
colnames(sample_stat)[5] <- strsplit(stat_list[i], "\\.")[[1]][1]
if (i == 1)
 {
  table_stat <- sample_stat[,c(1,5)]
 }
else
 {
  table_stat <- merge(table_stat, sample_stat[,c(1,5)])
 }
}
```

</div>

Ahora, hemos normalizado las cuentas de las *reads* por el largo del
gen, pero no hemos tomado en cuenta el tamaño de la librería (*número de
secuencias por muestra*). Una mayor profundidad de secuenciación implica
un mayor número de *reads* mapeando en contra de genes de interés,
incrementando su abundancia de forma artificial.

  - Para normalizar por el tamaño de la librería, usamos la función
    `echo bash` para calcular el número de *reads* totales por muestras:
    número de líneas del archivo FASTQ dividido por 4 = número de
    *reads*.

<div class="sourceCode">

``` sourceCode r
samples <- vapply(strsplit(stat_list, ".", fixed = TRUE), "[", "", 1)

lib_size <- vector()

for (i in c(1:length(samples)))
{
echo_command <- paste("echo $(cat ", reads_directory, samples[i], "_OK_1.fastq|wc -l)/4|bc", sep="")
lib_size <- c(lib_size,system(echo_command, intern = TRUE))
}

lib_size <- as.numeric(lib_size)
```

</div>

Ahora que tenemos el número de *reads* por muestra, vamos a crear la
tabla de cuentas normalizada. Después, nuevamente, multiplicamos el
valor normalizado por 100000 para tener valores manejables.

<div class="sourceCode">

``` sourceCode r
table_normalized <- table_stat

for (i in c(1:4))
{
n = i+1
table_normalized[,n] <- table_stat[,n]/lib_size[i]*100000
}
```

</div>

  - Ahora que tenemos los valores de abundancia normalizados por tamaño
    de librería, necesitamos generar la tabla de correspondencia entre
    el ID del gen y el nombre del gen de interés. Debido a que algunos
    genes no presentan match en los metagenomas, removemos aquellas
    filas sin ID correspondiente.

<div class="sourceCode">

``` sourceCode r
path <- paste(fasta_directory, "gene_table.tsv", sep="")
gene_names <- read.table(path, header = F)

gene_names <- gene_names[! is.na(gene_names$V2),]
```

</div>

La tabla contiene los nombres de los genes en la primera columna, y en
la segunda columna, el ID de los genes separados por `,`. Desde esto nos
interesa extraer la siguiente información: una tabla de correspondencia
uno a uno entre el nombre de los genes y el ID de los genes, y una tabla
con el número de variantes por gen.

Vamos a crear la estructura para ambas tablas, para después leer la
tabla original línea por línea e ir rellenando las tablas nuevas.

<div class="sourceCode">

``` sourceCode r
id_gene <- as.data.frame(matrix(ncol = 2, nrow=length(table_normalized$id) , NA))
colnames(id_gene) <- c("id","gene")
gene_versions <- as.data.frame(matrix(ncol = 2, nrow=length(gene_names$V1) , NA))
colnames(gene_versions) <- c("gene","version_nb")
```

</div>

<div class="sourceCode">

``` sourceCode r
gene_names$V2 <- as.character(gene_names$V2)
gene_names$V1 <- as.character(gene_names$V1)
n <- 0
for (i in c(1:length(gene_names$V1)))
{
 gene <- gene_names$V1[i]
 id_vect <- as.vector(unlist(strsplit(gene_names$V2[i], split=",") ) )
 if(length(id_vect) == 1)
 {
   n = n+1
   id_gene$id[n] <- gene_names$V2[i]
   id_gene$gene[n] <- gene_names$V1[i]
   gene_versions$gene[i] <- gene_names$V1[i]
   gene_versions$version_nb[i] <- 1
 } else
 {
   gene_versions$gene[i] <- gene_names$V1[i]
   gene_versions$version_nb[i] <- length(id_vect)
   for (j in c(1:length(id_vect)))
   {
    n = n+1
    id_gene$id[n] <- id_vect[j]
    id_gene$gene[n] <- gene_names$V1[i]
   }
 }
}
```

</div>

</div>

<div id="abundance" class="section level2">

## <span class="header-section-number">3.3</span> Abundancia de genes por muestra

  - Comenzaremos por la visualización de las *read count* para los
    diferentes genes y versiones. Para ello, agregamos el nombre de los
    genes a la tabla que contiene los valores de cuentas por ID de los
    genes.

<div class="sourceCode">

``` sourceCode r
table_all <- merge(table_normalized, id_gene, by.all=id)
```

</div>

  - Generamos un gráfico de barras (*barplot*) para visualizar la
    abundancia de los genes en cada muestra. Para tomar en cuenta las
    variantes del gen, vamos a graficar una barra por cada variante, y
    luego, agrupamos por gen. Para ello, debemos preparar la tabla de
    datos para que tenga todos los valores en una misma columna, y otra
    información en columnas separadas (una para el nombre de las
    muestras, otra para el nombre de los genes, y otra para el ID de la
    variante). Hacemos esto usando la función `melt` para colapsar las
    columnas que contienen el valor de las cuentas, conserbando la
    columna con el ID como referencia, y luego, agregar el nombre del
    gen.

<div class="sourceCode">

``` sourceCode r
tmp_table <- melt(data = table_all[,c(1:5)], id.vars = "id")
plot_table <- merge(tmp_table,  id_gene, by.all=id)
```

</div>

  - Entonces, usamos ggplot2 para graficar: graficar los valores por ID,
    apilar valores para cada muestra y agruparlos por nombre del gen.
    También, utilizamos una escala logarítmica para poder apreciar la
    variación de genes con menor abundancia.

<div class="sourceCode">

``` sourceCode r
ggplot(plot_table[which(plot_table$value > 0),] , aes(x = id,y = value)) + 
  geom_bar(aes(color=variable, fill=variable), stat="identity", position="stack")  +  
  facet_grid(~gene, scales="free_x" ) +  
  scale_y_log10() + 
  theme( axis.text.x=element_blank(), axis.ticks.x=element_blank()) + 
  labs(x = "gene variants", y="abundance")
```

</div>

![](images/barplot.png)

Basándonos en el gráfico, vemos que varios genes tales como *amoA*,
*amoB*, y *amoC* parecen estar presentes en todas las muestras en
abundancia similar. Mientras que otros genes tales como *nirC*, *nirK* y
*nirN* parecen ser específicos para algunas muestras. Los genes con
varias variantes, tales como *napA* y *narG*, muestran que aunque
algunas variantes están igualmente presentes en todas las muestras,
otras son específicas para una o más muestras. Esto es interesante, por
ejemplo en el caso de *napA*, las muestras EC19 y EC100 tienen una
abundancia total similar de este gen, pero provienen de versiones
diferentes del gen.

Podemos ver que muestras, tales como EC11, tienen muchos de los genes de
interés mientras que muestras, tales como EC19 tienen un número menor de
estos genes.

Ahora bien, si miramos la metadata notamos que todas las muestras fueron
colectadas en diferentes tiempos lo que podría explicar la alta
especificidad por muestra de los datos.

</div>

<div id="test-estadistico-de-abundancia-diferencial" class="section level2">

## <span class="header-section-number">3.4</span> Test estadístico de abundancia diferencial

Para ver si la abundancia de algunos genes es conducida por la
profundidad de las muestras, usamos el paquete *DESeq2*. DESeq2 evalúa
si las diferencias en abundancia de un gen entre dos condiciones es
significativa o no. Aquí, vamos a definir la profundidad como condición
para evaluar la abundancia de los genes de interés.

DESeq2 toma como *input* las *read count* y realiza el proceso de
normalización. Sin embargo, asume que el total de *read count* es
proporcional al tamaño de la librería, lo que no es necesariamente
verdadero en este caso en el que estamos analizando un grupo pequeño de
genes seleccionados. Por lo tanto, usaremos los valores de abundancia
que previamente normalizamos por tamaño de librería como *input* para
DESeq2.

  - Para correr DESeq2, necesitamos: una tabla de cuentas por cada gen y
    por cada muestra (aquí `table_normalized`) con los ID de los genes
    como *row names*, y la metadata con la profundidad definida como
    variable categórica (`factor`).

  - Debido a que DESeq2 espera una tabla de cuentas como *input*
    (*integer values*), es necesario redondear los valores en la tabla
    `table_normalized` para que sean números enteros.

<!-- end list -->

    ## [1] "100" "150" "150" "100"

    ## converting counts to integer mode

    ## estimating size factors

    ## estimating dispersions

    ## gene-wise dispersion estimates

    ## mean-dispersion relationship

    ## final dispersion estimates

    ## fitting model and testing

    ## [1] "Intercept"          "Depth_m_150_vs_100"

    ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    ##  0.2120  0.6295  0.6364  0.6761  0.7366  0.8168

Podemos ver en los valores de p-values ajustados que no hay valores
menores a 0.2, indicando que ninguna de las diferencias entre muestras
de diferente profundidad es significativa. Esto se puede deber a varios
factores, podría significar que las diferencias en profundidad
comprendida en las muestras no tienen influencia en el metabolismo de el
nitrógeno en la OMZ, pero hay muchos otros factores a considerar.
Primero, el número de muestras es muy bajo y un mayor número de muesras
y réplicas conducen a identificar diferencias con mayor precisión. Otro
factor a considerar es que todas las muestras fueron colectadas en
fechas diferentes, lo que significa que en el caso de que el metabolismo
del nitrógeno varíe por profundidad y por fecha, las diferencias por
fecha podrían estar enmascarando cualquier diferencia debido a la
profundidad.

</div>

<div id="evaluacion-cualitativa-de-abundancia-de-genes" class="section level2">

## <span class="header-section-number">3.5</span> Evaluación cualitativa de abundancia de genes

A pesar de que las muestras no nos entregan suficiente información para
las pruebas estadísticas, podemos hacer una evaluación cualitativa de la
abundancia de genes por muestra. Para ello, podemos graficar un
*heatmap* junto con un *hierarchical clustering* de los genes, de
acuerdo a sus valores de abundancia a través de las muestras, y de las
muestras, de acuerdo a sus valores de abundancia de los genes de
interés.

Esto nos permitirá ver qué muestras son similares y qué genes se
encuentran generalmente juntos.

<div class="sourceCode">

``` sourceCode r
my_palette <- colorRampPalette(c("lightyellow", "lightslateblue", "darkorchid"))(104)


x_labels <- paste(colnames(table_all[,c(2:5)]), metadata$Sampling_date, metadata$Depth_m, sep="\n")

heatmap.2(as.matrix(table_all[,c(2:5)]), scale="row", labRow = table_all$gene, labCol = x_labels , cexCol=0.8 , col=my_palette, trace="none", margins = c(7, 7), key.par = list(cex=0.5),  lhei=c(2,4), lwid=c(1.5,4), keysize=0.75)
```

</div>

![](gene_search_files/figure-html/unnamed-chunk-23-1.png)

</div>

</div>

<div id="conclusiones-acerca-del-metabolismo-del-nitrogeno-en-omz" class="section level1">

# <span class="header-section-number">4</span> Conclusiones acerca del metabolismo del nitrógeno en OMZ

Vamos a darle un vistazo a la siguiente tabla tomada del artículo [Zehr
and Kudela](https://doi.org/10.1146/annurev-marine-120709-142819), que
nos indica en que proceso participa cada gen.

![](images/table_genes.jpg)

Vamos a agregar esta información al *heatmap*.

  - Primero, agregamos una nueva columna a la tabla para incorporar la
    información acerca del proceso bilógico en el que participa cada
    gen.

<div class="sourceCode">

``` sourceCode r
table_all$process <- NA
table_all$process[table_all$gene %in% c("nifH","nifD","nifK","nifG")] <- "Nitrogen fixation"
table_all$process[table_all$gene %in% c("amoC","amoA","amoB","hao")] <- "Ammonium oxidation"
table_all$process[table_all$gene %in% c("norA","norB")] <- "Nitrite oxidation"
table_all$process[table_all$gene %in% c("narH","narJ")] <- "Heterotrophic oxidation"
table_all$process[table_all$gene %in% c("hfz")] <- "Anaerobic ammonia oxidation"
```

</div>

> **Keep filling the process in the same way.**

<div class="sourceCode">

``` sourceCode r
unique(table_all$process)
```

</div>

    ## [1] "Dissimilatory nitrate reduction and denitrification"
    ## [2] "Ammonium oxidation"                                 
    ## [3] "Assimilatory nitrate and nitrite reduction"         
    ## [4] "Ammonium assimilation"                              
    ## [5] "Dissimilatory nitrate reduction to ammonia"

Podemos ver entonces que tenemos 5 procesos diferentes representados en
nuestras muestras.

  - Vamos a definir 5 colores para personalizar la visualización. Y
    graficamos el *heatmap* nuevamente.

<div class="sourceCode">

``` sourceCode r
#palette_gimp <- c("#b3b477","#f8c47c","#81b477","#b8f87c","#77b48b","#7cf8a1","#76b4aa","#7cc7f8","#7791b4","#7c93f8","#8177b4","#b17cf8","#a077b4","#e57cf8","#b477a5","#f87ca9", "#9d9d9d" , "#b47781","#f87c7c","#b49677", "#f8de7c")
#color_bar <- palette_gimp[as.numeric((as.factor(table_all$process)))]

color_bar <- table_all$process
color_bar[color_bar %in% "Dissimilatory nitrate reduction and denitrification"] <- "cornflowerblue"
color_bar[color_bar %in% "Ammonium oxidation"] <- "gold"
color_bar[color_bar %in% "Assimilatory nitrate and nitrite reduction"] <- "deeppink"
color_bar[color_bar %in% "Ammonium assimilation"] <- "midnightblue"
color_bar[color_bar %in% "Dissimilatory nitrate reduction to ammonia"] <- "greenyellow"

x_labels <- paste(colnames(table_all[,c(2:5)]), metadata$Sampling_date, metadata$Depth_m, sep="\n")

par(oma=c(0,0,3,0),xpd=TRUE)

heatmap.2(as.matrix(table_all[,c(2:5)]), scale="row", labRow = table_all$gene, labCol = x_labels , cexCol=0.8 , col=my_palette, trace="none", margins = c(7, 7), RowSideColors=color_bar , key.par = list(cex=0.5),  lhei=c(2,4), lwid=c(1.5,4), keysize=0.75, colRow = color_bar)

legend(x=0.65,y=1.34,      
    legend = unique(table_all$process),
    col = unique(color_bar), 
    lty= 1,             
    lwd = 5,           
    cex=.6 ,
    bty="n"
    )
```

</div>

![](gene_search_files/figure-html/unnamed-chunk-27-1.png)

Los primeros 3 genes *amoA*, *amoB* y *amoC* que son todos parte de
proceso *ammonium oxidation*, son más abundantes en la muestra EC100. Es
importante notar que los valores de abundancia están normalizados por
filas en la tabla. Es decir, aunque las muestras EC19 y EC5 presenten
bajo z-score, esto no significa que presenten una baja abundancia
absoluta de este gen, sino que se encuentran en la fracción menor de los
valores de abundancia de los genes de interés en este pequeño grupo de
muestras. En efecto, si regresamos a mirar el gráfico de barras de la
sección [3.3](#abundance), esos gene presentan una abundancia mucho más
alta en todas las muestras que cualquier otro gen de nuestra lista.

Teniendo esto en mente, aquí podemos mirar las diferencias entre las
muestras.

Podemos notar que ambas muestras colectadas a 150 metros de profundidad
tienen un grupo de alta abundancia de genes involucrados en
*Dissimilatory nitrate reduction and denitrification* y *Assimilatory
nitrate and nitrite reduction*. Aunque el mismo proceso es enriquecido
en esas muestras, diferentes grupos de genes, o ortólogos son de alta
abundancia en una de las otras muestras. Esto podría reflejar que aunque
las comunidades microbianas podrían haber cambiado entre 2015 y 2018,
las funciones de la comunidad microbiana se conservan. Por ejemplo, en
el caso de *Assimilatory nitrate and nitrite reduction*, EC5 es
enriquecida en *nasD* y *nasA*, mientras que EC11 es enriquecida en
*nasB* y en otra variante de *nasA*. También, ambas muestras presentan
alta abundancia de *nosZ*, pero con variantes diferentes; y para *napA*,
varias variantes se presentan con altos valores de abundancia en EC5 y
otras en EC11.

Otra función que parece ser específica a cierta profundidad es
*Dissimilatory nitrate reduction to ammonia*, para la cual EC100 esta
enriquecida en *nrfD*, mientras que EC19 está enriquecida en *nrfA*.

Esto nos muestra que la ausencia de abundancia diferencial entre dos
profundidades diferente no necesariamente implica que la profundidad no
tenga una influencia en el metabolismo del nitrógeno, y que las
similitudes funcionales puedes existir a pesar de las diferencias a
nivel taxonómico en las comunidades microbianas.

-----

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

</div>

</div>

</div>

</div>

</div>

</div>

</div>

<div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

<div class="book-summary">

  - [Introducción a phyloseq y a análisis de
    diversidad](http://www.castrolab.org/isme/biodiversity/biodiversity.html)

  - 
  - [****0.1** Acerca del curso](#workshop)

  - [****1** Instalación de paquetes de
    R](#instalacion-de-paquetes-de-r)

  - [****2** Introducción a phyloseq](#introduccion-a-phyloseq)
    
      - [****2.1** Control de calidad del análisis de
        16S](#control-de-calidad-del-analisis-de-16s)
      - [****2.2** Estructura y manipulación de un objeto
        `phyloseq`](#estructura-y-manipulacion-de-un-objeto-phyloseq)

  - [****3** Introducción al análisis de
    diversidad](#introduccion-al-analisis-de-diversidad)
    
      - [****3.1** Medidas de riqueza, uniformidad, dominancia,
        diversidad filogenética (diversidad
        alfa)](#medidas-de-riqueza-uniformidad-dominancia-diversidad-filogenetica-diversidad-alfa)
      - [****3.2** Diversidad beta y escalamiento multidimensional
        (Bray-Curtis, UniFrac,
        t-SNE)](#diversidad-beta-y-escalamiento-multidimensional-bray-curtis-unifrac-t-sne)
      - [****3.3** Análisis de abundancias y
        visualizaciones](#analisis-de-abundancias-y-visualizaciones)
          - [****3.3.1** Gráfico de barras
            apiladas](#grafico-de-barras-apiladas)
          - [****3.3.2** Diferentes visualizaciones de
            abundancias](#diferentes-visualizaciones-de-abundancias)
          - [****3.3.3** Análisis de abundancia diferencial de
            microorganismos](#analisis-de-abundancia-diferencial-de-microorganismos)
          - [****3.3.4** Redes de
            co-ocurrencia](#redes-de-co-ocurrencia)

  - 
  - [CASTRO LAB](http://www.castrolab.org)

  - [ISME LA 2019](https://isme-la2019.org)

</div>

<div class="book-body">

<div class="body-inner">

<div class="book-header" role="navigation">

# **[Introducción a phyloseq y a análisis de diversidad](./)

</div>

<div class="page-wrapper" tabindex="-1" role="main">

<div class="page-inner">

<div id="section-" class="section normal">

<div id="header">

*ISME Latin America, Septiembre 2019*

</div>

<div id="workshop" class="section level2">

## <span class="header-section-number">0.1</span> Acerca del curso

El tutorial a continuación fue creado especialmente para guiar el
trabajo práctico del [**curso pre-congreso ISME Latin
America 2019**](https://isme-la2019.org/curso-pre-congreso/): **Análisis
de datos bioinformáticos para metagenomas y amplicones usando R**. A
realizarse el próximo 9 y 10 de septiembre en la [Universidad Técnica
Federico Santa María](https://www.usm.cl), Valparaíso, Chile.

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

El curso cuenta con **6 unidades**. Ahora, usted se encuentra en la
unidad: **Introducción a phyloseq y a análisis de diversidad**
![](images/bacteria.png)

> **Otras unidades del curso son**:
> 
> [**Introducción a R: Manipulación de datos y
> visualización**](http://www.castrolab.org/isme/introR/introR.html)
> ![](images/r.png)
> 
> [**Análisis de secuencias de 16S con
> DADA2**](http://www.castrolab.org/isme/dada2/dada2.html)
> ![](images/bioinformatics.png)
> 
> [**Búsqueda de genes de interés en datos de metagenómica
> *shotgun***](http://www.castrolab.org/isme/gene_search/gene_search.html)
> ![](images/gene_search.png)
> 
> [**Visualización y curación de genomas ensamblados desde metagenomas
> (MAGs)**](http://www.castrolab.org/isme/mags/mags.html)
> ![](images/genome.png)
> 
> [**Redes de co-ocurrencia de
> microorganismos**](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)
> ![](images/network.png)

-----

  - Profesor: **Dr. Eduardo Castro-Nallar** (<eduardo.castro@unab.cl>)

  - Ayudantes:
    
      - **Dr. Florence Gutzwiller** (<florence.gutzwiller@gmail.com>)
      - **M.Sc. Katterinne N. Mendez** (<mendez.katterinne@gmail.com>)

**[CASTRO LAB](http://www.castrolab.org)**

[Centro de Bioinformática y Biología Integrativa](http://www.cbib.cl) |
[Universidad Andrés Bello](https://www.unab.cl)

![](images/UNAB_CBIB_horizontal.png)

[Santiago, Chile](https://goo.gl/maps/BCe9hWcRZJKkhaDP8)

</div>

<div id="instalacion-de-paquetes-de-r" class="section level1">

# <span class="header-section-number">1</span> Instalación de paquetes de R

Los siguientes 3 *scripts* te mostrarán una manera eficiente de instalar
y cargar la lista de paquetes según su repositorio de origen, ya que
cada repositorio tiene su propia función para instlar sus paquetes.

  - Primero, enlistar los paquetes necesarios en diferentes vectores
    dependiendo de su repositorio de origen.

<div class="sourceCode">

``` sourceCode r
# Definir paquetes
## Repositorio CRAN
cran_packages <- c("bookdown", "knitr", "tidyverse", "plyr", "grid", "gridExtra", "kableExtra", "xtable", "ggpubr")
## Repositorio Bioconductor
bioc_packages <- c("phyloseq", "dada2", "DECIPHER", "phangorn", "ggpubr", "BiocManager","DESeq2", "microbiome", "philr")
## Repositorio GitHub
git_source <- c("twbattaglia/btools", "gmteunisse/Fantaxtic", "MadsAlbertsen/ampvis2", "opisthokonta/tsnemicrobiota") # fuente/nombre del paquete
git_packages <- c("btools", "fantaxtic", "ampvis2", "tsnemicrobiota") # nombre del paquete
```

</div>

  - Segundo, instalar los paquetes definidos arriba usando la función
    correspondiente a cada repositorio.

<div class="sourceCode">

``` sourceCode r
# Instalar paquetes CRAN
.inst <- cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(cran_packages[!.inst])
}
# Intalar paquetes BioConductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
.inst <- bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(bioc_packages[!.inst])
}
# Instalar paquetes GitHub
.inst <- git_source %in% installed.packages()
if(any(!.inst)) {
  devtools::install_github(git_source[!.inst])
}
```

</div>

  - Tercero, cargar los paquetes requeridos a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
sapply(c(cran_packages, bioc_packages, git_packages), require, character.only = TRUE)
```

</div>

El paso de instalación de paquetes es necesario solamente una vez.
Excepto si se quiere actualizar la versión del paquete, o bien, R ha
sido desinstalado e instalado nuevamente o actualizado su versión.

Si ya tienes los paquetes instalados en tu computadora, sólo necesitas
enlistar (*1er script*) y cargar (*3er script*) los paquetes. También,
puedes cargarlos a la sesión actual de R usando la función `library()`,
así:

    # Cargar paquetes
    library(tidyverse)
    library(plyr)
    library(grid)
    library(gridExtra)
    library(kableExtr)
    library(xtable)
    library(ggpubr)
    library(phyloseq)
    library(dada2)
    library(DECIPHER)
    library(phangorn)
    library(ggpubr)
    library(BiocManager)
    library(DESeq2)
    library(microbiome)
    library(philr)
    library(btools)
    library(fantaxtic)
    library(ampvis2)
    library(tsnemicrobiota)

</div>

<div id="introduccion-a-phyloseq" class="section level1">

# <span class="header-section-number">2</span> Introducción a phyloseq

**[Phyloseq](https://joey711.github.io/phyloseq/index.html)** es un
paquete de [Bioconductor](https://www.bioconductor.org) (*Open Source
Software For Bioinformatics*) para la manipulación y análisis de datos
metagenómicos generados por metodologías de secuenciación de alto
rendimiento. `phyloseq` es una herramienta para importar, guardar,
analizar y visualizar éste tipo de datos después de haber sido
procesados inicialmente, e.g., ensamblaje *de novo*, ASVs u OTUs
(*clustered*), incluyendo otros importantes datos asociados (si están
disponibles): tabla de observaciones asociadas a cada muestra (e.g.,
especie, localización geográfica, temperatura, etc.), conocida como
*sample data* o *metadata*, árbol filogenético, e identificación
taxonómica de cada OTU. La estructura del paquete `phyloseq` consiste
en una serie de funciones de acceso y de proceso de objetos `phyloseq`.
Estos objetos están compuestos de cuatro componentes que almacenan las
cuentas de reads, la metadata, la taxonomía y el árbol filogenético. El
paquete también provee una serie de herramientas para importar datos de
otros programas. El siguiente diagrama muestra la estructura completa de
`phyloseq`.

<div class="figure">

![](images/phyloseq_structure.png)

</div>

  - Si no tienes el objeto phyloseq `ps` generado por DADA2 puedes
    descargarlo haciendo clic:
    [**AQUÍ**](https://www.dropbox.com/s/df1aie9angv16gk/ps.RDS?dl=0)

  - En la terminal de **R** cargamos el objeto phyloseq:

<div class="sourceCode">

``` sourceCode r
# Leémos el objeto phyloseq del análisis por DADA2
readRDS("ps.RDS") -> psd
psd
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 1476 taxa and 98 samples ]
    ## sample_data() Sample Data:       [ 98 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 1476 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 1476 tips and 1474 internal nodes ]

<div id="control-de-calidad-del-analisis-de-16s" class="section level2">

## <span class="header-section-number">2.1</span> Control de calidad del análisis de 16S

Lo primero que podemos mirar es la prevalencia de las *features*
taxonómicas.

  - Primero creamos un data frame con los valores de prevalencia, luego
    les agregamos la taxonomía y graficamos.

<div class="sourceCode">

``` sourceCode r
# Computamos prevalencia para cada feature y la guardamos en un data frame
prevdf = apply(X = otu_table(psd),
               MARGIN = ifelse(taxa_are_rows(psd), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})
# Le agregamos la taxonomía
prevdf = data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(psd),
                    tax_table(psd))

plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))}) -> dfprev
kable(dfprev)
```

</div>

| Phylum                          |        1 |    2 |
| :------------------------------ | -------: | ---: |
| Acidobacteria                   | 3.800000 |   38 |
| Actinobacteria                  | 5.041667 |  363 |
| Bacteroidetes                   | 5.719388 | 2242 |
| BRC1                            | 1.000000 |    1 |
| Chloroflexi                     | 1.750000 |   21 |
| Ciliophora                      | 3.000000 |    9 |
| Cyanobacteria                   | 4.223881 |  283 |
| Deinococcus-Thermus             | 1.333333 |    4 |
| Epsilonbacteraeota              | 2.760000 |   69 |
| Euryarchaeota                   | 3.714286 |   26 |
| Firmicutes                      | 4.685315 |  670 |
| Fusobacteria                    | 3.500000 |   70 |
| Gemmatimonadetes                | 1.000000 |    2 |
| Kiritimatiellaeota              | 1.000000 |    1 |
| Lentisphaerae                   | 1.250000 |    5 |
| Marinimicrobia\_(SAR406\_clade) | 3.500000 |    7 |
| Nanoarchaeaeota                 | 1.000000 |    1 |
| Nitrospinae                     | 1.000000 |    1 |
| Ochrophyta                      | 1.000000 |    1 |
| Patescibacteria                 | 5.473684 |  312 |
| Planctomycetes                  | 3.235294 |  110 |
| Proteobacteria                  | 8.233840 | 4331 |
| Schekmanbacteria                | 1.000000 |    1 |
| Spirochaetes                    | 1.500000 |    3 |
| Tenericutes                     | 6.083333 |   73 |
| Thaumarchaeota                  | 4.000000 |   12 |
| Verrucomicrobia                 | 4.814815 |  130 |
| NA                              | 6.425532 |  302 |

Al examinar la tabla, es evidente que algunos Phylum aunque presentes,
están muy poco representados. La columna 1 representa la media de *read
counts* para ese Phylum, mientras que la columna 2 representa la suma.
Por ejemplo, grupos como BRC1, Kiritimatiellaeota, y Nanoarchaeaeota
están representados solamente por 1 read. Es muy riesgoso mantener
estos grupos taxonómicos en el análisis ya que pueden corresponder a
falsos positivos.

  - Para filtrarlos, generamos un vector con todas las taxa que queremos
    filtrar.

<div class="sourceCode">

``` sourceCode r
# Definimos taxa a filtrar
filterPhyla = c("BRC1", "Deinococcus-Thermus", "Gemmatimonadetes", "Kiritimatiellaeota", "Nanoarchaeaeota", "Ochrophyta", "Schekmanbacteria", "Ciliophora", "Spirochaetes", NA)

# Procedemos a filtrar
(psd1 = subset_taxa(psd, !Phylum %in% filterPhyla))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 1414 taxa and 98 samples ]
    ## sample_data() Sample Data:       [ 98 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 1414 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 1414 tips and 1412 internal nodes ]

<div class="sourceCode">

``` sourceCode r
# Además aprovechamos a remover taxa que no corresponde a microorganismos como cloroplastos, mitocondrias y otros

filterPhyla2 <- c("Chloroplast", "Mitochondria", "Eukaryota")
psd1 <- subset_taxa(psd1, !Kingdom %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Phylum %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Class %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Order %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Family %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Genus %in% filterPhyla2)
```

</div>

  - Además del filtrado que acabamos de realizar, existen otros tipos de
    filtrado que tienen que ver con la media de *read counts* por taxa,
    con la distribución de éstas, y con filtrar muestras bajo un número
    mínimo de reads.

<div class="sourceCode">

``` sourceCode r
# Filtramos taxa de acuerdo a un umbral de número medio de _read counts_, en este caso 1e-5
psd2 <- filter_taxa(psd1, function(x) mean(x) > 1e-5, TRUE)

# También podemos remover taxa que no se observe más de X veces en al menos 10% de las muestras
psd3 <- filter_taxa(psd2, function(x) sum(x > 2) > (0.1*length(x)), TRUE)

# Y finalmente filtrar muestras con menos de 1000 reads
psd4 = prune_samples(sample_sums(psd3) > 1000, psd3)

psd4
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 136 taxa and 87 samples ]
    ## sample_data() Sample Data:       [ 87 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 136 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 136 tips and 135 internal nodes ]

  - Otra forma de filtrar taxa de baja prevalencia es estableciendo un
    umbral y luego visulizar el efecto de manera grafica.

<div class="sourceCode">

``` sourceCode r
# Seleccionamos las taxa de interés
prevdf1 = subset(prevdf, Phylum %in% get_taxa_unique(psd4, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(psd),color=Phylum)) +

# Agregamos una línea para nuestro umbral
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-6-1.png)

<div class="sourceCode">

``` sourceCode r
# Definimos el umbral de prevalencia a un 5%
(prevalenceThreshold = 0.05 * nsamples(psd4))
```

</div>

    ## [1] 4.35

<div class="sourceCode">

``` sourceCode r
# Execute prevalence filter, using `prune_taxa()` function
keepTaxa = rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
(psd5 = prune_taxa(keepTaxa, psd4))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 136 taxa and 87 samples ]
    ## sample_data() Sample Data:       [ 87 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 136 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 136 tips and 135 internal nodes ]

DADA2 usa como nombre de las taxa la secuencia o ASV asociada a un taxon
determinado. Esto es conveniente cuando nos interesa la secuencia en
nuestros análisis, sin embargo en este práctico solamente vamos a
trabajar a nivel de comunidad.

  - Por esto, vamos a reemplazar esos nombres con códigos correlativos,
    lo cual va a hacer las visualizaciones posteriores más entendibles.

<div class="sourceCode">

``` sourceCode r
# Reemplazamos las secuencias por un nombre genérico
taxa_names(psd5) <- paste0("ASV", seq(ntaxa(psd5)))
```

</div>

  - Con nuestro *objeto phyloseq* ya filtrado y listo para usar, podemos
    gráficar la distribución de *read counts* por número de muestra de
    forma de tener una idea sobre la distribución de éstas.

<div class="sourceCode">

``` sourceCode r
sample_sum_df <- data.frame(sum = sample_sums(psd5))

ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank()) 
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-8-1.png)

  - Finalmente, calculamos curvas de rarefacción para cada muestra, de
    manera tal que podamos determinar si la profundidad de secuenciación
    fue sufuciente o si tal vez necesitemos secuenciar más. En otras
    palabras, este análisis nos permitiría averiguar si al secuenciar
    más observaríamos más OTUs o ASVs.

<div class="sourceCode">

``` sourceCode r
# Primero cargamos algunos scripts de manera remota
scripts <- c("graphical_methods.R",
             "tree_methods.R",
             "plot_merged_trees.R",
             "specificity_methods.R",
             "ternary_plot.R",
             "richness.R",
             "edgePCA.R",
             "copy_number_correction.R",
             "import_frogs.R",
             "prevalence.R",
             "compute_niche.R")
urls <- paste0("https://raw.githubusercontent.com/mahendra-mariadassou/phyloseq-extended/master/R/", scripts)

for (url in urls) {
  source(url)
}
```

</div>

<div class="sourceCode">

``` sourceCode r
# Y graficamos
p <- ggrare(psd5, step = 100, color = "species", label = "sample_ID", se = TRUE)
(p <- p + facet_wrap(~species))
```

</div>

<div class="figure">

![](images/rarefaction.png)

</div>

Los gráficos están separados por especies de ballena, azul
(*Balaenoptera musculus*), fin (*Balaenoptera physalus*), franca
(*Eubalaena australis*), y jorobada (*Megaptera novaeangliae*) y
muestran la cantidad de Taxa (riqueza o diversidad alfa) en función del
tamaño muestreal o número de reads. Podemos ver que la mayoría de las
muestras de ballena azul y jorobada alcanzan un plateau. Esto significa
que el *retorno en la inversión* disminuye si seguimos secuenciando, o
de otra forma, que ya hemos muestreado toda la diversidad de esa
muestra. Al contrario, algunas muestras de ballena fin no alcanzaron el
plateau, lo cual implica que la diversidad alfa estaría subestimada.

</div>

<div id="estructura-y-manipulacion-de-un-objeto-phyloseq" class="section level2">

## <span class="header-section-number">2.2</span> Estructura y manipulación de un objeto `phyloseq`

Muchas veces queremos analizar un sub conjunto de las muestras en
nuestro objeto phyloseq, o bien, queremos seleccionar ciertos grupos
taxonómicos para análisis posteriores. phyloseq nos permite hacer todo
tipo de filtros para llevar esto a cabo. Veamos dónde se almacena la
información en phyloseq.

  - Primero la tabla de cuentas.

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:350px; overflow-x: scroll; width:100%; ">

|            | ASV1 | ASV2 | ASV3 |  ASV4 | ASV5 | ASV6 | ASV7 | ASV8 |  ASV9 | ASV10 | ASV11 | ASV12 | ASV13 | ASV14 | ASV15 | ASV16 | ASV17 | ASV18 | ASV19 | ASV20 | ASV21 | ASV22 | ASV23 | ASV24 | ASV25 | ASV26 | ASV27 | ASV28 | ASV29 | ASV30 | ASV31 | ASV32 | ASV33 | ASV34 | ASV35 | ASV36 | ASV37 | ASV38 | ASV39 | ASV40 | ASV41 | ASV42 | ASV43 | ASV44 | ASV45 | ASV46 | ASV47 | ASV48 | ASV49 | ASV50 | ASV51 | ASV52 | ASV53 | ASV54 | ASV55 | ASV56 | ASV57 | ASV58 | ASV59 | ASV60 | ASV61 | ASV62 | ASV63 | ASV64 | ASV65 | ASV66 | ASV67 | ASV68 | ASV69 | ASV70 | ASV71 | ASV72 | ASV73 | ASV74 | ASV75 | ASV76 | ASV77 | ASV78 | ASV79 | ASV80 | ASV81 | ASV82 | ASV83 | ASV84 | ASV85 | ASV86 | ASV87 | ASV88 | ASV89 | ASV90 | ASV91 | ASV92 | ASV93 | ASV94 | ASV95 | ASV96 | ASV97 | ASV98 | ASV99 | ASV100 | ASV101 | ASV102 | ASV103 | ASV104 | ASV105 | ASV106 | ASV107 | ASV108 | ASV109 | ASV110 | ASV111 | ASV112 | ASV113 | ASV114 | ASV115 | ASV116 | ASV117 | ASV118 | ASV119 | ASV120 | ASV121 | ASV122 | ASV123 | ASV124 | ASV125 | ASV126 | ASV127 | ASV128 | ASV129 | ASV130 | ASV131 | ASV132 | ASV133 | ASV134 | ASV135 | ASV136 |
| :--------- | ---: | ---: | ---: | ----: | ---: | ---: | ---: | ---: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | ----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: | -----: |
| SRR6442697 |    0 |    3 |    1 |     4 |    0 |    0 |    5 |   17 |     3 |     0 |     0 |     0 |     1 |     1 |   917 |  1031 |     0 |     3 |     0 |    76 |     0 |     0 |     3 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |    15 |     0 |     0 |   534 |     0 |     4 |     0 |  2099 |     0 |     0 |     4 |     0 |     0 |     0 |     0 |     0 |     0 |   158 |     0 |   914 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |  1014 |     0 |     0 |   322 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |   535 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |      0 |      0 |      0 |      0 |    122 |      0 |      0 |      2 |      0 |     15 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      1 |      0 |      0 |      0 |     49 |      0 |      0 |      0 |      8 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |
| SRR6442698 |    0 |    9 |  537 |     2 |    0 |    0 |    4 |    0 |     8 |     4 |     0 |     0 |     2 |     1 |  2015 |   120 |     0 |     0 |     0 |    36 |     1 |     0 |     2 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |    67 |     0 |    35 |     2 |   306 |     0 |     1 |     0 |   246 |     0 |     0 |     1 |     0 |     0 |     5 |     0 |     0 |     0 |   251 |     0 |    23 |     0 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |    28 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     2 |     3 |     0 |     0 |   178 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     2 |     0 |     0 |     0 |     0 |     0 |    88 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     5 |      0 |      0 |      0 |      0 |    120 |      0 |      0 |      5 |      0 |      9 |      0 |      0 |      0 |      0 |      0 |      1 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      7 |      0 |      2 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |
| SRR6442699 |    0 |  581 |    0 |     0 |    1 |    0 |    2 |    3 |     6 |     0 |     8 |     0 |     1 |     0 |  2461 |     7 |     0 |     0 |     0 |  1400 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |   236 |     0 |     0 |     0 |   575 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |   168 |     0 |  1235 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     3 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |  1458 |     0 |     0 |  1208 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |      0 |      0 |      0 |      0 |     92 |      0 |      0 |     21 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      2 |      0 |      0 |      0 |      0 |      0 |      1 |      0 |      0 |      0 |      0 |      0 |      0 |
| SRR6442700 |    2 | 8300 | 3828 |     0 |    1 |    0 |  275 |    0 |     9 |  3557 |     8 |     0 |  3324 |     0 |   741 |  1045 |   413 |  6923 |     0 |   253 |    48 |     0 |     1 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |   170 |     0 |   331 |   352 |     0 |     0 |  2913 |     0 |     0 |     2 |   967 |   164 |     0 |     0 |   146 |   361 |     0 |     0 |     0 |     0 |     0 |     2 |    28 |     0 |    17 |     0 |     0 |     0 |  1055 |     1 |   114 |     0 |     0 |     0 |     0 |     0 |    16 |    25 |     0 |     2 |     0 |    79 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |    31 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     3 |     0 |     0 |     2 |     0 |    10 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |     15 |      1 |      1 |      4 |    197 |      0 |      0 |     39 |    160 |      0 |      0 |      0 |      0 |     28 |      0 |      0 |      0 |      0 |      0 |      0 |      1 |      0 |      0 |      0 |      1 |      0 |     36 |      0 |      0 |      0 |
| SRR6442701 |    0 |   80 |  526 |     2 |    1 |   88 |    0 |   25 |   249 |  2425 |   182 |     0 |     8 |     0 |   215 |     8 |  7742 |  2455 |     6 |   565 |     9 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     3 |    18 |     0 |     8 |    65 |     0 |     0 |     0 |    94 |    55 |     1 |     0 |     0 |     0 |     0 |     1 |     0 |     1 |     0 |     9 |     0 |     0 |     0 |     6 |  2550 |     0 |   690 |     1 |     3 |     0 |     0 |    77 |     0 |    85 |    40 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |   107 |     2 |      0 |      0 |      0 |      0 |      0 |     72 |      0 |      0 |      0 |      0 |     40 |    101 |      3 |      0 |    108 |      0 |      0 |      0 |      0 |      0 |    241 |      0 |      0 |      0 |      0 |      0 |      0 |     12 |      0 |      0 |      1 |      0 |      0 |      0 |      0 |      0 |      0 |
| SRR6442702 |    0 |    6 |   49 | 13341 |    3 |    0 | 3583 |    1 | 13608 |     5 |     0 |     0 |    15 |   460 |     3 |   272 | 19137 | 14544 |     0 |    18 |     2 |     0 |     1 |     1 |     3 |    90 |     0 |     1 |     0 |     0 |     0 |     1 |     0 |    15 |     0 |  1963 |     1 |     4 |     9 |     6 |     0 |    92 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     1 |     0 |     9 |     0 |    78 |     0 |     0 |     0 |   766 |     1 |     0 |     0 |     0 |     0 |     0 |     0 |   135 |     4 |     0 |     0 |     0 |     4 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |     0 |    66 |     0 |      0 |      0 |      0 |      0 |      0 |      1 |      0 |      0 |      0 |      0 |     12 |      0 |     31 |      0 |      6 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |      0 |

</div>

La tabla de cuentas relaciona el nombre de las taxa con las muestras y
con el número de reads mapeadas en contra de ellas. Acá el número de
reads es directamente proporcional al número de veces que se observa un
taxon.

  - El otro componente importante es la tabla de taxonomía.

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:320px; overflow-x: scroll; width:100%; ">

|      | Kingdom  | Phylum         | Class               | Order             | Family             | Genus            |
| :--- | :------- | :------------- | :------------------ | :---------------- | :----------------- | :--------------- |
| ASV1 | Bacteria | Proteobacteria | Gammaproteobacteria | Cardiobacteriales | Cardiobacteriaceae | NA               |
| ASV2 | Bacteria | Bacteroidetes  | Bacteroidia         | Flavobacteriales  | Flavobacteriaceae  | NA               |
| ASV3 | Bacteria | Proteobacteria | Gammaproteobacteria | Pseudomonadales   | Moraxellaceae      | NA               |
| ASV4 | Bacteria | Proteobacteria | Gammaproteobacteria | NA                | NA                 | NA               |
| ASV5 | Bacteria | Proteobacteria | Gammaproteobacteria | Xanthomonadales   | Xanthomonadaceae   | Stenotrophomonas |
| ASV6 | Bacteria | Proteobacteria | Gammaproteobacteria | Pseudomonadales   | Moraxellaceae      | Moraxella        |

</div>

La tabla de taxonomía relaciona el nombre de las taxa con el linaje
taxonómico de éstas, i.e., vincula una variante de secuencia, o ASV, con
los rangos taxonómicos desde Reino hasta Género o Especie dependiendo
del nivel de resolución del análisis.

  - Veamos ahora el otro componente esencial que es la metadata.

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:400px; overflow-x: scroll; width:100%; ">

|            | sample\_ID | bioproject\_accession | study     | biosample\_accession | experiment | run        | SRA\_Sample | geo\_loc\_name                                   | collection\_date | sample\_type | species                | common\_name         | AvgSpotLen |
| :--------- | :--------- | :-------------------- | :-------- | :------------------- | :--------- | :--------- | :---------- | :----------------------------------------------- | ---------------: | :----------- | :--------------------- | :------------------- | ---------: |
| SRR6442697 | EMA4       | PRJNA428495           | SRP128093 | SAMN08292292         | SRX3533985 | SRR6442697 | SRS2809259  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442698 | EMA3       | PRJNA428495           | SRP128093 | SAMN08292291         | SRX3533984 | SRR6442698 | SRS2809258  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442699 | EMA2       | PRJNA428495           | SRP128093 | SAMN08292284         | SRX3533983 | SRR6442699 | SRS2809257  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442700 | EMA19      | PRJNA428495           | SRP128093 | SAMN08292283         | SRX3533982 | SRR6442700 | SRS2809256  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442701 | EMA21      | PRJNA428495           | SRP128093 | SAMN08292286         | SRX3533981 | SRR6442701 | SRS2809255  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442702 | EMA20      | PRJNA428495           | SRP128093 | SAMN08292285         | SRX3533980 | SRR6442702 | SRS2809254  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442703 | EMA23      | PRJNA428495           | SRP128093 | SAMN08292288         | SRX3533979 | SRR6442703 | SRS2809252  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442704 | EMA22      | PRJNA428495           | SRP128093 | SAMN08292287         | SRX3533978 | SRR6442704 | SRS2809253  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442705 | EMA25      | PRJNA428495           | SRP128093 | SAMN08292290         | SRX3533977 | SRR6442705 | SRS2809251  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442706 | EMA24      | PRJNA428495           | SRP128093 | SAMN08292289         | SRX3533976 | SRR6442706 | SRS2809250  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442708 | EMA18      | PRJNA428495           | SRP128093 | SAMN08292282         | SRX3533974 | SRR6442708 | SRS2809249  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442709 | EMA11      | PRJNA428495           | SRP128093 | SAMN08292275         | SRX3533973 | SRR6442709 | SRS2809248  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442710 | EMA12      | PRJNA428495           | SRP128093 | SAMN08292276         | SRX3533972 | SRR6442710 | SRS2809246  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442711 | EMA1       | PRJNA428495           | SRP128093 | SAMN08292273         | SRX3533971 | SRR6442711 | SRS2809245  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442712 | EMA10      | PRJNA428495           | SRP128093 | SAMN08292274         | SRX3533970 | SRR6442712 | SRS2809244  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442713 | EMA15      | PRJNA428495           | SRP128093 | SAMN08292279         | SRX3533969 | SRR6442713 | SRS2809243  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442714 | EMA16      | PRJNA428495           | SRP128093 | SAMN08292280         | SRX3533968 | SRR6442714 | SRS2809242  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442715 | EMA13      | PRJNA428495           | SRP128093 | SAMN08292277         | SRX3533967 | SRR6442715 | SRS2809241  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442716 | EMA14      | PRJNA428495           | SRP128093 | SAMN08292278         | SRX3533966 | SRR6442716 | SRS2809240  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442717 | F1         | PRJNA428495           | SRP128093 | SAMN08292272         | SRX3533965 | SRR6442717 | SRS2809239  | Chile: Chiloe                                    |             2015 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442718 | CHIO5      | PRJNA428495           | SRP128093 | SAMN08292271         | SRX3533964 | SRR6442718 | SRS2809237  | Chile: Chiloe                                    |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442719 | CHiO7      | PRJNA428495           | SRP128093 | SAMN08292270         | SRX3533963 | SRR6442719 | SRS2809238  | Chile: Chiloe                                    |             2017 | skin         | Eubalaena australis    | southern right whale |        500 |
| SRR6442720 | CHiO6      | PRJNA428495           | SRP128093 | SAMN08292269         | SRX3533962 | SRR6442720 | SRS2809236  | Chile: Chiloe                                    |             2017 | skin         | Eubalaena australis    | southern right whale |        501 |
| SRR6442721 | CHiO4      | PRJNA428495           | SRP128093 | SAMN08292268         | SRX3533961 | SRR6442721 | SRS2809235  | Chile: Chiloe                                    |             2017 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442722 | CHiO3      | PRJNA428495           | SRP128093 | SAMN08292267         | SRX3533960 | SRR6442722 | SRS2809234  | Chile: Chiloe                                    |             2017 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442723 | CHiO2      | PRJNA428495           | SRP128093 | SAMN08292266         | SRX3533959 | SRR6442723 | SRS2809232  | Chile: Chiloe                                    |             2017 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442725 | F9         | PRJNA428495           | SRP128093 | SAMN08292264         | SRX3533957 | SRR6442725 | SRS2809231  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442726 | F8         | PRJNA428495           | SRP128093 | SAMN08292263         | SRX3533956 | SRR6442726 | SRS2809230  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442727 | F10        | PRJNA428495           | SRP128093 | SAMN08292242         | SRX3533955 | SRR6442727 | SRS2809229  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442731 | RNPH16     | PRJNA428495           | SRP128093 | SAMN08292238         | SRX3533951 | SRR6442731 | SRS2809225  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442732 | RNPH15     | PRJNA428495           | SRP128093 | SAMN08292237         | SRX3533950 | SRR6442732 | SRS2809224  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442733 | RNPH14     | PRJNA428495           | SRP128093 | SAMN08292236         | SRX3533949 | SRR6442733 | SRS2809223  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442734 | RNPH13     | PRJNA428495           | SRP128093 | SAMN08292235         | SRX3533948 | SRR6442734 | SRS2809222  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442735 | RNPH12     | PRJNA428495           | SRP128093 | SAMN08292234         | SRX3533947 | SRR6442735 | SRS2809221  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442736 | RNPH11     | PRJNA428495           | SRP128093 | SAMN08292233         | SRX3533946 | SRR6442736 | SRS2809220  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Balaenoptera physalus  | fin whale            |        501 |
| SRR6442737 | F6         | PRJNA428495           | SRP128093 | SAMN08292261         | SRX3533945 | SRR6442737 | SRS2809218  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442738 | F7         | PRJNA428495           | SRP128093 | SAMN08292262         | SRX3533944 | SRR6442738 | SRS2809219  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442739 | F39        | PRJNA428495           | SRP128093 | SAMN08292253         | SRX3533943 | SRR6442739 | SRS2809217  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442740 | F4         | PRJNA428495           | SRP128093 | SAMN08292254         | SRX3533942 | SRR6442740 | SRS2809216  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442741 | F40        | PRJNA428495           | SRP128093 | SAMN08292255         | SRX3533941 | SRR6442741 | SRS2809215  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442742 | F41        | PRJNA428495           | SRP128093 | SAMN08292256         | SRX3533940 | SRR6442742 | SRS2809214  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442743 | F42        | PRJNA428495           | SRP128093 | SAMN08292257         | SRX3533939 | SRR6442743 | SRS2809213  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442744 | F43        | PRJNA428495           | SRP128093 | SAMN08292258         | SRX3533938 | SRR6442744 | SRS2809212  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442745 | F44        | PRJNA428495           | SRP128093 | SAMN08292259         | SRX3533937 | SRR6442745 | SRS2809211  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442746 | F5         | PRJNA428495           | SRP128093 | SAMN08292260         | SRX3533936 | SRR6442746 | SRS2809210  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442747 | RNPH7      | PRJNA428495           | SRP128093 | SAMN08292328         | SRX3533935 | SRR6442747 | SRS2809209  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442748 | RNPH6      | PRJNA428495           | SRP128093 | SAMN08292327         | SRX3533934 | SRR6442748 | SRS2809208  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442749 | RNPH9      | PRJNA428495           | SRP128093 | SAMN08292330         | SRX3533933 | SRR6442749 | SRS2809207  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442750 | RNPH8      | PRJNA428495           | SRP128093 | SAMN08292329         | SRX3533932 | SRR6442750 | SRS2809206  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442751 | RNPH3      | PRJNA428495           | SRP128093 | SAMN08292324         | SRX3533931 | SRR6442751 | SRS2809205  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442752 | RNPH20     | PRJNA428495           | SRP128093 | SAMN08292323         | SRX3533930 | SRR6442752 | SRS2809204  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442753 | RNPH5      | PRJNA428495           | SRP128093 | SAMN08292326         | SRX3533929 | SRR6442753 | SRS2809203  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442754 | RNPH4      | PRJNA428495           | SRP128093 | SAMN08292325         | SRX3533928 | SRR6442754 | SRS2809202  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442755 | F16        | PRJNA428495           | SRP128093 | SAMN08292248         | SRX3533927 | SRR6442755 | SRS2809201  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442756 | F15        | PRJNA428495           | SRP128093 | SAMN08292247         | SRX3533926 | SRR6442756 | SRS2809199  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442757 | F18        | PRJNA428495           | SRP128093 | SAMN08292250         | SRX3533925 | SRR6442757 | SRS2809200  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442758 | F17        | PRJNA428495           | SRP128093 | SAMN08292249         | SRX3533924 | SRR6442758 | SRS2809198  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442759 | F12        | PRJNA428495           | SRP128093 | SAMN08292244         | SRX3533923 | SRR6442759 | SRS2809197  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442760 | F11        | PRJNA428495           | SRP128093 | SAMN08292243         | SRX3533922 | SRR6442760 | SRS2809196  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442761 | F14        | PRJNA428495           | SRP128093 | SAMN08292246         | SRX3533921 | SRR6442761 | SRS2809195  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442762 | F13        | PRJNA428495           | SRP128093 | SAMN08292245         | SRX3533920 | SRR6442762 | SRS2809193  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale           |        501 |
| SRR6442763 | F3         | PRJNA428495           | SRP128093 | SAMN08292252         | SRX3533919 | SRR6442763 | SRS2809194  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442764 | F2         | PRJNA428495           | SRP128093 | SAMN08292251         | SRX3533918 | SRR6442764 | SRS2809192  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale           |        500 |
| SRR6442765 | RNPH10     | PRJNA428495           | SRP128093 | SAMN08292321         | SRX3533917 | SRR6442765 | SRS2809191  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442766 | RNPH2      | PRJNA428495           | SRP128093 | SAMN08292322         | SRX3533916 | SRR6442766 | SRS2809190  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442767 | F50        | PRJNA428495           | SRP128093 | SAMN08292319         | SRX3533915 | SRR6442767 | SRS2809189  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442768 | RNPH1      | PRJNA428495           | SRP128093 | SAMN08292320         | SRX3533914 | SRR6442768 | SRS2809188  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442769 | F48        | PRJNA428495           | SRP128093 | SAMN08292317         | SRX3533913 | SRR6442769 | SRS2809187  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442770 | F49        | PRJNA428495           | SRP128093 | SAMN08292318         | SRX3533912 | SRR6442770 | SRS2809186  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442771 | F46        | PRJNA428495           | SRP128093 | SAMN08292315         | SRX3533911 | SRR6442771 | SRS2809185  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442774 | F45        | PRJNA428495           | SRP128093 | SAMN08292314         | SRX3533908 | SRR6442774 | SRS2809181  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442775 | F27        | PRJNA428495           | SRP128093 | SAMN08292306         | SRX3533907 | SRR6442775 | SRS2809180  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442776 | F26        | PRJNA428495           | SRP128093 | SAMN08292305         | SRX3533906 | SRR6442776 | SRS2809179  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442779 | F31        | PRJNA428495           | SRP128093 | SAMN08292310         | SRX3533903 | SRR6442779 | SRS2809176  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        499 |
| SRR6442780 | F30        | PRJNA428495           | SRP128093 | SAMN08292309         | SRX3533902 | SRR6442780 | SRS2809175  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442781 | F29        | PRJNA428495           | SRP128093 | SAMN08292308         | SRX3533901 | SRR6442781 | SRS2809174  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442782 | F28        | PRJNA428495           | SRP128093 | SAMN08292307         | SRX3533900 | SRR6442782 | SRS2809183  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442783 | F33        | PRJNA428495           | SRP128093 | SAMN08292312         | SRX3533899 | SRR6442783 | SRS2809173  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442784 | F32        | PRJNA428495           | SRP128093 | SAMN08292311         | SRX3533898 | SRR6442784 | SRS2809172  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442785 | F22        | PRJNA428495           | SRP128093 | SAMN08292301         | SRX3533897 | SRR6442785 | SRS2809171  | Chile: Estrecho\_Magallanes                      |             2010 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442786 | F23        | PRJNA428495           | SRP128093 | SAMN08292302         | SRX3533896 | SRR6442786 | SRS2809170  | Chile: Estrecho\_Magallanes                      |             2010 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442787 | EMA9       | PRJNA428495           | SRP128093 | SAMN08292297         | SRX3533895 | SRR6442787 | SRS2809169  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442788 | F19        | PRJNA428495           | SRP128093 | SAMN08292298         | SRX3533894 | SRR6442788 | SRS2809168  | Chile: Estrecho\_Magallanes                      |             2010 | skin         | Megaptera novaeangliae | humpback whale       |        501 |
| SRR6442789 | F20        | PRJNA428495           | SRP128093 | SAMN08292299         | SRX3533893 | SRR6442789 | SRS2809167  | Chile: Estrecho\_Magallanes                      |             2010 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442790 | F21        | PRJNA428495           | SRP128093 | SAMN08292300         | SRX3533892 | SRR6442790 | SRS2809166  | Chile: Estrecho\_Magallanes                      |             2010 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442792 | EMA6       | PRJNA428495           | SRP128093 | SAMN08292294         | SRX3533890 | SRR6442792 | SRS2809164  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |
| SRR6442794 | EMA8       | PRJNA428495           | SRP128093 | SAMN08292296         | SRX3533888 | SRR6442794 | SRS2809162  | Chile: Estrecho\_Magallanes                      |             2017 | skin         | Megaptera novaeangliae | humpback whale       |        500 |

</div>

Finalmente, tenemos el árbol filogenético, que es opcional en
`phyloseq`, que nos muestra las relaciones evolutivas entre las taxa de
todas las muestras. Es opcional porque normalmente cuando hacemos
*shotgun metagenomics* no contamos con un marcador universal y por lo
tanto no hay filogenia.

  - Podemos graficar simplemente la filogenia con la función
    `plot_tree`.

<div class="sourceCode">

``` sourceCode r
# Esta es la filogenia asociada a las taxa en nuestro objeto phyloseq
plot_tree(psd5, method = "treeonly", ladderize = "left")
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-14-1.png)

Ahora, el objeto `phyloseq` se ha vuelto una suerte de estándar en la
industria ya que otros paquetes ahora usan esta estructura de datos para
sus propias funciones. Uno de esos paquetes es `microbiome` y `ampvis`.
Podemos fácilmente obtener un resumen global de nuestro objeto
`phyloseq` usando la función `summarize_phyloseq`.

  - Primero cargamos el paquete con `library(microbiome)`.

<div class="sourceCode">

``` sourceCode r
summarize_phyloseq(psd5)
```

</div>

    ## Compositional = NO
    ## 1] Min. number of reads = 1123 
    ## 2] Max. number of reads = 103541 
    ## 3] Total number of reads = 2606004 
    ## 4] Average number of reads = 29954.0689655172 
    ## 5] Median number of reads = 23576 
    ## 7] Sparsity = 0.679428668018932 
    ## 6] Any OTU sum to 1 or less? NO 
    ## 8] Number of singletons = 0 
    ## 9] Percent of OTUs that are singletons 0 
    ## 10] Number of sample variables are: 13 
    ## sample_ID 
    ## bioproject_accession 
    ## study 
    ## biosample_accession 
    ## experiment 
    ## run 
    ## SRA_Sample 
    ## geo_loc_name 
    ## collection_date 
    ## sample_type 
    ## species 
    ## common_name 
    ## AvgSpotLen

Este comando nos muestra el mínimo y máximo de reads, número total y
promedio de reads, etc. También muestra los encabezados de las columans
en la tabla de metadata.

  - Veamos ahora una tabla que mezcle metadata, taxonomíaa y abundancia
    del taxon más abundante de cada muestra.

<!-- end list -->

    df <- psmelt(psd5)

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:400px; overflow-x: scroll; width:100%; ">

|      | OTU   | Sample     | Abundance | sample\_ID | bioproject\_accession | study     | biosample\_accession | experiment | run        | SRA\_Sample | geo\_loc\_name                                   | collection\_date | sample\_type | species                | common\_name   | AvgSpotLen | Kingdom  | Phylum         | Class               | Order             | Family             | Genus         |
| :--- | :---- | :--------- | --------: | :--------- | :-------------------- | :-------- | :------------------- | :--------- | :--------- | :---------- | :----------------------------------------------- | ---------------: | :----------- | :--------------------- | :------------- | ---------: | :------- | :------------- | :------------------ | :---------------- | :----------------- | :------------ |
| 5    | ASV1  | SRR6442744 |     65451 | F43        | PRJNA428495           | SRP128093 | SAMN08292258         | SRX3533938 | SRR6442744 | SRS2809212  | Chile: Chiloe                                    |             2016 | skin         | Balaenoptera musculus  | blue whale     |        501 | Bacteria | Proteobacteria | Gammaproteobacteria | Cardiobacteriales | Cardiobacteriaceae | NA            |
| 8009 | ASV6  | SRR6442747 |     57107 | RNPH7      | PRJNA428495           | SRP128093 | SAMN08292328         | SRX3533935 | SRR6442747 | SRS2809209  | Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt |             2017 | skin         | Megaptera novaeangliae | humpback whale |        499 | Bacteria | Proteobacteria | Gammaproteobacteria | Pseudomonadales   | Moraxellaceae      | Moraxella     |
| 39   | ASV1  | SRR6442738 |     46464 | F7         | PRJNA428495           | SRP128093 | SAMN08292262         | SRX3533944 | SRR6442738 | SRS2809219  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale     |        501 | Bacteria | Proteobacteria | Gammaproteobacteria | Cardiobacteriales | Cardiobacteriaceae | NA            |
| 3702 | ASV14 | SRR6442771 |     44378 | F46        | PRJNA428495           | SRP128093 | SAMN08292315         | SRX3533911 | SRR6442771 | SRS2809185  | Chile: Estrecho\_Magallanes                      |             2016 | skin         | Megaptera novaeangliae | humpback whale |        501 | Bacteria | Bacteroidetes  | Bacteroidia         | Flavobacteriales  | Flavobacteriaceae  | Tenacibaculum |
| 6139 | ASV4  | SRR6442763 |     42681 | F3         | PRJNA428495           | SRP128093 | SAMN08292252         | SRX3533919 | SRR6442763 | SRS2809194  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale     |        500 | Bacteria | Proteobacteria | Gammaproteobacteria | NA                | NA                 | NA            |
| 4144 | ASV19 | SRR6442763 |     37149 | F3         | PRJNA428495           | SRP128093 | SAMN08292252         | SRX3533919 | SRR6442763 | SRS2809194  | Chile: Chiloe                                    |             2015 | skin         | Balaenoptera musculus  | blue whale     |        500 | Bacteria | Proteobacteria | Gammaproteobacteria | Cardiobacteriales | Cardiobacteriaceae | NA            |

</div>

  - También es importante tener una visión de cómo se distribuyen las
    muestras de acuerdo a la metadata. En este ejemplo, graficamos la
    frecuencia de muestras de acuerdo a la ubicación geográfica
    (geo\_loc\_name) y a la especie de ballena de donde la muestra fue
    obtenida (species).

<!-- end list -->

    res <- plot_frequencies(sample_data(psd5), "geo_loc_name", "species")
    print(res$plot)

![](biodiversity_files/figure-html/unnamed-chunk-17-1.png)

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:300px; overflow-x: scroll; width:100%; ">

| Groups                                           | Factor                 |  n |    pct |
| :----------------------------------------------- | :--------------------- | -: | -----: |
| Chile: Chiloe                                    | Balaenoptera musculus  | 26 |  86.67 |
| Chile: Chiloe                                    | Eubalaena australis    |  2 |   6.67 |
| Chile: Chiloe                                    | Megaptera novaeangliae |  2 |   6.67 |
| Chile: Estrecho\_Magallanes                      | Megaptera novaeangliae | 40 | 100.00 |
| Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt | Balaenoptera physalus  |  6 |  35.29 |
| Chile: Reserva\_Nacional\_Pinguino\_de\_Humboldt | Megaptera novaeangliae | 11 |  64.71 |

</div>

Ahora veamos cómo podemos filtrar y hacer *subsetting* de un objeto
phyloseq. Esto lo hacemos con tres grupos de funciones, i.e., `filter`,
`subset`, y `prune`. Filtrar se refiere a filtrar según alguna regla
lógica. Ya lo hicimos en la parte de control de calidad cuando llamamos
la función `filter_taxa(psd1, function(x) mean(x) > 1e-5, TRUE)`. Acá le
pedíamos a la función `filter_taxa` que sobre el objeto `psd5`,
calculara la media de *read counts* para cada taxa y si este resultado
era menor que 1e-5, lo eliminara. Veamos un ejemplo diferente y
filtremos según abundancia.

  - Primero transformamos en abundancia relativa y luego filtramos.

<div class="sourceCode">

``` sourceCode r
# Transformamos las cuentas en porcentaje
psd5r  = transform_sample_counts(psd5, function(x) x / sum(x) )

# Filtramos las taxa con una abundancia inferior al 1%
(psd5r.filtrado = filter_taxa(psd5r, function(x) sum(x) > 1, TRUE))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 24 taxa and 87 samples ]
    ## sample_data() Sample Data:       [ 87 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 24 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 24 tips and 23 internal nodes ]

¿Cuántas taxa permanecen en nuestro objeto phyloseq? Con una operación
tan simple como la que acabamos de aplicar, nos damos cuenta que la
mayoría de las taxa presentes en nuestras muestras están en muy baja
abundancia.

  - Ahora imaginemos la situación donde queremos filtrar nuestro objeto
    pero en función de un taxon en específico.

|       | Genus                |
| :---- | :------------------- |
| ASV1  | NA                   |
| ASV2  | NA                   |
| ASV3  | NA                   |
| ASV4  | NA                   |
| ASV5  | Stenotrophomonas     |
| ASV6  | Moraxella            |
| ASV7  | Tenacibaculum        |
| ASV8  | Klebsiella           |
| ASV9  | Tenacibaculum        |
| ASV10 | NA                   |
| ASV11 | NA                   |
| ASV12 | Pseudomonas          |
| ASV13 | NA                   |
| ASV15 | NA                   |
| ASV16 | Moraxella            |
| ASV17 | Moraxella            |
| ASV18 | NA                   |
| ASV19 | NA                   |
| ASV20 | NA                   |
| ASV22 | Pseudomonas          |
| ASV23 | Tenacibaculum        |
| ASV24 | Achromobacter        |
| ASV25 | Catenococcus         |
| ASV28 | Escherichia/Shigella |

<div class="sourceCode">

``` sourceCode r
# Ahora filtramos de acuerdo a _Moraxella_
(subset_taxa(psd5r.filtrado, Genus=="Moraxella") -> psd5r.filtrado.moraxella)
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 3 taxa and 87 samples ]
    ## sample_data() Sample Data:       [ 87 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 3 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 3 tips and 2 internal nodes ]

<div class="sourceCode">

``` sourceCode r
# También podríamos todo lo que NO es _Moraxella_
(subset_taxa(psd5r.filtrado, Genus!="Moraxella") -> psd5r.filtrado.NoMoraxella)
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 10 taxa and 87 samples ]
    ## sample_data() Sample Data:       [ 87 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 10 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 10 tips and 9 internal nodes ]

  - Otra manera de filtrar un objeto `phyloseq` es en base a algún
    atributo presente en `sample_data`. Por ejemplo, con estos datos uno
    podría querer estudiar el microbioma de las ballenas por separado.
    Para esto crearíamos tres objetos `phyloseq` a partir de `psd5`.

<div class="sourceCode">

``` sourceCode r
(psd5.blue = subset_samples(psd5, species == "Balaenoptera musculus"))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 136 taxa and 26 samples ]
    ## sample_data() Sample Data:       [ 26 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 136 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 136 tips and 135 internal nodes ]

<div class="sourceCode">

``` sourceCode r
(psd5.fin = subset_samples(psd5, species == "Balaenoptera physalus"))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 136 taxa and 6 samples ]
    ## sample_data() Sample Data:       [ 6 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 136 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 136 tips and 135 internal nodes ]

<div class="sourceCode">

``` sourceCode r
(psd5.joro = subset_samples(psd5, species == "Megaptera novaeangliae"))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 136 taxa and 53 samples ]
    ## sample_data() Sample Data:       [ 53 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 136 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 136 tips and 135 internal nodes ]

  - Alternativamente, podríamos decicir estudiar solo tres de las cuatro
    especies de ballenas que tenemos representadas en `psd5`.

<div class="sourceCode">

``` sourceCode r
psd5 = subset_samples(subset_samples(psd5, species != "Eubalaena australis"))
```

</div>

  - El comando `prune_samples()` también es muy usado ya que nos permite
    usar un vector con las muestras que queremos mantener (similar a
    `subset_samples`) o un vector lógico donde las muestras que queremos
    mantener son verdaderas.

<div class="sourceCode">

``` sourceCode r
# Primero seleccionamos solo el género _Moraxella_
subset_taxa(psd5, Genus=="Moraxella") -> psd5.moraxella

# Luego nos quedamos con las muestras que solo cumplen con la condición, i,e, que poseen una abundancia de _Moraxella_ de más de 5 reads
prune_samples(sample_sums(psd5.moraxella)>=5, psd5.moraxella) -> psd5.moraxella

# Y finalmente visualizamos los resultados mapeados en el árbol filogenético
plot_tree(psd5.moraxella, color="species", shape="Family", label.tips="Genus", size="abundance")
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-23-1.png)

Inmediatamente podemos apreciar que la distribución de *Moraxella* es
mayor en ballena jorobada que en las otras dos especies, azul y fin.

  - Otra situación muy común ocurre cuando queremos remover
    contaminantes u otras taxa no deseadas. Esto se puede hacer
    fácilmente con el comando `prune_taxa`.

<div class="sourceCode">

``` sourceCode r
# Primero definimos las taxa que no queremos
badTaxa = c("ASV134", "ASV104", "ASV68")

# Creamos una lista con todos los nombres de los taxa presentes en el objeto `psd5`
allTaxa = taxa_names(psd5)

# Nos quedamos con la diferencia entre badTaxa y allTaxa
keepTaxa <- allTaxa[!(allTaxa %in% badTaxa)]

#Ejecutamos `prune_taxa` sobre psd5
(psd5.prune = prune_taxa(keepTaxa, psd5))
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 133 taxa and 85 samples ]
    ## sample_data() Sample Data:       [ 85 samples by 13 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 133 taxa by 6 taxonomic ranks ]
    ## phy_tree()    Phylogenetic Tree: [ 133 tips and 132 internal nodes ]

Para finalizar esta sección, un par de funciones muy útiles en
`phyloseq` son `tax_glom()` y `tip_glom()`. Ambas funciones tratan de
agrupar o aglomerar un objeto de acuerdo a alguna propiedad, de esta
manera simplificándolo. Por ejemplo, es muy probable que uno tenga
varias ASVs del mismo género ya que si bien a nivel de secuencia son
diferentes, estas corresponden al mismo género. En cierta forma ya lo
vimos cuando seleccionamos el género *Moraxella*. El objeto resultante
tenía ocho taxa, todas ellas *Moraxella*.

  - Para hacer visualizaciones y otros análisis puede ser conveniente
    colapsar o aglomerar estas secuencias del mismo género u otro rango
    taxonómico. Al mismo tiempo, `tip_glom` realiza una función similar
    pero basándose en una “altura” arbitraria en el árbol filogenético.

<div class="sourceCode">

``` sourceCode r
# Primero aglomeramos por género
psd5.genus = tax_glom(psd5, "Genus", NArm = FALSE)
# Luego por altura en el árbol filogenético
h1 = 0.4
psd5.tip = tip_glom(psd5, h = h1)
# Grafiquemos una comparación para visualizar las diferencias
multiPlotTitleTextSize = 15
p2tree = plot_tree(psd5, method = "treeonly",
                   ladderize = "left",
                   title = "Sin aglomeración") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree = plot_tree(psd5.genus, method = "treeonly",
                   ladderize = "left", title = "A nivel de género") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree = plot_tree(psd5.tip, method = "treeonly",
                   ladderize = "left", title = "Por altura") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))

# Graficamos los árboles juntos
grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-25-1.png)

</div>

</div>

<div id="introduccion-al-analisis-de-diversidad" class="section level1">

# <span class="header-section-number">3</span> Introducción al análisis de diversidad

¿Qué entendemos por diversidad? Al menos podemos conceptualizar
diversidad a dos niveles: diversidad genética o morfológica, y
biodiversidad. En el estudio de comunidades, tomamos prestado el
concepto de biodiversidad de ecología de comunidades donde estamos
interesados en la riqueza de especies (número de especies diferentes en
una comunidad o diversidad alfa), en las diferencias y similitudes entre
comunidades (diversidad beta), y en algunos casos en la diversidad total
de un región o paisaje ecológico (*landscape*; diversidad gama).

<div class="figure">

![](images/diversidad.png)

</div>

En la figura observamos la diversidad de aves en dos regiones, X e Y, y
cuatro sitios, 1-4 (figura tomada de [Community Ecology de
Mittelbach](https://global.oup.com/academic/product/community-ecology-9780878935093?cc=cl&lang=en&)).
La diversidad alfa es mayor en los sitios 1 y 3 con 5 especies cada uno.
La diversidad beta mide la cantidad de cambio o *turnover* de especies
entre sitios. En la figura, la región Y tiene una diversidad beta mayor
que la región X porque el cambio o *turnover* de especies entre el sitio
2 y el 4 es mayor que entre el sitio 1 y el 3 (que tienen las mismas 5
especies). La diversidad gama mide la diversidad total dentro de una
región, por lo tanto en nuestro ejemplo la diversidad gama es mayor en
la región Y porque contiene 6 especies en total versus la región X que
tiene 5 especies.

<div id="medidas-de-riqueza-uniformidad-dominancia-diversidad-filogenetica-diversidad-alfa" class="section level2">

## <span class="header-section-number">3.1</span> Medidas de riqueza, uniformidad, dominancia, diversidad filogenética (diversidad alfa)

En el contexto metagenómico, medimos diversidad alfa usando una serie de
medidas prestadas de ecología que nos permiten caracterizar una
comunidad microbiana. `phyloseq` tiene una función muy útil que nos
permite calcular y graficar hasta siete medidas, i .e., Observed
(simplemente el número de taxa o riqueza), Chao1 (la riqueza ajustada
por probabilidad de no observar especies), ACE (riqueza que toma en
cuenta la abundancia relativa), Shannon (abundancia relativa de taxa),
Simpson (1 - la probabilidad de que observemos aleatoriamente dos
bacterias en una comunidad y que pertenezcan a diferentes especies ),
Inverse Simpson ( 1 / Simpson), y Fisher (riqueza tomando en cuenta
abundancia).

  - En `phyloseq` simplemente llamamos la función `plot_richness` y
    podemos visualizar las medidas de diversidad.

<div class="sourceCode">

``` sourceCode r
plot_richness(psd5, color = "species", x = "species", measures = c("Observed", "Chao1", "Shannon")) + geom_boxplot(aes(fill = species), alpha=.7) + scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-26-1.png)

En el ejemplo, solo graficamos Observed, Chao1 y Shannon usando el
argumento `measures = c("Observed", "Chao1", "Shannon")`. Si quisieramos
obtener todas las medidas simplemente eliminamos este argumento y por
defecto `phyloseq` graficará todo.

¿Hay un efecto significativo de la diversidad alfa según especie de
ballena? Eso lo podríamos probar rápidamente con un análisis de varianza
(ANOVA). Para este ejemplo utilicemos otra medida de diversidad, una que
`phyloseq` no incorpora. **Faith’s Phylogenetic Diversity** es un índice
introducido por [Daniel Faith
en 1992](http://moritzlab.anu.edu.au/DiversityWorkshop_Nov2016/Readings/Faith%201992%20Phylogenetic%20Diversity.pdf)
que no solo considera número de especies sino que también considera qué
tanto se parecen estas especies filogenéticamente. Esto es muy relevante
porque nos entrega una medida rápida para evaluar prioridades de
conservación de ecosistemas, o si se trata de comunidades microbianas,
donde tenemos mayor probabilidad de encontrar funciones génicas
novedosas.

<div class="sourceCode">

``` sourceCode r
# Guardamos un dataframe con las medidas de diversidad alfa
alpha_pd <- estimate_pd(psd5)
# Combinamos la metadata con alpha.diversity
data <- cbind(sample_data(psd5), alpha_pd) 
# Y calculamos un ANOVA
psd5.anova <- aov(PD ~ species, data) 
# install.packages("xtable")
library(xtable)
psd5.anova.table <- xtable(psd5.anova)
```

</div>

|           | Df |    Sum Sq |  Mean Sq | F value | Pr(\>F) |
| :-------- | -: | --------: | -------: | ------: | ------: |
| species   |  2 |  40.46002 | 20.23001 | 5.21047 | 0.00741 |
| Residuals | 82 | 318.37078 |  3.88257 |      NA |      NA |

  - El paquete `microbiome` ofrece otras herramientas para evaluar
    diversidad que son accesibles fácilmente a través de su función
    `global`.

<div class="sourceCode">

``` sourceCode r
tab <- global(psd5, index = "all")
head(tab)
```

</div>

    ##            richness_0 richness_20 richness_50 richness_80 observed
    ## SRR6442697         31          31          31          16       31
    ## SRR6442698         38          38          38          17       38
    ## SRR6442699         25          25          25          12       25
    ## SRR6442700         53          53          53          36       53
    ## SRR6442701         48          48          48          32       48
    ## SRR6442702         42          42          42          22       42
    ##            diversities_inverse_simpson diversities_gini_simpson
    ## SRR6442697                    6.948971                0.8560938
    ## SRR6442698                    3.673899                0.7278096
    ## SRR6442699                    6.461545                0.8452383
    ## SRR6442700                    7.707637                0.8702586
    ## SRR6442701                    4.520999                0.7788099
    ## SRR6442702                    4.873575                0.7948118
    ##            diversities_shannon diversities_fisher diversities_coverage
    ## SRR6442697            2.181249           4.100949                    3
    ## SRR6442698            1.913672           5.781418                    2
    ## SRR6442699            2.043740           3.117388                    3
    ## SRR6442700            2.412447           6.104153                    3
    ## SRR6442701            2.038536           5.949163                    2
    ## SRR6442702            1.759212           4.346443                    3
    ##            evenness_camargo evenness_pielou evenness_simpson evenness_evar
    ## SRR6442697       0.04991266       0.6351942       0.05109538    0.09528851
    ## SRR6442698       0.04179604       0.5260830       0.02701396    0.13983565
    ## SRR6442699       0.04419760       0.6349235       0.04751136    0.07442449
    ## SRR6442700       0.06210963       0.6076245       0.05667380    0.08087544
    ## SRR6442701       0.04676204       0.5265900       0.03324264    0.10368220
    ## SRR6442702       0.03423354       0.4706709       0.03583511    0.07058635
    ##            evenness_bulla dominance_dbp dominance_dmn dominance_absolute
    ## SRR6442697     0.09213899     0.2669465     0.3980669               2099
    ## SRR6442698     0.11343557     0.4878935     0.6179177               2015
    ## SRR6442699     0.07294103     0.2597910     0.4137021               2461
    ## SRR6442700     0.14903074     0.2305235     0.4228024               8300
    ## SRR6442701     0.13473186     0.4078386     0.5421693               7742
    ## SRR6442702     0.06516802     0.2799936     0.4927869              19137
    ##            dominance_relative dominance_simpson dominance_core_abundance
    ## SRR6442697          0.2669465         0.1439062                0.2618593
    ## SRR6442698          0.4878935         0.2721904                0.6714286
    ## SRR6442699          0.2597910         0.1547617                0.4718674
    ## SRR6442700          0.2305235         0.1297414                0.6071379
    ## SRR6442701          0.4078386         0.2211901                0.2298899
    ## SRR6442702          0.2799936         0.2051882                0.4588576
    ##            dominance_gini rarity_log_modulo_skewness rarity_low_abundance
    ## SRR6442697      0.9500873                   2.059940          0.009538344
    ## SRR6442698      0.9582040                   2.060444          0.015012107
    ## SRR6442699      0.9558024                   2.038428          0.004011401
    ## SRR6442700      0.9378904                   2.051077          0.009359811
    ## SRR6442701      0.9532380                   2.054745          0.006900911
    ## SRR6442702      0.9657665                   2.053781          0.009861298
    ##            rarity_noncore_abundance rarity_rare_abundance
    ## SRR6442697              0.131756327           0.131756327
    ## SRR6442698              0.095883777           0.095883777
    ## SRR6442699              0.137337697           0.137337697
    ## SRR6442700              0.012887099           0.012887099
    ## SRR6442701              0.031607228           0.031607228
    ## SRR6442702              0.003131035           0.003131035

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:300px; overflow-x: scroll; width:100%; ">

|            | richness\_0 | richness\_20 | richness\_50 | richness\_80 | observed | diversities\_inverse\_simpson | diversities\_gini\_simpson | diversities\_shannon | diversities\_fisher | diversities\_coverage | evenness\_camargo | evenness\_pielou | evenness\_simpson | evenness\_evar | evenness\_bulla | dominance\_dbp | dominance\_dmn | dominance\_absolute | dominance\_relative | dominance\_simpson | dominance\_core\_abundance | dominance\_gini | rarity\_log\_modulo\_skewness | rarity\_low\_abundance | rarity\_noncore\_abundance | rarity\_rare\_abundance |
| :--------- | ----------: | -----------: | -----------: | -----------: | -------: | ----------------------------: | -------------------------: | -------------------: | ------------------: | --------------------: | ----------------: | ---------------: | ----------------: | -------------: | --------------: | -------------: | -------------: | ------------------: | ------------------: | -----------------: | -------------------------: | --------------: | ----------------------------: | ---------------------: | -------------------------: | ----------------------: |
| SRR6442697 |          31 |           31 |           31 |           16 |       31 |                          6.95 |                       0.86 |                 2.18 |                4.10 |                     3 |              0.05 |             0.64 |              0.05 |           0.10 |            0.09 |           0.27 |           0.40 |                2099 |                0.27 |               0.14 |                       0.26 |            0.95 |                          2.06 |                   0.01 |                       0.13 |                    0.13 |
| SRR6442698 |          38 |           38 |           38 |           17 |       38 |                          3.67 |                       0.73 |                 1.91 |                5.78 |                     2 |              0.04 |             0.53 |              0.03 |           0.14 |            0.11 |           0.49 |           0.62 |                2015 |                0.49 |               0.27 |                       0.67 |            0.96 |                          2.06 |                   0.02 |                       0.10 |                    0.10 |
| SRR6442699 |          25 |           25 |           25 |           12 |       25 |                          6.46 |                       0.85 |                 2.04 |                3.12 |                     3 |              0.04 |             0.63 |              0.05 |           0.07 |            0.07 |           0.26 |           0.41 |                2461 |                0.26 |               0.15 |                       0.47 |            0.96 |                          2.04 |                   0.00 |                       0.14 |                    0.14 |
| SRR6442700 |          53 |           53 |           53 |           36 |       53 |                          7.71 |                       0.87 |                 2.41 |                6.10 |                     3 |              0.06 |             0.61 |              0.06 |           0.08 |            0.15 |           0.23 |           0.42 |                8300 |                0.23 |               0.13 |                       0.61 |            0.94 |                          2.05 |                   0.01 |                       0.01 |                    0.01 |
| SRR6442701 |          48 |           48 |           48 |           32 |       48 |                          4.52 |                       0.78 |                 2.04 |                5.95 |                     2 |              0.05 |             0.53 |              0.03 |           0.10 |            0.13 |           0.41 |           0.54 |                7742 |                0.41 |               0.22 |                       0.23 |            0.95 |                          2.05 |                   0.01 |                       0.03 |                    0.03 |
| SRR6442702 |          42 |           42 |           42 |           22 |       42 |                          4.87 |                       0.79 |                 1.76 |                4.35 |                     3 |              0.03 |             0.47 |              0.04 |           0.07 |            0.07 |           0.28 |           0.49 |               19137 |                0.28 |               0.21 |                       0.46 |            0.97 |                          2.05 |                   0.01 |                       0.00 |                    0.00 |

</div>

La función `global` nos da 26 medidas de diversidad que nos ayudan a
entender la estructura de las comunidades microbianas. En general, estas
medidas se dividen en riqueza, diversidad, dominancia, rareza, cobertura
y uniformidad.

  - El paquete `microbiome` ofrece funciones para calcular cada uno de
    estos aspectos de las comunidades microbianas.

<div class="sourceCode">

``` sourceCode r
# Riqueza
tab <- richness(psd5)
# Dominancia
tab <- dominance(psd5, index = "all")
# Rareza
tab <- rarity(psd5, index = "all")
# Cobertura
tab <- coverage(psd5, threshold = 0.5)
# Desigualdad
tab <- inequality(psd5)
# Uniformidad
tab <- evenness(psd5, "all")
```

</div>

  - Veamos un ejemplo concreto estimando diversidad, graficando los
    resultados y calculando significancia estadística. Para esto usamos
    el paquete `ggpubr` que genera “publication-ready plots”, algo que
    siempre es deseable (ejecuta `library(ggpubr)`).

<div class="sourceCode">

``` sourceCode r
# Generamos un objeto `phyloseq` sin taxa que sume 0 reads
psd5.2 <- prune_taxa(taxa_sums(psd5) > 0, psd5)
# Calculamos los índices de diversidad
tab <- diversities(psd5.2, index = "all")
# Y finalmente visualizamos la tabla de resultados
head(tab)
```

</div>

    ##            inverse_simpson gini_simpson  shannon   fisher coverage
    ## SRR6442697        6.948971    0.8560938 2.181249 4.100949        3
    ## SRR6442698        3.673899    0.7278096 1.913672 5.781418        2
    ## SRR6442699        6.461545    0.8452383 2.043740 3.117388        3
    ## SRR6442700        7.707637    0.8702586 2.412447 6.104153        3
    ## SRR6442701        4.520999    0.7788099 2.038536 5.949163        2
    ## SRR6442702        4.873575    0.7948118 1.759212 4.346443        3

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:310px; overflow-x: scroll; width:100%; ">

|            | inverse\_simpson | gini\_simpson | shannon | fisher | coverage |
| :--------- | ---------------: | ------------: | ------: | -----: | -------: |
| SRR6442697 |             6.95 |          0.86 |    2.18 |   4.10 |        3 |
| SRR6442698 |             3.67 |          0.73 |    1.91 |   5.78 |        2 |
| SRR6442699 |             6.46 |          0.85 |    2.04 |   3.12 |        3 |
| SRR6442700 |             7.71 |          0.87 |    2.41 |   6.10 |        3 |
| SRR6442701 |             4.52 |          0.78 |    2.04 |   5.95 |        2 |
| SRR6442702 |             4.87 |          0.79 |    1.76 |   4.35 |        3 |

</div>

  - Ahora necesitamos extraer la metadata de nuestro objeto `phyloseq`.

<div class="sourceCode">

``` sourceCode r
psd5.2.meta <- meta(psd5.2)
head(psd5.2.meta)
```

</div>

    ##            sample_ID bioproject_accession     study biosample_accession
    ## SRR6442697      EMA4          PRJNA428495 SRP128093        SAMN08292292
    ## SRR6442698      EMA3          PRJNA428495 SRP128093        SAMN08292291
    ## SRR6442699      EMA2          PRJNA428495 SRP128093        SAMN08292284
    ## SRR6442700     EMA19          PRJNA428495 SRP128093        SAMN08292283
    ## SRR6442701     EMA21          PRJNA428495 SRP128093        SAMN08292286
    ## SRR6442702     EMA20          PRJNA428495 SRP128093        SAMN08292285
    ##            experiment        run SRA_Sample               geo_loc_name
    ## SRR6442697 SRX3533985 SRR6442697 SRS2809259 Chile: Estrecho_Magallanes
    ## SRR6442698 SRX3533984 SRR6442698 SRS2809258 Chile: Estrecho_Magallanes
    ## SRR6442699 SRX3533983 SRR6442699 SRS2809257 Chile: Estrecho_Magallanes
    ## SRR6442700 SRX3533982 SRR6442700 SRS2809256 Chile: Estrecho_Magallanes
    ## SRR6442701 SRX3533981 SRR6442701 SRS2809255 Chile: Estrecho_Magallanes
    ## SRR6442702 SRX3533980 SRR6442702 SRS2809254 Chile: Estrecho_Magallanes
    ##            collection_date sample_type                species
    ## SRR6442697            2017        skin Megaptera novaeangliae
    ## SRR6442698            2017        skin Megaptera novaeangliae
    ## SRR6442699            2017        skin Megaptera novaeangliae
    ## SRR6442700            2017        skin Megaptera novaeangliae
    ## SRR6442701            2017        skin Megaptera novaeangliae
    ## SRR6442702            2017        skin Megaptera novaeangliae
    ##               common_name AvgSpotLen
    ## SRR6442697 humpback whale        501
    ## SRR6442698 humpback whale        500
    ## SRR6442699 humpback whale        501
    ## SRR6442700 humpback whale        500
    ## SRR6442701 humpback whale        499
    ## SRR6442702 humpback whale        500

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:500px; overflow-x: scroll; width:100%; ">

|            | sample\_ID | bioproject\_accession | study     | biosample\_accession | experiment | run        | SRA\_Sample | geo\_loc\_name              | collection\_date | sample\_type | species                | common\_name   | AvgSpotLen |
| :--------- | :--------- | :-------------------- | :-------- | :------------------- | :--------- | :--------- | :---------- | :-------------------------- | ---------------: | :----------- | :--------------------- | :------------- | ---------: |
| SRR6442697 | EMA4       | PRJNA428495           | SRP128093 | SAMN08292292         | SRX3533985 | SRR6442697 | SRS2809259  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        501 |
| SRR6442698 | EMA3       | PRJNA428495           | SRP128093 | SAMN08292291         | SRX3533984 | SRR6442698 | SRS2809258  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        500 |
| SRR6442699 | EMA2       | PRJNA428495           | SRP128093 | SAMN08292284         | SRX3533983 | SRR6442699 | SRS2809257  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        501 |
| SRR6442700 | EMA19      | PRJNA428495           | SRP128093 | SAMN08292283         | SRX3533982 | SRR6442700 | SRS2809256  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        500 |
| SRR6442701 | EMA21      | PRJNA428495           | SRP128093 | SAMN08292286         | SRX3533981 | SRR6442701 | SRS2809255  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        499 |
| SRR6442702 | EMA20      | PRJNA428495           | SRP128093 | SAMN08292285         | SRX3533980 | SRR6442702 | SRS2809254  | Chile: Estrecho\_Magallanes |             2017 | skin         | Megaptera novaeangliae | humpback whale |        500 |

</div>

  - Luego agregamos la tabla de diversidad a la metadata.

<div class="sourceCode">

``` sourceCode r
psd5.2.meta$Shannon <- tab$shannon 
psd5.2.meta$InverseSimpson <- tab$inverse_simpson
```

</div>

  - En este ejercicio nos interesa comparar la diversidad entre especies
    de ballenas. Recordemos que tenemos datos para tres especies de
    ballenas: azul, fin y jorobada. Necesitamos crear una lista de
    comparasiones de a pares para poder visualizar y calcular
    significancia estadística de manera simultánea.

<div class="sourceCode">

``` sourceCode r
# Obtenemos las variables desde nuestro objeto `phyloseq`
spps <- levels(psd5.2.meta$species)
# Creamos una lista de lo que queremos comparar
pares.spps <- combn(seq_along(spps), 2, simplify = FALSE, FUN = function(i)spps[i])
# Imprimimos en pantalla el resultado
print(pares.spps)
```

</div>

    ## [[1]]
    ## [1] "Balaenoptera musculus" "Balaenoptera physalus"
    ## 
    ## [[2]]
    ## [1] "Balaenoptera musculus"  "Megaptera novaeangliae"
    ## 
    ## [[3]]
    ## [1] "Balaenoptera physalus"  "Megaptera novaeangliae"

  - Con la función `ggviolin` podemos generar un gráfico de violín en un
    solo paso de la siguiente forma.

<div class="sourceCode">

``` sourceCode r
p1 <- ggviolin(psd5.2.meta, x = "species", y = "Shannon",
 add = "boxplot", fill = "species", palette = c("#a6cee3", "#b2df8a", "#fdbf6f"))  
print(p1)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-39-1.png)

  - Ahora necesitamos evaluar la significancia estadística entre los
    estimados de diversidad de las muestras de ballenas. De nuevo, en
    una línea, tenemos nuestra figura lista para el artículo.

<div class="sourceCode">

``` sourceCode r
p1 <- p1 + stat_compare_means(comparisons = pares.spps)
print(p1)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-40-1.png)

</div>

<div id="diversidad-beta-y-escalamiento-multidimensional-bray-curtis-unifrac-t-sne" class="section level2">

## <span class="header-section-number">3.2</span> Diversidad beta y escalamiento multidimensional (Bray-Curtis, UniFrac, t-SNE)

En cuanto a diversidad beta podemos calcular similitud global a través
de todas las muestras de interés o también podemos cuantificar la
divergencia de un grupo y compararla con la divergencia de otro.

  - Veamos este último caso primero.

<div class="sourceCode">

``` sourceCode r
# Calculamos las divergencias para ballena azul y jorobada
div.azul <- divergence(subset_samples(psd5, species == "Balaenoptera musculus"))
div.joro <- divergence(subset_samples(psd5, species == "Megaptera novaeangliae"))
# transformamos el resultado anterior en _dataframes_
data.frame(div.azul) -> df.div.azul
data.frame(div.joro) -> df.div.joro
# Agregamos columnas a nuestros _dataframes_
mutate(df.div.azul, species = "Blue Whale") -> df.div.azul
mutate(df.div.joro, species = "Humpback Whale") -> df.div.joro
# Cambiamos los nombres de las columans de manera que sean iguales an ambos _dataframes_
colnames(df.div.azul) <- c("divergence", "species")
colnames(df.div.joro) <- c("divergence", "species")
# Los combinamos en un _dataframe_
rbind(df.div.azul, df.div.joro) -> div.boxplot

# Y finalmente graficamos y realizamos una comparación estadística
p2 <- ggboxplot(data = div.boxplot, x = "species", y = "divergence", fill = "species", palette = c("#a6cee3", "#fdbf6f"))
p2 + stat_compare_means(comparisons = list(c("Blue Whale", "Humpback Whale")))
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-41-1.png)

Existen diferentes medidas de similitud (o disimilitud, i.e., 1 -
similitud) disponibles que nos permiten entender las relaciones entre
nuestras muestras. En general todas producen matrices de distancia
comparables. El paquete `phyloseq` ofrece un gran número de medidas de
distancia. Las más populares son UniFrac y Weighted UniFrac (medidas que
consideran filogenia) y otras independientes de filogenia como: Jaccard,
Manhattan, Euclidian, Bray-Curtis, Canberra, etc. Por otra parte, la
matriz de distancia resultante no se usa en aislación sino que en
conjunto con algún método de ordinación o escalamiento multidimensional
(*ordination*). De nuevo, `phyloseq` ofrece un gran número de métodos
entre los cuales se encuentran: detrended y canonical correspondence
analysis, Double Principal Coordinate Analysis, Non-metric
MultiDimenstional Scaling, y MDS/PCoA.

  - Probemos entonces hacer un análisis tipo PCoA con una matriz de
    distancia que considera las relaciones filogenéticas y otra que no.

<div class="sourceCode">

``` sourceCode r
psd5.mds.unifrac <- ordinate(psd5, method = "MDS", distance = "unifrac")
evals <- psd5.mds.unifrac$values$Eigenvalues
pord1 <- plot_ordination(psd5, psd5.mds.unifrac, color = "geo_loc_name") +
  labs(col = "geo_loc_name") +
  coord_fixed(sqrt(evals[2] / evals[1]))

psd5.mds.bray <- ordinate(psd5, method = "MDS", distance = "bray")
evals <- psd5.mds.bray$values$Eigenvalues
pord2 <- plot_ordination(psd5, psd5.mds.bray, color = "geo_loc_name") +
  labs(col = "geo_loc_name") +
  coord_fixed(sqrt(evals[2] / evals[1]))

grid.arrange(pord1, pord2)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-42-1.png)

Nota que los gráficos de dispersión donde se visualiza este tipo de
análisis están escalados según la cantidad de variación que los ejes
explican. En general lo que estos métodos pretenden hacer es tratar de
encontrar el menor número de vectores matemáticos que maximicen la
separación entre las muestras (puntos en el gráfico). Esto nace de la
imposibilidad de graficar eficientemente datos multidimencionales. Los
datos que estamos analizando ciertamente son multidimensionales en el
sentido que tenemos más de 100 taxa que varían simultáneamente en cada
una de las 90+ muestras que tenemos. Volviendo a los ejes, estos no
suman 100% porque hay otros ejes que no estamos usando para graficar y
que contribuyen con el resto de la variación. Al graficarlos de manera
simétrica distorsionaríamos las relaciones entre los puntos,
especialmente si estamos comparando dos o más gráficos.

En específico para comunidades microbianas, el método de doble análisis
de coordenadas principales o (DPCoA) es muy apropiado porque analiza
conjuntamente dos tipos de datos: una tabla de disimilitud que
representa diferencias entre especies y una matriz de abundancia que
representa la distribución de especies entre las comunidades. El
resultado final es un ensamble del espacio multidimensional que
correlacionan las especies con las comunidades. El método fue [publicado
en 2004](https://www.sciencedirect.com/science/article/pii/S0022519304000736).

  - Veamos un ejemplo con nuestros datos.

<div class="sourceCode">

``` sourceCode r
psd5.dpcoa.unifrac <- ordinate(psd5, method = "DPCoA", distance = "dpcoa")
evals <- psd5.dpcoa.unifrac$eig
pord3 <- plot_ordination(psd5, psd5.dpcoa.unifrac, color = "species", shape = "geo_loc_name") +
  labs(col = "Species") +
  coord_fixed(sqrt(evals[2] / evals[1])) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) +
  geom_point(size=4)
pord3
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-43-1.png)

  - Ahora exploremos escalamiento multidimensional usando un método
    reciente conocido como t-SNE o [t-Distributed Stochastic Neighbor
    Embedding](http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf).
    *t-SNE* difiere de otros métodos en que hace énfasis en las
    distancias locales en vez de las distancias globales, de esta forma
    generando una mayor resolución o separación entre los puntos o
    muestras.

<div class="sourceCode">

``` sourceCode r
library(tsnemicrobiota)

tsne_res <- tsne_phyloseq(psd5, distance= "dpcoa", perplexity = 8, verbose=0, rng_seed = 3901)

# Graficamos
pord4 <- plot_tsne_phyloseq(psd5, tsne_res, color = "species", shape = "geo_loc_name") +
  geom_point(size=4) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))

grid.arrange(pord3, pord4)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-44-1.png)

Ambos gráficos usan distintos métodos pero la misma medida de distancia.
Los resultados son similares aunque las agrupaciones de puntos o
muestras ocupan distinto espacio en el gráfico.

  - Otro uso de estas medidas es a través de la visualización de la
    densidad de las muestras en el espacio.

<div class="sourceCode">

``` sourceCode r
method <- "tsne"
trans <- "hellinger"
distance <- "euclidean"

# Matriz de distancia
psd5 <- microbiome::transform(psd5, trans)

# Calculamos similitud entre muestras
dm <- vegdist(otu_table(psd5), distance)

# Corremos t-SNE
tsne_out <- Rtsne(dm, dims = 2, perplexity = 8) 
proj <- tsne_out$Y
rownames(proj) <- rownames(otu_table(psd5))
data.frame(proj) -> proj
proj$species <- sample_data(psd5)[,11]

pland <- plot_landscape(proj[,1:2], legend = T, size = 4) 
print(pland)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-45-1.png)

</div>

<div id="analisis-de-abundancias-y-visualizaciones" class="section level2">

## <span class="header-section-number">3.3</span> Análisis de abundancias y visualizaciones

<div id="grafico-de-barras-apiladas" class="section level3">

### <span class="header-section-number">3.3.1</span> Gráfico de barras apiladas

Una manera muy eficiente de obtener una visión general de la composición
de las muestras es a través de un gráfico de barras apiladas. Existe una
variadad de funciones que pueden hacer esto, sin embargo vamos a usar el
paquete creado por un ex-miembro del laboratorio ya que tiene la ventaja
de poder agrupar por *hierarchical clustering* las muestras entre otras
ventajas.

<div class="sourceCode">

``` sourceCode r
# Necesitamos obtener las taxa más abundantes, en este caso el top 15
top15 <- get_top_taxa(physeq_obj = psd5, n = 15, relative = T,
                       discard_other = T, other_label = "Other")
# Ya que no todas las taxa fueron clasificadas a nivel de especie, generamos etiquetas compuestas de distintos rangos taxonómicos para el gráfico
top15 <- name_taxa(top15, label = "", species = F, other_label = "Other")
# Finalmente graficamos
fantaxtic_bar(top15, color_by = "Family", label_by = "Genus", facet_by = NULL, grid_by = NULL, other_color = "Grey") -> ptop15
```

</div>

    ##                          Level N.color.shades Central.color
    ## 1           Cardiobacteriaceae              1       #6495ED
    ## 2            Flavobacteriaceae              1       #EDBC64
    ## 3                Moraxellaceae              5       #9A64ED
    ## 4  Gammaproteobacteria (Class)              2       #B7ED64
    ## 5             Xanthomonadaceae              1       #ED64DA
    ## 6           Enterobacteriaceae              2       #64ED77
    ## 7             Pseudomonadaceae              2       #ED6473
    ## 8             Burkholderiaceae              1       #64EDDE

<div class="sourceCode">

``` sourceCode r
ptop15
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-46-1.png)

Podemos ver que existen patrones relativamente claros en el gráfico
solamente a partir de los colores. Aunque tenemos el nombre de las
muestras bajo cada barra, sería mejor poder parcelar este gráfico de
manera que quede claro qué muestras corresponden a qué especie de
ballena.

  - La función `fantaxtic_bar` ofrece estas posibilidades a través de
    los argumentos `facet_by` y `grid_by`. Grafiquemos de nuevo.

<div class="sourceCode">

``` sourceCode r
fantaxtic_bar(top15, color_by = "Family", label_by = "Genus", facet_by = "species", grid_by = NULL, other_color = "Grey") -> ptop15.2
```

</div>

    ##                          Level N.color.shades Central.color
    ## 1           Cardiobacteriaceae              1       #6495ED
    ## 2            Flavobacteriaceae              1       #EDBC64
    ## 3                Moraxellaceae              5       #9A64ED
    ## 4  Gammaproteobacteria (Class)              2       #B7ED64
    ## 5             Xanthomonadaceae              1       #ED64DA
    ## 6           Enterobacteriaceae              2       #64ED77
    ## 7             Pseudomonadaceae              2       #ED6473
    ## 8             Burkholderiaceae              1       #64EDDE

<div class="sourceCode">

``` sourceCode r
ptop15.2
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-47-1.png)

Ahora queda más claro y se puede observar que las distintas especies de
ballena tienen un patrón similar entre sí que es diferente entre las
otras, con algunas excepciones. Por ejemplo, para ballena jorobada
podemos ver un conjunto de muestras que no se parecen al resto. Usando
las herramientas ya aprendidas, ¿A qué corresponden esas muestras?

</div>

<div id="diferentes-visualizaciones-de-abundancias" class="section level3">

### <span class="header-section-number">3.3.2</span> Diferentes visualizaciones de abundancias

Veamos ahora otras herramientas que nos permiten examinar la composición
de estas comunidades microbianas. El paquete `ampvis2`, desarrollado por
Mads Albertsen y Kasper Skytte Andersen, nos permite hacer precisamente
esto. Primero transformemos el objeto `phyloseq` con el cual hemos
estado trabajando en un objeto `ampvis2`.

<div class="sourceCode">

``` sourceCode r
library(ampvis2)

# Necesitamos extraer la tabla de read counts y la tabla de taxonomía del objeto psd5
# Generamos una copia para no sobreescribir psd5
obj <- psd5
# Cambiamos la orientación de la otu_table
t(otu_table(obj)) -> otu_table(obj)
# Extraemos las tablas
otutable <- data.frame(OTU = rownames(phyloseq::otu_table(obj)@.Data),
                       phyloseq::otu_table(obj)@.Data,
                       phyloseq::tax_table(obj)@.Data,
                       check.names = FALSE
)
# Extraemos la metadada
metadata <- data.frame(phyloseq::sample_data(obj), 
                       check.names = FALSE
)

# ampvis2 requiere que 1) los rangos taxonómicos sean siete y vayan de Kingdom a Species y 2) la primera columna de la metadata sea el identificador de cada muestra
# Entonces duplicamos la columna Género y le cambiamos el nombre a Especie
otutable$Species = otutable$Genus
# Reordenamos la metadata
metadata <- metadata[,c("run","sample_ID","bioproject_accession","study","biosample_accession","experiment","SRA_Sample","geo_loc_name","collection_date","sample_type","species","common_name","AvgSpotLen")]

# finalmente generamos el objeto ampvis
av2 <- amp_load(otutable, metadata)
```

</div>

  - Ahora echemos un vistazo a la estructura de las comunidades
    utilizando “rank abundance curves”.

<div class="sourceCode">

``` sourceCode r
amp_rankabundance(av2, plot_log = T, group_by = "species")
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-49-1.png)

El gráfico nos muestra que en la medida que vamos sumando las taxa de
mayor a menor abundancia (*Rank Abundance*) la abundancia de reads
cumulativa va aumentando. Lo importante de observar es la forma de la
curva. Una curva que sube rápidamente nos indica que las comunidades
están dominadas por unas cuantas taxa. En cambio, lo que observamos en
nuestros datos es que las taxa más abundantes solamente dan cuenta de
aproximadamente el 25% de la abundancia cumulativa de reads.

  - Veamos ahora qué taxa corresponde a ese 25%. Para esto podemos usar
    la función `amp_heatmap`.

<div class="sourceCode">

``` sourceCode r
amp_heatmap(av2, 
            group_by = "species", 
            facet_by = "geo_loc_name", 
            plot_values = TRUE,
            tax_show = 20,
            tax_aggregate = "Genus",
            tax_add = "Phylum",
            plot_colorscale = "sqrt",
            plot_legendbreaks = c(1, 5, 10)
            )
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-50-1.png)

*Tenacibaculum* parece ser el género más abundante para todas las
muestras en todas los sitios de muestreo con excepción de *Balaenoptera
physalus* que está dominada por *Stenotrphomonas*. *Moraxella* y
distintas variantes de Cardiobacteriaceae de género no conocido.
Justamente estos resultados se ajustan a lo conocido para cetáceos y
otros mamíferos marinos.

  - También podemos realizar una visualización similar pero usando Box
    Plots.

<div class="sourceCode">

``` sourceCode r
amp_boxplot(av2,
            group_by = "species",
            tax_show = 20,
            tax_aggregate = "Genus",
            tax_add = "Phylum",
            adjust_zero = T,
            plot_log = T) +
  scale_color_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f")) + 
  scale_fill_manual(values = c("#a6cee3", "#b2df8a", "#fdbf6f"))
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-51-1.png)

  - Veamos ahora si es que algunos de estos microorganismos están
    compartidos entre todas las muestras. Para esto debemos calcular el
    *core microbiome* o el conjunto de taxa compartidas entre un cierto
    umbral porcentual de muestras y de prevalencia intra-muestra.

<div class="sourceCode">

``` sourceCode r
amp_core(av2, 
         tax_aggregate = "Family",
         group_by = "Sample",
         abund_thrh = 0.5)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-52-1.png)

  - Y visto de otra manera en un diagrama de Venn.

<div class="sourceCode">

``` sourceCode r
amp_venn(av2, group_by = "species", cut_a = 0, cut_f = 50, text_size = 3)
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-53-1.png)

</div>

<div id="analisis-de-abundancia-diferencial-de-microorganismos" class="section level3">

### <span class="header-section-number">3.3.3</span> Análisis de abundancia diferencial de microorganismos

Hasta ahora hemos visto principalmente análisis exploratorios y algunos
test estadísticos para diversidad alfa y beta. Sin embargo, muchas veces
queremos determinar exactamente qué taxa está más representada en una
condición versus otra y en qué medida. El procedimiento es análogo al
análisis de expresión diferencial de genes en transcritómica, e.g.,
RNA-seq. Es tan así que justamente ocupamos uno de los paquetes de R más
populares en transcriptómica, **DESeq2**. Ahora, nuestras muestras se
secuenciaron al mismo tiempo y se intentó que se produjera una
profundidad uniforme a través de todas las muestras. En la práctica esto
no ocurre y al momento de analizar las muestras en el contexto del
**análisis diferencial de abundancia** debemos corregir por dos
situaciones: el tamaño desigual de las muestras (en número de reads) y
la correlación de la variabilidad de los datos con la media de éstos.
Para esto último, utilizamos una transformación llamada **Variance
Stabilizing Transformation**, cuyo objetivo es encontrar una función ƒ
que se aplique a los valores de read counts, de tal forma que en los
nuevos valores y = ƒ(x), la variabilidad de y no se relacione con sus
valores medios.

  - Comencemos por aplicar la transformación en los datos.

<div class="sourceCode">

``` sourceCode r
# Creamos un objeto DESeq2 con la función `phyloseq_to_deseq2`
diagdds = phyloseq_to_deseq2(psd5, ~species)
# Calculamos los factores de tamaño como parte de la normalización de las muestras
# calculate geometric means prior to estimate size factors
gm_mean = function(x, na.rm=TRUE){
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}
geoMeans = apply(counts(diagdds), 1, gm_mean)
diagdds = estimateSizeFactors(diagdds, geoMeans = geoMeans)

# Normalizamos y realizamos el test paramétrico de Wald para determinar taxa diferencialmente abundante.
diagdds = DESeq(diagdds, test="Wald", fitType="local")
```

</div>

Hasta ahora hemos transformado nuestro objeto `phyloseq` en un objeto
`DESeq2` de nombre `diagdds`, y hemos normalizado las cuentas y
realizado un test paramétrico (Wald Test).

  - Nos queda entonces revisar los resultados usando la función
    `results`.

<div class="sourceCode">

``` sourceCode r
# Guardamos los resultados en el objeto res
res = results(diagdds, cooksCutoff = FALSE)
# hacemos un poco de aseo y ordenamos la tabla de resultados según p-value, y dejamos los valores NA al final
res = res[order(res$padj, na.last=NA), ]
```

</div>

  - Ahora nosotros queremos averiguar sobre ciertos contrastes
    específicos entre condiciones, e.g., ballena jorobada versus
    ballena azul. En el contraste, pasamos un vector con el nombre de la
    columna en la metadata (“species”) e indicamos el numerador de la
    comparación (“Megaptera novaeangliae”) y el denominador
    (“Balaenoptera musculus”). Por lo tanto el `log2FoldChange`
    positivo indicará que ese microorganismo es más abundante en ballena
    jorobada que en ballena azul, y viceversa.

<div class="sourceCode">

``` sourceCode r
res.joro.azul <- results(diagdds, contrast=c("species","Megaptera novaeangliae","Balaenoptera musculus"))
```

</div>

  - Descarga el archivo `res.joro.azul.RDS`
    [**AQUÍ**](https://www.dropbox.com/s/jxufvf51hb127g5/res.joro.azul.RDS?dl=1)

  - Veamos qué hay en `res.joro.azul`

<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:400px; overflow-x: scroll; width:100%; ">

|        |     baseMean | log2FoldChange |     lfcSE |        stat |    pvalue |      padj |
| :----- | -----------: | -------------: | --------: | ----------: | --------: | --------: |
| ASV1   | 2719.4817399 |    \-7.1224534 | 1.0359380 | \-6.8753665 | 0.0000000 | 0.0000000 |
| ASV2   | 2022.5405509 |      5.4006313 | 0.7461453 |   7.2380427 | 0.0000000 | 0.0000000 |
| ASV3   | 2100.9914000 |      5.3802668 | 0.6766070 |   7.9518346 | 0.0000000 | 0.0000000 |
| ASV4   |  489.6362991 |      0.8724453 | 0.8271381 |   1.0547760 | 0.2915278 | 0.3442805 |
| ASV5   | 1138.1509390 |     13.0147565 | 1.3019415 |   9.9964222 | 0.0000000 | 0.0000000 |
| ASV6   |   45.6810800 |      5.5840818 | 1.8653474 |   2.9935880 | 0.0027572 | 0.0049735 |
| ASV7   |  245.1490808 |      4.4924803 | 0.9791466 |   4.5881589 | 0.0000045 | 0.0000168 |
| ASV8   | 1211.9442253 |    \-3.2250402 | 0.9315225 | \-3.4621172 | 0.0005359 | 0.0012307 |
| ASV9   |  148.8626474 |      4.0117257 | 0.8333867 |   4.8137625 |        NA |        NA |
| ASV10  |  548.7130326 |      6.4054200 | 0.7366579 |   8.6952434 | 0.0000000 | 0.0000000 |
| ASV11  | 1009.5925018 |    \-5.0854806 | 0.8255799 | \-6.1598889 | 0.0000000 | 0.0000000 |
| ASV12  |  658.7876904 |    \-3.2447714 | 1.0411077 | \-3.1166530 | 0.0018292 | 0.0034895 |
| ASV13  |  410.6582559 |      3.0099935 | 0.8716746 |   3.4531160 | 0.0005542 | 0.0012494 |
| ASV14  |  140.0717828 |      3.8198888 | 1.0080979 |   3.7892044 |        NA |        NA |
| ASV15  |  379.3194323 |      7.5644546 | 0.8161418 |   9.2685548 | 0.0000000 | 0.0000000 |
| ASV16  |  285.7620345 |      7.6440491 | 0.9097626 |   8.4022455 | 0.0000000 | 0.0000000 |
| ASV17  |  379.4487960 |     14.2183560 | 1.4003173 |  10.1536672 | 0.0000000 | 0.0000000 |
| ASV18  |  203.0595008 |      9.1750665 | 1.1303913 |   8.1167175 | 0.0000000 | 0.0000000 |
| ASV19  |   69.8158128 |    \-2.2614994 | 0.9908843 | \-2.2823041 | 0.0224714 | 0.0331721 |
| ASV20  |  299.9612618 |      5.6657701 | 0.9446883 |   5.9975021 | 0.0000000 | 0.0000000 |
| ASV21  |   91.1653741 |      7.8577937 | 1.1458691 |   6.8574966 | 0.0000000 | 0.0000000 |
| ASV22  |  522.4807634 |    \-3.8585579 | 1.1993634 | \-3.2171718 | 0.0012946 | 0.0027209 |
| ASV23  |  100.3448777 |     10.0985821 | 1.3550063 |   7.4527934 | 0.0000000 | 0.0000000 |
| ASV24  |  345.5275036 |      8.1857232 | 1.3845014 |   5.9123979 | 0.0000000 | 0.0000000 |
| ASV25  |  278.9908685 |    \-2.5125876 | 1.5875681 | \-1.5826644 | 0.1134980 | 0.1436097 |
| ASV26  |   62.1557348 |    \-0.4907744 | 1.4756983 | \-0.3325709 | 0.7394582 | 0.7904553 |
| ASV27  |  189.6100970 |    \-3.6035868 | 1.2050796 | \-2.9903310 | 0.0027868 | 0.0049735 |
| ASV28  |  218.1259662 |    \-0.4960691 | 0.8838224 | \-0.5612769 | 0.5746088 | 0.6361740 |
| ASV29  |  348.5666726 |    \-9.2693864 | 1.2067447 | \-7.6813154 | 0.0000000 | 0.0000000 |
| ASV30  |   19.9949713 |    \-6.9404408 | 2.0012541 | \-3.4680458 |        NA |        NA |
| ASV31  |    9.4574754 |      4.4204992 | 1.8265012 |   2.4202006 | 0.0155119 | 0.0234571 |
| ASV32  |  135.9042193 |      4.6452237 | 1.0957355 |   4.2393659 | 0.0000224 | 0.0000678 |
| ASV33  |   12.2150782 |      3.8067681 | 1.2271358 |   3.1021570 |        NA |        NA |
| ASV34  |   14.5758192 |      6.9563749 | 0.9863495 |   7.0526474 | 0.0000000 | 0.0000000 |
| ASV35  |   78.7642402 |      1.0289747 | 0.8831016 |   1.1651827 |        NA |        NA |
| ASV36  |   15.6844519 |      4.4745682 | 1.5457245 |   2.8948031 | 0.0037940 | 0.0065340 |
| ASV37  |  104.0931206 |      6.3198854 | 1.0890983 |   5.8028606 | 0.0000000 | 0.0000000 |
| ASV38  |   63.0999441 |      7.0198666 | 1.2124308 |   5.7899111 | 0.0000000 | 0.0000000 |
| ASV39  |   71.6857366 |    \-4.1210982 | 0.9699437 | \-4.2488015 | 0.0000215 | 0.0000666 |
| ASV40  |   11.7563573 |      4.6362327 | 1.8491255 |   2.5072570 |        NA |        NA |
| ASV41  |   63.6924912 |      6.7765578 | 1.5717381 |   4.3115057 | 0.0000162 | 0.0000522 |
| ASV42  |   39.8228286 |      3.9641573 | 1.1704109 |   3.3869791 | 0.0007067 | 0.0015108 |
| ASV43  |   29.6927766 |      0.6482185 | 0.9863497 |   0.6571893 | 0.5110592 | 0.5761031 |
| ASV44  |    4.6851145 |    \-4.9032274 | 1.1881480 | \-4.1267818 | 0.0000368 | 0.0001061 |
| ASV45  |   31.3542359 |    \-5.8903163 | 1.0674036 | \-5.5183589 | 0.0000000 | 0.0000001 |
| ASV46  |   52.3468950 |      8.1940044 | 1.2045392 |   6.8026052 | 0.0000000 | 0.0000000 |
| ASV47  |   24.3460080 |      5.1994788 | 1.1498081 |   4.5220406 | 0.0000061 | 0.0000223 |
| ASV48  |    9.5531988 |    \-3.1476568 | 1.9364467 | \-1.6254807 |        NA |        NA |
| ASV49  |   28.1689872 |      4.3313913 | 1.3563693 |   3.1933718 | 0.0014062 | 0.0028817 |
| ASV50  |   89.6234760 |    \-8.8288920 | 1.2859692 | \-6.8655549 | 0.0000000 | 0.0000000 |
| ASV51  |   42.8236021 |      7.0692754 | 1.5947984 |   4.4327079 | 0.0000093 | 0.0000328 |
| ASV52  |    1.0011767 |      2.5999491 | 1.5148878 |   1.7162651 | 0.0861135 | 0.1112300 |
| ASV53  |   33.2080947 |      1.4605265 | 0.9766925 |   1.4953800 | 0.1348153 | 0.1655158 |
| ASV54  |   82.8130820 |    \-2.1815886 | 1.1338739 | \-1.9240134 | 0.0543529 | 0.0732583 |
| ASV55  |    9.1745027 |      3.2672435 | 1.9477963 |   1.6774051 | 0.0934633 | 0.1194789 |
| ASV56  |   11.3403634 |      4.6971790 | 1.4994164 |   3.1326715 | 0.0017322 | 0.0034095 |
| ASV57  |   16.5241450 |      1.8610673 | 1.5605106 |   1.1926015 | 0.2330255 | 0.2778381 |
| ASV58  |   13.2662521 |      2.8954770 | 1.4432286 |   2.0062497 | 0.0448296 | 0.0624592 |
| ASV59  |   99.5242996 |   \-10.6308795 | 1.2924338 | \-8.2254731 | 0.0000000 | 0.0000000 |
| ASV60  |   68.5859180 |      1.1857152 | 1.2128028 |   0.9776653 | 0.3282399 | 0.3839788 |
| ASV61  |    2.5896101 |      0.5237964 | 0.9994077 |   0.5241068 |        NA |        NA |
| ASV62  |    7.2983417 |      4.2913582 | 1.4469920 |   2.9657096 | 0.0030199 | 0.0052741 |
| ASV63  |   10.6361249 |      7.2294633 | 1.8091772 |   3.9959952 | 0.0000644 | 0.0001816 |
| ASV64  |   83.5838226 |    \-2.6340549 | 1.2610396 | \-2.0887963 | 0.0367261 | 0.0517504 |
| ASV65  |   47.6516393 |     10.1206302 | 1.4127059 |   7.1640036 | 0.0000000 | 0.0000000 |
| ASV66  |   70.2942412 |      5.2089523 | 1.4217267 |   3.6638212 | 0.0002485 | 0.0006032 |
| ASV67  |   24.7841554 |      5.1537365 | 1.2188111 |   4.2284950 | 0.0000235 | 0.0000695 |
| ASV68  |   14.2934620 |      5.5087333 | 1.4218510 |   3.8743394 | 0.0001069 | 0.0002821 |
| ASV69  |   21.2132029 |      1.7036268 | 1.1444604 |   1.4885853 | 0.1365966 | 0.1660586 |
| ASV70  |   68.7558900 |    \-0.3460662 | 1.6848409 | \-0.2053999 | 0.8372597 | 0.8516169 |
| ASV71  |    6.2303015 |    \-0.2601080 | 1.2445510 | \-0.2089974 |        NA |        NA |
| ASV72  |   14.6638119 |      7.0648004 | 1.6396906 |   4.3086180 | 0.0000164 | 0.0000522 |
| ASV73  |    7.5897409 |      5.3428616 | 1.4510121 |   3.6821619 | 0.0002313 | 0.0005735 |
| ASV74  |    5.0789582 |    \-1.3853182 | 1.1394033 | \-1.2158278 |        NA |        NA |
| ASV75  |   19.8697343 |     24.2907265 | 1.8316754 |  13.2614802 | 0.0000000 | 0.0000000 |
| ASV76  |    1.2239068 |    \-1.9354764 | 1.2311449 | \-1.5720947 | 0.1159286 | 0.1437514 |
| ASV77  |    9.0374513 |    \-9.8994430 | 1.4981683 | \-6.6076975 | 0.0000000 | 0.0000000 |
| ASV78  |   21.1929292 |      8.8483467 | 1.6584029 |   5.3354626 | 0.0000001 | 0.0000004 |
| ASV79  |   13.7751655 |    \-2.6546117 | 1.4029815 | \-1.8921217 | 0.0584748 | 0.0771369 |
| ASV80  |   28.3678395 |     23.0655138 | 1.6147380 |  14.2843691 | 0.0000000 | 0.0000000 |
| ASV81  |    9.9644103 |    \-2.8946247 | 0.7983325 | \-3.6258383 |        NA |        NA |
| ASV82  |    5.5165903 |      5.0158379 | 1.8121294 |   2.7679247 | 0.0056414 | 0.0095827 |
| ASV83  |   22.0290096 |      7.8115706 | 1.2982118 |   6.0171773 | 0.0000000 | 0.0000000 |
| ASV84  |    5.3880867 |      3.5536543 | 1.1892872 |   2.9880540 | 0.0028076 | 0.0049735 |
| ASV85  |    1.7369590 |    \-3.9773770 | 1.3253471 | \-3.0010078 | 0.0026909 | 0.0049735 |
| ASV86  |    8.6940194 |      0.9909398 | 1.7309680 |   0.5724772 | 0.5669987 | 0.6334040 |
| ASV87  |    2.6463367 |    \-4.9527209 | 1.2607597 | \-3.9283623 | 0.0000855 | 0.0002305 |
| ASV88  |   22.4846884 |    \-7.9573124 | 1.0142627 | \-7.8454155 | 0.0000000 | 0.0000000 |
| ASV89  |   29.2974383 |    \-5.7553117 | 1.0928471 | \-5.2663465 | 0.0000001 | 0.0000005 |
| ASV90  |    5.5849388 |      4.5854927 | 2.0669960 |   2.2184332 | 0.0265253 | 0.0386957 |
| ASV91  |   16.5698452 |    \-7.4960519 | 1.3749392 | \-5.4519154 | 0.0000000 | 0.0000002 |
| ASV92  |   22.6522435 |    \-4.9676859 | 1.2977662 | \-3.8278742 | 0.0001293 | 0.0003339 |
| ASV93  |    6.4062042 |    \-4.0851822 | 1.5797024 | \-2.5860455 | 0.0097084 | 0.0156343 |
| ASV94  |    1.7970262 |      3.0983231 | 1.2328023 |   2.5132359 | 0.0119629 | 0.0190180 |
| ASV95  |   11.9501380 |    \-7.6996523 | 1.3118837 | \-5.8691576 | 0.0000000 | 0.0000000 |
| ASV96  |    2.8351525 |      0.3828029 | 1.6800387 |   0.2278536 | 0.8197600 | 0.8470854 |
| ASV97  |    3.7248506 |      5.1135350 | 1.5097237 |   3.3870667 | 0.0007064 | 0.0015108 |
| ASV98  |    4.3233609 |      4.8042120 | 1.9622148 |   2.4483619 | 0.0143507 | 0.0219690 |
| ASV99  |    2.8243846 |      3.5024621 | 1.0975926 |   3.1910403 | 0.0014176 | 0.0028817 |
| ASV100 |    9.9778511 |    \-4.6282742 | 1.2648220 | \-3.6592297 | 0.0002530 | 0.0006032 |
| ASV101 |    7.1881927 |    \-0.4163206 | 1.6084949 | \-0.2588262 | 0.7957694 | 0.8292050 |
| ASV102 |    8.2413114 |    \-3.7473291 | 1.1989296 | \-3.1255621 | 0.0017747 | 0.0034384 |
| ASV103 |    8.3102765 |    \-6.7562778 | 1.5258751 | \-4.4278053 | 0.0000095 | 0.0000328 |
| ASV104 |    6.7857308 |      5.7064612 | 1.6741681 |   3.4085353 | 0.0006531 | 0.0014462 |
| ASV105 |    5.0488641 |      4.1346140 | 1.5935323 |   2.5946219 | 0.0094695 | 0.0154502 |
| ASV106 |    0.9541234 |    \-1.1028164 | 2.0346151 | \-0.5420270 | 0.5877999 | 0.6450193 |
| ASV107 |    4.1007567 |      4.9980913 | 1.1373183 |   4.3946286 | 0.0000111 | 0.0000372 |
| ASV108 |    5.4038096 |    \-3.6271094 | 1.2133551 | \-2.9893224 | 0.0027960 | 0.0049735 |
| ASV109 |    1.3501927 |    \-0.4206071 | 1.4415801 | \-0.2917681 | 0.7704639 | 0.8096400 |
| ASV110 |    2.7371281 |      3.3005287 | 1.7374702 |   1.8996174 | 0.0574833 | 0.0766445 |
| ASV111 |    2.4259080 |      4.5000589 | 1.8203672 |   2.4720611 | 0.0134337 | 0.0210857 |
| ASV112 |    1.5325388 |    \-0.6703858 | 1.9366425 | \-0.3461588 | 0.7292234 | 0.7862930 |
| ASV113 |    5.1286581 |      5.5651234 | 1.5523269 |   3.5850202 | 0.0003371 | 0.0007886 |
| ASV114 |    3.2084055 |      4.2076848 | 1.5538169 |   2.7079669 | 0.0067697 | 0.0113438 |
| ASV115 |    1.8693006 |      4.1459636 | 1.5967342 |   2.5965270 | 0.0094171 | 0.0154502 |
| ASV116 |    7.7258899 |    \-6.1720272 | 1.5544558 | \-3.9705388 | 0.0000717 | 0.0001976 |
| ASV117 |    4.6721853 |    \-6.3099610 | 1.6600099 | \-3.8011586 | 0.0001440 | 0.0003645 |
| ASV118 |    0.9186556 |    \-1.6434260 | 1.7179194 | \-0.9566375 | 0.3387503 | 0.3925704 |
| ASV119 |    7.0228498 |    \-1.8945403 | 0.8629677 | \-2.1953780 | 0.0281365 | 0.0401026 |
| ASV120 |    0.8432035 |      0.1593532 | 1.9188207 |   0.0830475 | 0.9338138 | 0.9338138 |
| ASV121 |    3.3482616 |    \-2.7839431 | 1.2669338 | \-2.1973864 | 0.0279929 | 0.0401026 |
| ASV122 |    3.6359471 |    \-4.5928491 | 1.8643476 | \-2.4635155 | 0.0137582 | 0.0213252 |
| ASV123 |    1.7902754 |    \-1.4023022 | 1.5327540 | \-0.9148906 | 0.3602491 | 0.4136193 |
| ASV124 |    2.6697932 |      2.1839877 | 1.3857261 |   1.5760602 | 0.1150119 | 0.1437514 |
| ASV125 |    1.1415391 |    \-0.7290996 | 1.8509376 | \-0.3939082 | 0.6936488 | 0.7544952 |
| ASV126 |    2.9465902 |    \-1.8431157 | 1.2640321 | \-1.4581241 | 0.1448064 | 0.1743300 |
| ASV127 |    2.9109028 |      0.9547596 | 1.1013290 |   0.8669159 | 0.3859881 | 0.4391057 |
| ASV128 |    2.9624475 |    \-4.1618781 | 1.3116973 | \-3.1728951 | 0.0015093 | 0.0030185 |
| ASV129 |    2.1092384 |    \-0.3088813 | 1.5096505 | \-0.2046045 | 0.8378811 | 0.8516169 |
| ASV130 |    1.4749075 |    \-0.2884521 | 0.9376518 | \-0.3076324 | 0.7583621 | 0.8037342 |
| ASV131 |    2.3920165 |    \-2.4765750 | 1.3681047 | \-1.8102232 | 0.0702612 | 0.0917093 |
| ASV132 |    1.3600064 |      0.1650124 | 1.5324853 |   0.1076763 | 0.9142524 | 0.9216854 |
| ASV133 |    0.7154383 |      2.8063290 | 1.4139574 |   1.9847338 | 0.0471741 | 0.0649954 |
| ASV134 |    1.0638791 |    \-1.5182223 | 1.3665996 | \-1.1109489 |        NA |        NA |
| ASV135 |    1.4368076 |    \-4.0800926 | 1.6943303 | \-2.4080857 | 0.0160364 | 0.0239580 |
| ASV136 |    0.6620716 |    \-2.3480281 | 1.2061752 | \-1.9466725 | 0.0515740 | 0.0702767 |

</div>

¿Qué significa cada columna? Revisa la viñeta de `DESeq2`
[aquí](http://bioconductor.org/packages/devel/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#more-information-on-results-columns).

  - Ahora establezcamos un umbral de significancia estadística para los
    valores de *p-value* ajustado o `padj`. Cualquier resultado bajo
    este umbral será considerado no significativo y viceversa.

<div class="sourceCode">

``` sourceCode r
# Este es nuestro umbral
alpha = 0.01
# Ordenamos la tabla de resultados
res.joro.azul = res.joro.azul[order(res.joro.azul$padj, na.last=NA), ]
# Filtramos según nuestro umbral alpha
sigtab = res.joro.azul[(res.joro.azul$padj < alpha), ]
# Le agregamos la taxonomía a la tabla
sigtab = cbind(as(sigtab, "data.frame"), as(tax_table(psd5)[rownames(sigtab), ], "matrix"))

# Manipulaciones varias para finalmente graficar los resultados
sigtabgen = subset(sigtab, !is.na(Genus))
# Phylum order
x = tapply(sigtabgen$log2FoldChange, sigtabgen$Phylum, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Phylum = factor(as.character(sigtabgen$Phylum), levels=names(x))
# Genus order
x = tapply(sigtabgen$log2FoldChange, sigtabgen$Genus, function(x) max(x))
x = sort(x, TRUE)
sigtabgen$Genus = factor(as.character(sigtabgen$Genus), levels=names(x))
ggplot(sigtabgen, aes(y=Genus, x=log2FoldChange, color=Phylum)) + 
    geom_vline(xintercept = 0.0, color = "gray", size = 0.5) +
    geom_point(size=4) + 
    theme(axis.text.x = element_text(angle = -90, hjust = 0, vjust=0.5, size = 10), axis.text.y = element_text(size = 13), legend.text = element_text(size = 13) )
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-60-1.png)

</div>

<div id="redes-de-co-ocurrencia" class="section level3">

### <span class="header-section-number">3.3.4</span> Redes de co-ocurrencia

Para finalizar, vamos a echar un vistazo a las capacidades de `phyloseq`
para generar redes de co-occurrencia. Las redes de co-ocurrencia nos dan
pistas sobre potenciales interacciones ecológicas entre organismos.
Estas interacciones pueden ser directas o indirectas (no lo podemos
determinar a partir de una red) y nos permiten comenzar a descifrar
mecanismos ecológicos detrás de la composición de una comunidad
microbiana. En general en ecología tenemos distintos tipos de
interacciones:

<div class="figure">

![](images/ecological_interactions.png)

</div>

Donde destacan depredación, competición o depredación mutua, y
mutualismo. Cada una de estas relaciones podría ser detectada en una red
de co-ocurrencia según patrones de correlación positivos o negativos.

  - Veamos como generaríamos una red en `phyloseq`.

<div class="sourceCode">

``` sourceCode r
plot_net(psd5, type = "taxa", point_label = "Genus", point_size = 10, point_alpha = 0.5, maxdist = 0.5, color = "Phylum", distance = "bray", laymeth = "auto") 
```

</div>

![](biodiversity_files/figure-html/unnamed-chunk-61-1.png)

La red generada con `phyloseq` no es una red de co-ocurrencia
propiamente tal. Es más bien una red que representa relaciones de
distancia entre taxa o muestras. En nuestro ejemplo usamos muestras.
Para una red de co-ocurrencia propiamente tal necesitamos usar las
funciones del paquete `SpiecEasi`.

  - Veamos un ejemplo de cómo hacerlo.

<div class="sourceCode">

``` sourceCode r
se.mb.psd5 <- spiec.easi(psd5, method='mb', lambda.min.ratio=1e-2,
                           nlambda=20, icov.select.params=list(rep.num=50))
ig2.mb <- adj2igraph(se.mb.psd5$refit,  vertex.attr=list(name=taxa_names(psd5)))
plot_network(ig2.mb, psd5, type='taxa', color="Phylum")
```

</div>

<div class="figure">

![](images/SpiecEasi.png)

</div>

Para conocer más de redes de co-ocurrencia microbiana, dirígete al
tutorial de la unidad [Redes de co-ocurrencia de
microorganismos](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)

-----

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

</div>

</div>

</div>

</div>

</div>

</div>

</div>

</div>

</div>

<div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

<div class="book-summary">

  - [Redes de co-ocurrencia de
    microorganismos](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)

  - 
  - [****0.1** Acerca del curso](#workshop)

  - [****1** Configurar sesión de R](#setup)

  - [****2** Datos de estudio](#comau)
    
      - [****2.1** Datos de entrada](#input)
          - [****2.1.1** Pre-procesamiento](#pre-procesamiento)
      - [****2.2** Perfil taxonómico](#perfil-taxonomico)

  - [****3** Redes de co-ocurrencia microbiana](#network)
    
      - [****3.1** SPIEC-EASI](#spiec-easi)
      - [****3.2** ggnet2](#ggnet2)

  - [****4** Características de la red](#features)
    
      - [****4.1** Relaciones de co-ocurrencia positiva y
        negativa](#relaciones-de-co-ocurrencia-positiva-y-negativa)
      - [****4.2** Estabilidad visual](#estabilidad-visual)

  - [****5** Estadística de la red](#stats)
    
      - [****5.1** *Degree*](#degree)
      - [****5.2** *Node centrality*](#node-centrality)
          - [****5.2.1** *Closeness*](#closeness)
          - [****5.2.2** *Betweenness*](#betweenness)
      - [****5.3** *Transitivity*](#transitivity)
      - [****5.4** *Average Nearest Neighbor Degree*
        (ANND)](#average-nearest-neighbor-degree-annd)

  - [****6** Estructura de la red](#structure)
    
      - [****6.1** Detección de módulos](#deteccion-de-modulos)
          - [****6.1.1** Modularidad](#modularidad)
          - [****6.1.2** Visualizar módulos](#visualizar-modulos)
      - [****6.2** Sub-redes](#sub-redes)

  - [****7** Búsqueda de *keystone species*](#keystone)
    
      - [****7.1** *Node degree*](#node-degree)
      - [****7.2** *Node centrality*](#node-centrality-1)
      - [****7.3** *Keystone species*](#keystone-species)
      - [****7.4** Nodo TI\_27772](#nodo-ti_27772)

  - 
  - [CASTRO LAB](http://www.castrolab.org)

  - [ISME LA 2019](https://isme-la2019.org)

</div>

<div class="book-body">

<div class="body-inner">

<div class="book-header" role="navigation">

# **[Redes de co-ocurrencia de microorganismos](./)

</div>

<div class="page-wrapper" tabindex="-1" role="main">

<div class="page-inner">

<div id="section-" class="section normal">

<div id="header">

*ISME Latin America, Septiembre 2019*

</div>

<div id="workshop" class="section level2">

## <span class="header-section-number">0.1</span> Acerca del curso

El tutorial a continuación fue creado especialmente para guiar el
trabajo práctico del [**curso pre-congreso ISME Latin
America 2019**](https://isme-la2019.org/curso-pre-congreso/): **Análisis
de datos bioinformáticos para metagenomas y amplicones usando R**. A
realizarse el próximo 9 y 10 de septiembre en la [Universidad Técnica
Federico Santa María](https://www.usm.cl), Valparaíso, Chile.

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

El curso cuenta con **6 unidades**. Ahora, usted se encuentra en la
unidad: **Redes de co-ocurrencia de microorganismos**
![](images/network.png)

> **Otras unidades del curso son**:
> 
> [**Introducción a R: Manipulación de datos y
> visualización**](http://www.castrolab.org/isme/introR/introR.html)
> ![](images/r.png)
> 
> [**Análisis de secuencias de 16S con
> DADA2**](http://www.castrolab.org/isme/dada2/dada2.html)
> ![](images/bioinformatics.png)
> 
> [**Introducción a phyloseq y a análisis de
> diversidad**](http://www.castrolab.org/isme/biodiversity/biodiversity.html)
> ![](images/bacteria.png)
> 
> [**Búsqueda de genes de interés en datos de metagenómica
> *shotgun***](http://www.castrolab.org/isme/gene_search/gene_search.html)
> ![](images/gene_search.png)
> 
> [**Visualización y curación de genomas ensamblados desde metagenomas
> (MAGs)**](http://www.castrolab.org/isme/mags/mags.html)
> ![](images/genome.png)

-----

  - Profesor: **Dr. Eduardo Castro-Nallar** (<eduardo.castro@unab.cl>)

  - Ayudantes:
    
      - **Dr. Florence Gutzwiller** (<florence.gutzwiller@gmail.com>)
      - **M.Sc. Katterinne N. Mendez** (<mendez.katterinne@gmail.com>)

**[CASTRO LAB](http://www.castrolab.org)**

[Centro de Bioinformática y Biología Integrativa](http://www.cbib.cl) |
[Universidad Andrés Bello](https://www.unab.cl)

![](images/UNAB_CBIB_horizontal.png)

[Santiago, Chile](https://goo.gl/maps/BCe9hWcRZJKkhaDP8)

</div>

<div id="setup" class="section level1">

# <span class="header-section-number">1</span> Configurar sesión de R

Para trabajar en R, hay tres primeros pasos que debemos seguir: (1)
cargar a los paquetes necesarios a la sesión actual, (2) configurar el
directorio de trabajo, (3) e importar datos de entrada a la sesión
actual.

En esta sección del tutorial, vamos a utilizar **15 paquetes de R** en
total:

> [**phyloseq**](https://joey711.github.io/phyloseq/index.html)
> 
> [**microbiome**](https://microbiome.github.io/tutorials/)
> 
> [**genefilter**](http://bioconductor.org/packages/release/bioc/html/genefilter.html)
> 
> [**SpiecEasi**](https://github.com/zdk123/SpiecEasi)
> 
> [**seqtime**](https://github.com/hallucigenia-sparsa/seqtime)
> 
> [**igraph**](https://igraph.org)
> 
> [**qgraph**](https://cran.r-project.org/web/packages/qgraph/index.html)
> 
> [**ggnet**](https://briatte.github.io/ggnet/)
> 
> [**RColorBrewer**](https://cran.r-project.org/web/packages/RColorBrewer/index.html)
> 
> [**tidyverse**](https://www.tidyverse.org)
> 
> [**grid**](https://www.rdocumentation.org/packages/grid/versions/3.6.1)
> 
> [**gridExtra**](https://cran.r-project.org/web/packages/gridExtra/index.html)
> 
> [**network**](https://cran.r-project.org/web/packages/network/index.html)
> 
> [**sna**](https://cran.r-project.org/web/packages/sna/index.html)
> 
> [**ggplot2**](https://ggplot2.tidyverse.org)

Los siguientes 3 *scripts* te mostrarán una manera eficiente de instalar
y cargar la lista de paquetes según su repositorio de origen, ya que
cada repositorio tiene su propia función para instalar sus paquetes.

  - Primero, enlistar los paquetes necesarios en diferentes vectores
    dependiendo de su repositorio de origen.

<div class="sourceCode">

``` sourceCode r
# Definir paquetes
# Repositorio CRAN
cran_packages <- c("bookdown", "knitr", "devtools", "igraph", "qgraph", "RColorBrewer", "tidyverse", "network", "sna", "grid", "gridExtra")
# Repositorio Bioconductor
bioc_packages <- c("phyloseq", "microbiome", "genefilter")
# Repositorio GitHub
git_source <- c("zdk123/SpiecEasi", "hallucigenia-sparsa/seqtime", "briatte/ggnet") # fuente/nombre del paquete
git_packages <- c("SpiecEasi", "seqtime", "ggnet") # nombre del paquete
```

</div>

  - Segundo, instalar los paquetes definidos arriba usando la función
    correspondiente a cada repositorio.

<div class="sourceCode">

``` sourceCode r
# Instalar paquetes CRAN
.inst <- cran_packages %in% installed.packages()
if(any(!.inst)) {
  install.packages(cran_packages[!.inst])
}
# Intalar paquetes BioConductor
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
.inst <- bioc_packages %in% installed.packages()
if(any(!.inst)) {
  BiocManager::install(bioc_packages[!.inst])
}
# Instalar paquetes GitHub
.inst <- git_source %in% installed.packages()
if(any(!.inst)) {
  devtools::install_github(git_source[!.inst])
}
```

</div>

  - Tercero, cargar los paquetes requeridos a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
sapply(c(cran_packages, bioc_packages, git_packages), require, character.only = TRUE)
```

</div>

El paso de instalación de paquetes es necesario solamente una vez.
Excepto si se quiere actualizar la versión del paquete, o bien, R ha
sido desinstalado e instalado nuevamente o actualizado su versión.

Si ya tienes los paquetes instalados en tu computadora, sólo necesitas
enlistar (*1er script*) y cargar (*3er script*) los paquetes. También,
puedes cargarlos a la sesión actual de R usando la función `library()`,
así:

<div class="sourceCode">

``` sourceCode r
# Cargar paquetes
library(phyloseq)
library(microbiome)
library(genefilter)
library(SpiecEasi)
library(seqtime)
library(igraph)
library(qgraph)
library(ggnet)
library(RColorBrewer)
library(tidyverse)
library(grid)
library(gridExtra)
library(network)
library(sna)
library(ggplot2)
```

</div>

</div>

<div id="comau" class="section level1">

# <span class="header-section-number">2</span> Datos de estudio

El último paso antes de comenzar, es cargar y pre-procesar los datos de
entrada. Para hacer análisis de redes de co-ocurrencia de
microorganismos, necesitamos el **perfil taxonómico y de abundancia de
cada microorganismo detectado en todas las muestras que incluye el
estudio**. Dependiendo si los datos fueron generados por secuenciación
de DNA total o de amplicones (*shotgun sequencing* o *amplicon
sequencing*, respectivamente), hay varios caminos hasta obtener el
análisis de composición microbiana.

A continuación, paso a describir brévemente el origen y procesamiento de
los datos a utilizar en esta sección del curso.

En este tutorial, vamos a trabajar 69 metagenomas producto de
secuenciación de tipo *shotgun* de muestras de agua colectadas en el
fiordo Comau ubicado en las costas de la Patagonia norte chilena, en la
Región de Los Lagos.

![](images/Chile_LosLagos.jpg)

> **Localización geográfica del fiordo Comau**

  

![](images/ComauFjord_1.jpg)

> **Fiordo Comau: vista desde camino al Cerro El Tambor**  
> **Fuente:
> [flickr.com/photos/lalo\_pangue](https://www.flickr.com/photos/lalo_pangue/39022579644/)**

  

En el fiordo Comau, las muestras fueron tomadas en 15 sitios diferentes,
desde dos profundidades (5 y 20 metros), y en 5 fechas incluyendo los
años 2016, 2017, y 2018.

![](images/Comau_SampleSites_map.jpg)

> **Sitios de toma de muestras en el fiordo Comau**

  

Las muestras de \~25 L de agua fueron filtradas usando filtros Sterivex
de 0.22 um para retener células procariontes. Desde los filtros se
extrajo DNA total y se prepararon librerías *paired-end* siguiendo la
guía de preparación de muestras TruSeq de Illumina. Finalmente, las 69
librerías de tipo *paired-end* fueron enviadas a Macrogen para ser
secuenciadas en la plataforma Illumina HiSeq 3000.

> Las *reads* o *raw data* junto con la *metadata* (i.e., datos
> ambientales tomados junto con las muestras) de los metagenomas marinos
> colectados en el fiordo Comau se encuentran disponibles en la base de
> datos [NCBI](https://www.ncbi.nlm.nih.gov) bajo los
> [BioProject](https://www.ncbi.nlm.nih.gov/bioproject/?term=)
> [PRJNA359936](https://www.ncbi.nlm.nih.gov/bioproject/?term=PRJNA359936)
> y [PRJNA517740](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA517740).

Las secuencias metagenómicas de las 69 muestras fueron pre-procesadas
para eliminar adaptadores, secuencias/bases de baja calidad (i.e.,
*quality score* \< 20), y secuencias cortas (i.e., largo \< 50 pb),
usando [PRINSEQ](http://prinseq.sourceforge.net/manual.html). En total,
2.7 mil millones de secuencias (después del control de calidad) fueron
utilizadas para los análisis de composición microbiana.

Para estimar la composición microbiana de cada muestra, primero las
*reads* fueron clasificadas usando
[Centrifuge](https://ccb.jhu.edu/software/centrifuge/manual.shtml) en
contra de una base de datos personalizada que incluye la base de datos
[GTDB (*Genome Taxonomy Database*)](https://gtdb.ecogenomic.org), los
genomas ensamblados desde metagenomas (MAGs) del [Tara Oceans (*global
oceans
expedition*)](http://www.taraoceans-dataportal.org/top/;jsessionid=EC107687CCD664C70F7C4AED1EFA9EF0?execution=e1s1),
y los genomas ensamblados desde metagenomas del mismo fiordo Comau.

> Para más información acerca de por qué utilizar una base de datos
> personalizada para clasificar las *reads* metagenómicas y como esta
> estrategía puede aumentar significativamente el porcentaje de
> secuencias clasificadas, y en consecuencia, su asignación taxonómica,
> especialmente en el caso de metagenomas ambientales:  
> **Guillaume Méric, Ryan R. Wick, Stephen C. Watts, Kathryn E. Holt,
> Michael Inouye**. 2019. [**Correcting index databases improves
> metagenomic
> studies**](https://www.biorxiv.org/content/10.1101/712166v1). bioRxiv,
> doi.org/10.1101/712166.

Finalmente, a partir de la clasificación de las secuencias de cada uno
de los 69 metagenomas del fiordo Comau, se generó el objeto
[phyloseq](https://joey711.github.io/phyloseq/) que contiene la
información de abundancia y perfil taxonómico de cada microorganismo
detectado en cada muestra, junto con la metadata (i.e., datos
ambientales) de cada una. Desde este punto en adelante, trabajamos el
análisis de composición microbiana y de redes de co-ocurrencia en R.

<div id="input" class="section level2">

## <span class="header-section-number">2.1</span> Datos de entrada

Para construir una red de co-ocurrencia de microorganismos, como mínimo
necesitamos una tabla de abundancia de todas las taxas identificadas en
cada una de las muestras (también conocida como *OTU table*), ya que
esta se utiliza para calcular la posible relación entre diferentes
microorganismos o taxas de acuerdo a su abundancia a través de las
muestras. Por lo tanto, el dato de entrada o *input* para construir una
red de co-ocurrencia puede ser tanto una *OTU table* o un objeto
phyloseq.

En este tutorial, el dato de entrada o *input* será el objeto phyloseq:
`comau69_3`

  - **Antes de cargar el objeto phyloseq** `comau69_3`**, DESCARGA EL
    *INPUT*** `comau69_3.RDS`
    [**AQUÍ**](https://www.dropbox.com/s/mu6no9rnmspka8q/comau69_3.RDS?dl=0)

  - Carga el objeto phyloseq a tu sesión de R actual, así:

<div class="sourceCode">

``` sourceCode r
# Cargar objeto phyloseq
comau69_3 <- readRDS(file = "comau69_3.RDS")
comau69_3 # overview
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 650 taxa and 69 samples ]
    ## sample_data() Sample Data:       [ 69 samples by 23 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 650 taxa by 7 taxonomic ranks ]

![](images/important.png) **IMPORTANTE**: El objeto phyloseq `comau69_3`
ya se encuentra **procesado** y esta listo para inferir la red de
co-ocurrencia de microorganismos del fiordo Comau.

![](images/question.png) ¿A qué nos referimos con **procesado**? Antes
de inferir redes de co-ocurrencia, se recomienda aglomerar la taxonomía
por el *best hit* y filtrar por prevalencia (ver abajo en
“Pre-procesamiento” para más detalle). Con el fin de reducir la
heterogeneidad de las muestras, lo que según estudios basados en datos
simulados, mejora la precisión de la red.

Si no estás interesado en conocer los pasos de pre-procesamiento (i.e.,
*aglomerar y filtrar*) de los datos de estudio hasta obtener el objeto
`comau69_3`, puedes saltar los pasos a continuación y seguir con el
cálculo de la red en la **sección [3](#network)**.

De lo contrario, puedes cargar el objeto phyloseq inicial `comau69_1` y
seguir los pasos de pre-procesamiento.

  - **Antes de cargar el objeto phyloseq** `comau69_1`**, DESCARGA EL
    *INPUT*** `comau69_1.RDS`
    [**AQUÍ**](https://www.dropbox.com/s/33j9t5pllw58ar4/comau69_1.RDS?dl=0)

  - Carga el objeto phyloseq a tu sesión de R actual, así:

<div class="sourceCode">

``` sourceCode r
# Leer objeto phyloseq
comau69_1 <- readRDS(file = "comau69_1.RDS")
comau69_1 # overview
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 25361 taxa and 69 samples ]
    ## sample_data() Sample Data:       [ 69 samples by 23 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 25361 taxa by 7 taxonomic ranks ]

<div id="pre-procesamiento" class="section level3">

### <span class="header-section-number">2.1.1</span> Pre-procesamiento

<div id="aglomerar-por-best-hit" class="section level4">

#### <span class="header-section-number">2.1.1.1</span> Aglomerar por *best hit*

Aglomerar por el *best hit* se refiere a que el proceso de aglomeración
se hará según el linaje completo y no por un rango taxonómico en
particular.

Para ello, primero utilizaremos la función `format_to_besthit()` del
paquete
[microbiomeutilities](https://microsud.github.io/microbiomeutilities/)
sobre el objeto phyloseq `comau69_1`, para agregar a la tabla de
taxonomía el último rango alcanzado en la clasificación taxonómica de
cada taxa (*best hit*). Seguidamente, usamos la función `tax_glom` del
paquete phyloseq para aglomerar según la octava columna, que contiene el
último rango taxonómico alcanzado.

  - Así:

<div class="sourceCode">

``` sourceCode r
# Agregar la mejor taxonomía en el objeto phyloseq
comau69_2 <- microbiomeutilities::format_to_besthit(comau69_1)
comau69_2 #overview

# La función 'format_to_besthit()' hace varias modificaciones en el objeto phyloseq, que por conveniencia vamos a revertir: 
# Nombre de las taxas o filas de la tabla de taxonomía (tax table)
rownames(comau69_2@tax_table@.Data) <- rownames(comau69_1@tax_table@.Data)
# Nombre de las taxas o filas de la tabla de abundancia (otu table)
rownames(comau69_2@otu_table@.Data) <- rownames(comau69_1@otu_table@.Data)
# Remover la columna extra creada por 'format_to_besthit()' en la tax table
tax_table(comau69_2) <- tax_table(comau69_2)[,1:7]
# Reemplazar el título de la columna "Domain" por "Kingdom" en la tax table
colnames(comau69_2@tax_table@.Data) <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")

# Mira como quedó la tabla de taxonomía en el objeto phyloseq
View(comau69_2@tax_table@.Data)

# Aglomerar por el best hit, usando el último rango taxonómico: "Species"
comau69_2 <- tax_glom(comau69_2, "Species", NArm = FALSE)
comau69_2 #overview
```

</div>

![](images/important.png) Ambos pasos, calcular el *best hit* y
aglomerar, pueden tomar varios minutos o incluso unas pocas horas. Para
ahorrar una espera innecesaria y seguir avanzando en el tutorial,
descarga el objeto phyloseq `comau69_2`
[**AQUÍ**](https://www.dropbox.com/s/wcz49uy72xo0e6i/comau69_2.RDS?dl=0)

  - Carga el objeto phyloseq a tu sesión de R actual, así:

<div class="sourceCode">

``` sourceCode r
# Cargar objeto phyloseq
comau69_2 <- readRDS(file = "comau69_2.RDS")
comau69_2 #overview
```

</div>

    ## phyloseq-class experiment-level object
    ## otu_table()   OTU Table:         [ 24218 taxa and 69 samples ]
    ## sample_data() Sample Data:       [ 69 samples by 23 sample variables ]
    ## tax_table()   Taxonomy Table:    [ 24218 taxa by 7 taxonomic ranks ]

</div>

<div id="filtrar" class="section level4">

#### <span class="header-section-number">2.1.1.2</span> Filtrar

El filtro por prevalencia reduce el número de taxas eliminando aquellas
que tengan 0 cuentas (*read count*) en un porcentaje del número total de
muestras definido por el valor de prevalencia.

Como se explica en el *review* de Lisa Rottjers y Karoline Faust: [From
hairballs to hypotheses–biological insights from microbial
networks](https://academic.oup.com/femsre/article/42/6/761/5061627). No
somos capaces de discriminar si los valores igual a cero en la tabla de
abundancia (*otu table*) representan la ausencia de la taxa o un
muestreo insuficiente.

![](images/question.png) ¿Qué valor de prevalencia usar? No hay una guía
o valor definido aún, pero en el review mencionado arriba de Lisa
Rottjers y Karoline Faust, recomiendan definir el valor de prevalencia
apuntando a un equilibrio entre: evitar asociaciones erradas y conservar
potenciales especies importantes. Por lo tanto, depende de los datos de
estudio y/o de la pregunta biológica.

Por ejemplo, en el caso de los datos que trabajamos en este tutorial:
Estamos interesados en observar las taxas de baja abundancia (*rare
taxa*), ya que creemos podrían tener un rol importante en la comunidad
microbiana del fiordo. Entonces, previamente experimentamos haciendo
filtros por prevalencia y por abundancia relativa. En seguida
descubrimos que al filtrar por abundancia relativa, todas las taxas que
pasaron el criteri de filtro presentaban una alta prevalencia.
Finalmente, elegimos este criterio de filtro porque nos permite
conservar las taxas de baja abundancia manteniendo altos los valores de
prevalencia.

  - Filtrar taxas por abundancia relativa:
      - Primero, usamos la función `transform_sample_counts()` para
        calcular los valores de abundancia relativa (número de *reads*
        clasificados dividido por el número total de *reads*).
      - Segundo, usamos la función
        [`kOverA()`](https://www.rdocumentation.org/packages/genefilter/versions/1.54.2/topics/kOverA)
        del paquete genefilter para definir el criterio de filtro:  
        conservar aquellas taxas con una abundancia relativa mayor a
        0.05% en al menos 1 de las 69 muestras
      - Tercero, usamos la función `prune_taxa()` para filtrar el objeto
        phyloseq.

<div class="sourceCode">

``` sourceCode r
# Transformar los valores de cuentas (otu table) a valores de abundancia relativa en el objeto phyloseq
comau69_2ra <- transform_sample_counts(comau69_2, function(x) x / sum(x))

# Definir criterio de filtro usando la función 'kOverA(k, A)'
# k = número de muestras; A = vaor de abundancia
# k = 1; A = 0.0005
flist <- filterfun(kOverA(1, 0.0005))
# Filtrar taxas
# Crear objeto que clasifica como TRUE a aquellas taxas que pasaron el criterio de filtro 
comau69_2raf <- filter_taxa(comau69_2ra, flist)
# Filtrar el objeto phyloseq
comau69_3 <- prune_taxa(comau69_2raf, comau69_2)
comau69_3 #overview
```

</div>

<div class="sourceCode">

``` sourceCode r
# Mira la tabla de abundancia
View(comau69_3@otu_table@.Data)
```

</div>

|           | AUG2018\_L1S1D05 | AUG2018\_L1S1D20 | AUG2018\_L1S2D05 | AUG2018\_L1S2D20 | AUG2018\_L1S3D05 | AUG2018\_L1S3D20 | AUG2018\_L3S1D05 | AUG2018\_L3S1D20 | AUG2018\_L3S2D05 | AUG2018\_L3S2D20 | AUG2018\_L3S3D05 | AUG2018\_L3S3D20 | AUG2018\_L4S1D05 | AUG2018\_L4S1D20 | AUG2018\_L4S2D05 | AUG2018\_L4S2D20 | AUG2018\_L4S3D05 | AUG2018\_L4S3D20 | AUG2018\_L5S1D05 | AUG2018\_L5S1D20 | AUG2018\_L5S2D05 | AUG2018\_L5S2D20 | AUG2018\_L5S3D05 | AUG2018\_L5S3D20 | BacS1 | BacS2 |  BacS3 | DEC2017\_L1S1D05 | DEC2017\_L1S1D20 | DEC2017\_L1S2D05 | DEC2017\_L1S3D05 | DEC2017\_L1S3D20 | DEC2017\_L3S1D05 | DEC2017\_L3S1D20 | DEC2017\_L3S3D05 | DEC2017\_L3S3D20 | DEC2017\_L4S1D05 | DEC2017\_L4S1D20 | DEC2017\_L4S2D05 | DEC2017\_L4S2D20 | DEC2017\_L4S3D05 | DEC2017\_L4S3D20 | DEC2017\_L5S1D05 | DEC2017\_L5S1D20 | DEC2017\_L5S2D05 | DEC2017\_L5S2D20 | DEC2017\_L5S3D05 | DEC2017\_L5S3D20 | JAN2018\_L3S2D05 | JAN2018\_L3S2D20 | JUN2017\_L1S1D05 | JUN2017\_L1S2D05 | JUN2017\_L1S2D20 | JUN2017\_L1S3D05 | JUN2017\_L1S3D20 | JUN2017\_L3S1D20 | JUN2017\_L3S2D05 | JUN2017\_L3S2D20 | JUN2017\_L4S1D05 | JUN2017\_L4S1D20 | JUN2017\_L4S2D05 | JUN2017\_L4S2D20 | JUN2017\_L4S3D05 | JUN2017\_L4S3D20 | JUN2017\_L5S1D05 | JUN2017\_L5S1D20 | JUN2017\_L5S2D05 | JUN2017\_L5S2D20 | JUN2017\_L5S3D05 |
| --------- | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ----: | ----: | -----: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: | ---------------: |
| TI\_27683 |          2132914 |           446684 |          1828370 |           734858 |          2002908 |           481932 |           344432 |            34090 |           593656 |            30588 |           754466 |            39859 |           657003 |            92631 |          1108959 |           517165 |          1411538 |           228912 |           392922 |           431466 |          1752318 |           569986 |          1026325 |           249799 | 62043 | 55477 | 169719 |           859509 |           899814 |          1488533 |          2356204 |          1842909 |          1686912 |           719965 |           802211 |          1174158 |          2064040 |           668016 |           561522 |           784329 |           217988 |           262094 |          1300809 |           557228 |           770428 |           432943 |           591262 |           160154 |           357727 |            38925 |           104981 |           104914 |            24947 |            88872 |            46080 |             3126 |           216776 |             6650 |           145223 |            26183 |           116443 |            31726 |            74114 |            20554 |            71942 |            22783 |           138095 |            32185 |            58110 |
| TI\_39035 |              977 |            10787 |              922 |             4144 |             1227 |             3579 |              256 |            11418 |              409 |            10795 |              358 |            16686 |              764 |             1333 |             1422 |             7124 |             1742 |             3171 |              418 |             2214 |             1134 |             7171 |             2766 |             6847 |    97 |   102 |    108 |            19951 |             1664 |             1191 |             3103 |             3134 |             1688 |             1522 |             1506 |              290 |              537 |             3020 |             8097 |             2110 |             6464 |             2558 |              633 |             1237 |              409 |             6408 |              560 |              338 |             1197 |            22969 |            20645 |            19193 |            14628 |            12961 |            14597 |             8239 |             7196 |            11890 |            27096 |            12297 |            25549 |            13062 |            17103 |            13099 |            21582 |            13793 |            23239 |            16852 |            20818 |
| TI\_27681 |              129 |              924 |              119 |              399 |              225 |              398 |               66 |              861 |              124 |              924 |               93 |             1379 |              131 |              144 |              187 |              691 |              213 |              340 |               59 |              268 |              201 |              836 |              306 |              776 |    26 |    38 |     43 |             2079 |              337 |              415 |              413 |              407 |              449 |              291 |              380 |              103 |              116 |              439 |              969 |              385 |              715 |              536 |              150 |              251 |              158 |              776 |              215 |               88 |              218 |             1605 |             2367 |             1940 |             1902 |             2067 |             1721 |             1541 |              769 |             1441 |             3090 |             1711 |             2588 |             1880 |             1902 |             1937 |             2941 |             1850 |             2734 |             4487 |             3100 |
| TI\_13593 |          1308850 |          3365486 |          1022844 |          3040117 |          1482830 |          1519207 |           181828 |            86186 |          1081413 |           161198 |           163905 |           131914 |          1481758 |           355686 |           680570 |          1069106 |           628357 |           534329 |           563609 |           443793 |           382266 |          1069965 |           600898 |           492585 | 13185 |  7373 |   3118 |          2683197 |          7798839 |          1319276 |           813638 |          5579080 |          4740967 |          4354461 |          2895557 |            57235 |            22516 |          2663175 |          1013002 |          1360649 |           662193 |          1023236 |          1110980 |          1726956 |           325612 |           870570 |          1062262 |           612162 |          2105090 |           215064 |            84480 |            83334 |            43519 |            63473 |            53791 |            10913 |            31560 |            17519 |           144717 |            48971 |           113167 |            49273 |            85574 |            40743 |            91391 |            43532 |           150608 |            70097 |            91030 |
| TI\_13597 |            66037 |           162935 |            51765 |           145039 |            76116 |            77887 |            10286 |             6393 |            49574 |            11305 |            10898 |             9940 |            63831 |            16313 |            37926 |            55858 |            34506 |            25550 |            25168 |            23760 |            25269 |            54498 |            29336 |            24772 |  6891 |  5184 |   5519 |           132432 |           332103 |           126603 |            52765 |           246777 |           235951 |           192132 |           150925 |            11465 |            11240 |           124679 |            56481 |            71910 |            35922 |            55909 |            60453 |            75991 |            22596 |            48159 |            73717 |            35187 |            97733 |            18158 |             9266 |             8140 |             5917 |             6710 |             6161 |             3041 |             3739 |             3478 |            15342 |             6228 |            11461 |             5866 |             8997 |             5711 |            10770 |             5313 |            13402 |            10428 |            10334 |
| TI\_20829 |           393029 |           172057 |           360412 |           303746 |           420787 |           188589 |            75319 |            25570 |           156945 |            18705 |           104920 |            24515 |           167470 |            38208 |           326174 |           258648 |           362785 |            89202 |            72003 |            98090 |           249539 |           142447 |           160137 |            51917 |  6799 |  8382 |  19167 |           180635 |           458225 |           478760 |           271704 |          1150808 |           891532 |           470387 |           362761 |            40185 |            52298 |           435196 |            98043 |           478134 |            64956 |           170954 |           293849 |           230265 |           151000 |           146600 |           218217 |            96803 |           153469 |            92346 |            19579 |            16178 |            13214 |            13754 |            13417 |             8175 |            36433 |            13855 |            22660 |             8457 |            24152 |             9814 |            14531 |            10117 |            19200 |             9753 |            23875 |            12439 |            19371 |
| TI\_20846 |            32501 |            77289 |            28404 |            89361 |            40890 |            74012 |             9592 |            18632 |            10981 |            12355 |            10560 |            23748 |            49911 |            31150 |            68516 |           179372 |            98469 |            57929 |            15858 |            38460 |            78282 |            67337 |            44081 |            40673 |   431 |   358 |   1111 |            17727 |            10963 |             6605 |             4741 |            23519 |             9486 |            20837 |            17086 |             2556 |             2695 |            65654 |             9647 |            95531 |             5151 |            95651 |             3756 |            19587 |             4146 |            29780 |             3654 |             4469 |            15533 |            78958 |            25553 |            21644 |            19047 |            19444 |            20417 |            11679 |            42075 |            21320 |            22757 |            10585 |            26599 |            12592 |            18414 |            15669 |            24264 |            12581 |            22955 |            18478 |            25749 |
| TI\_20835 |             2434 |             3772 |             2009 |             4265 |             2720 |             3480 |              905 |             1102 |              789 |              677 |             1165 |             1315 |             2457 |             1464 |             3260 |             8527 |             4818 |             2763 |              806 |             1825 |             4258 |             3308 |             2530 |             1856 |    71 |    66 |    180 |             1595 |             1358 |             1132 |             1380 |             2329 |             1567 |             1689 |             1636 |              665 |             1162 |             3909 |              845 |             5205 |              405 |             4688 |              792 |             1445 |              511 |             1937 |              501 |              350 |             1221 |             3855 |             1213 |             1008 |              825 |              888 |              983 |              522 |             2027 |             1043 |             1168 |              444 |             1235 |              574 |              885 |              731 |             1098 |              616 |             1127 |              721 |             1169 |
| TI\_38896 |            13288 |            37930 |            11716 |            18187 |            15047 |            18470 |             2058 |            36028 |             3334 |            24654 |             5109 |            36952 |             4299 |             4942 |             8637 |            23567 |            11472 |            12168 |             2511 |             6054 |            11161 |            16002 |             9700 |            12136 |   682 |   720 |    687 |           103719 |             8010 |            11988 |            20221 |            20594 |            14160 |             7664 |             8665 |             2679 |             3638 |            16592 |            41688 |            11112 |            29969 |            14304 |             5103 |             6285 |             3124 |            19591 |             4680 |             2180 |             5879 |            86420 |            24916 |            20712 |            19409 |            14991 |            19921 |            12390 |            14697 |            21997 |            46691 |            17502 |            27861 |            18391 |            21256 |            17486 |            25921 |            17560 |            30822 |            30402 |            28667 |
| TI\_20841 |              426 |             6518 |              351 |             2822 |              626 |             3182 |               84 |             3744 |               81 |             3856 |               84 |             7114 |              600 |             1022 |              987 |             3706 |              990 |             2376 |              374 |             2429 |              662 |             6623 |             1921 |             5996 |   287 |   364 |    137 |            55400 |              439 |              646 |             7131 |             3261 |              815 |              793 |              709 |               69 |               94 |             2968 |            20731 |              959 |            18700 |             2160 |              386 |              742 |              152 |            12453 |              547 |              337 |              897 |            13131 |            23237 |            18677 |            13156 |            13275 |            16616 |             6993 |             8419 |            14186 |            24178 |            16217 |            24395 |            14474 |            19045 |            12208 |            25795 |            13718 |            27605 |            21907 |            24301 |

  - Puedes descargar el objeto phyloseq `comau69_3`
    [**AQUÍ**](https://www.dropbox.com/s/mu6no9rnmspka8q/comau69_3.RDS?dl=0)
    y cargarlo a la sesión de R actual.

<div class="sourceCode">

``` sourceCode r
# Leer objeto phyloseq
comau69_3 <- readRDS(file = "comau69_3.RDS")
comau69_3 # overview
```

</div>

    phyloseq-class experiment-level object
    otu_table()   OTU Table:         [ 650 taxa and 69 samples ]
    sample_data() Sample Data:       [ 69 samples by 23 sample variables ]
    tax_table()   Taxonomy Table:    [ 650 taxa by 7 taxonomic ranks ]

</div>

</div>

</div>

<div id="perfil-taxonomico" class="section level2">

## <span class="header-section-number">2.2</span> Perfil taxonómico

Puede ser muy útil tener una tabla de datos disponible para consultar
durante el análisis.

  - Vamos a usar la función
    [`psmelt`](https://www.rdocumentation.org/packages/phyloseq/versions/1.16.2/topics/psmelt)
    para tabular la información contenida en el objeto phyloseq
    `comau69_3`

<div class="sourceCode">

``` sourceCode r
# Extraer y tabular los datos en comau69_3
taxotutable <- phyloseq::psmelt(comau69_3)
# Editar tabla
colnames(taxotutable) <- c("TaxID", "Sample", "Abundance", 
                           "sample_ID", "sample_date", "sample_name", "line", "site", "line_site", "depth_m", "latitude", "longitude", "lat_lon", "temperature_C", "light_lux", "pH", "salinity_PSU", "chlorophyll_A_ugL", "C_total_ug", "N_total_ug", "C_N", "nitrate_nitrite_uM", "nitrate_uM", "nitrite_uM", "phosphate_uM", "silicate_uM", 
                           "Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species")

# Exportar/guardar tabla
write.table(taxotutable, file = "SummarizedTaxAssigments_comau69_3.tsv", sep = "\t", quote = FALSE)
```

</div>

  - También, puedes descargar la tabla
    `SummarizedTaxAssigments_comau69_3.tsv`
    [**AQUÍ**](https://www.dropbox.com/s/ff8ziga3lhinu5b/SummarizedTaxAssigments_comau69_3.tsv?dl=0)
    y cargarla a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Leer y guardar tabla en objeto 'taxotutable'
taxotutable <- read.table(file = "SummarizedTaxAssigments_comau69_3.tsv", sep = "\t", header = TRUE)
```

</div>

  - Usa la función `View()` para visualizar la tabla de datos
    `taxotutable` en RStudio.

<div class="sourceCode">

``` sourceCode r
# Leer y guardar tabla en objeto 'taxotutable'
taxotutable <- read.table(file = "SummarizedTaxAssigments_comau69_3.tsv", sep = "\t", header = TRUE)
```

</div>

| TaxID     | Sample           | Abundance | sample\_ID       | sample\_date | sample\_name | line | site | line\_site | depth\_m |   latitude |  longitude | lat\_lon              | temperature\_C | light\_lux |   pH | salinity\_PSU | chlorophyll\_A\_ugL | C\_total\_ug | N\_total\_ug |    C\_N | nitrate\_nitrite\_uM | nitrate\_uM | nitrite\_uM | phosphate\_uM | silicate\_uM | Kingdom  | Phylum         | Class               | Order            | Family              | Genus          | Species          |
| :-------- | :--------------- | --------: | :--------------- | :----------- | :----------- | :--- | :--- | :--------- | -------: | ---------: | ---------: | :-------------------- | -------------: | ---------: | ---: | ------------: | ------------------: | -----------: | -----------: | ------: | -------------------: | ----------: | ----------: | ------------: | -----------: | :------- | :------------- | :------------------ | :--------------- | :------------------ | :------------- | :--------------- |
| TI\_13593 | DEC2017\_L1S1D20 |   7798839 | DEC2017\_L1S1D20 | DEC2017      | L1S1D20      | L1   | S1   | L1S1       |       20 | \-42.47733 | \-72.43112 | 42.47733 S 2.43112 W  |          12.87 |     75.330 | 8.27 |         32.18 |              0.1455 |      55.2030 |       6.5863 |  8.3815 |               0.8000 |      0.8000 |      0.0000 |        0.8800 |       2.0000 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Amylibacter\_A | sp000153745      |
| TI\_13593 | DEC2017\_L1S3D20 |   5579080 | DEC2017\_L1S3D20 | DEC2017      | L1S3D20      | L1   | S3   | L1S3       |       20 | \-42.47310 | \-72.40573 | 42.4731 S 2.40573 W   |          13.48 |         NA | 8.33 |         32.08 |              0.9275 |      58.2057 |       6.3085 |  9.2266 |               0.6000 |      0.6000 |      0.0000 |        0.6300 |       1.0000 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Amylibacter\_A | sp000153745      |
| TI\_26133 | DEC2017\_L1S1D20 |   4968562 | DEC2017\_L1S1D20 | DEC2017      | L1S1D20      | L1   | S1   | L1S1       |       20 | \-42.47733 | \-72.43112 | 42.47733 S 2.43112 W  |          12.87 |     75.330 | 8.27 |         32.18 |              0.1455 |      55.2030 |       6.5863 |  8.3815 |               0.8000 |      0.8000 |      0.0000 |        0.8800 |       2.0000 | Bacteria | Proteobacteria | Gammaproteobacteria | Pseudomonadales  | Pseudohongiellaceae | OM182          | sp001438145      |
| TI\_13593 | DEC2017\_L3S1D05 |   4740967 | DEC2017\_L3S1D05 | DEC2017      | L3S1D05      | L3   | S1   | L3S1       |        5 | \-42.38636 | \-72.45599 | 42.38636 S 2.45599 W  |          15.02 |    403.625 | 8.54 |         32.72 |              0.3819 |      56.0702 |       6.4933 |  8.6351 |               0.0000 |      0.0000 |      0.0100 |        0.4500 |       1.0000 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Amylibacter\_A | sp000153745      |
| TI\_39096 | AUG2018\_L3S3D05 |   4557864 | AUG2018\_L3S3D05 | AUG2018      | L3S3D05      | L3   | S3   | L3S3       |        5 | \-42.37470 | \-72.43074 | 42.3747 S 72.43074 W  |          10.44 |     53.800 | 8.09 |         30.16 |                  NA |           NA |           NA |      NA |              12.7048 |     12.5244 |      0.1804 |        1.2357 |       2.6795 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Tateyamaria    | g\_\_Tateyamaria |
| TI\_13593 | DEC2017\_L3S1D20 |   4354461 | DEC2017\_L3S1D20 | DEC2017      | L3S1D20      | L3   | S1   | L3S1       |       20 | \-42.38636 | \-72.45599 | 42.38636 S 2.45599 W  |          12.83 |     43.050 | 8.04 |         34.06 |              0.2364 |      41.5871 |       2.4199 | 17.1856 |               0.9000 |      0.9000 |      0.0000 |        0.9200 |       0.0000 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Amylibacter\_A | sp000153745      |
| TI\_26133 | DEC2017\_L3S1D05 |   3706850 | DEC2017\_L3S1D05 | DEC2017      | L3S1D05      | L3   | S1   | L3S1       |        5 | \-42.38636 | \-72.45599 | 42.38636 S 2.45599 W  |          15.02 |    403.625 | 8.54 |         32.72 |              0.3819 |      56.0702 |       6.4933 |  8.6351 |               0.0000 |      0.0000 |      0.0100 |        0.4500 |       1.0000 | Bacteria | Proteobacteria | Gammaproteobacteria | Pseudomonadales  | Pseudohongiellaceae | OM182          | sp001438145      |
| TI\_27699 | AUG2018\_L3S3D05 |   3466513 | AUG2018\_L3S3D05 | AUG2018      | L3S3D05      | L3   | S3   | L3S3       |        5 | \-42.37470 | \-72.43074 | 42.3747 S 72.43074 W  |          10.44 |     53.800 | 8.09 |         30.16 |                  NA |           NA |           NA |      NA |              12.7048 |     12.5244 |      0.1804 |        1.2357 |       2.6795 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Planktotalea   | sp000156115      |
| TI\_13593 | AUG2018\_L1S1D20 |   3365486 | AUG2018\_L1S1D20 | AUG2018      | L1S1D20      | L1   | S1   | L1S1       |       20 | \-42.47733 | \-72.43112 | 42.47733 S 72.43112 W |          10.88 |         NA | 7.79 |         29.82 |                  NA |           NA |           NA |      NA |              22.1702 |     21.7523 |      0.4179 |        2.2719 |       9.7044 | Bacteria | Proteobacteria | Alphaproteobacteria | Rhodobacterales  | Rhodobacteraceae    | Amylibacter\_A | sp000153745      |
| TI\_23044 | DEC2017\_L3S3D20 |   3323790 | DEC2017\_L3S3D20 | DEC2017      | L3S3D20      | L3   | S3   | L3S3       |       20 | \-42.37470 | \-72.43074 | 42.3747 S 2.43074 W   |          12.62 |      0.000 | 8.38 |         34.69 |              0.4001 |      47.7105 |       4.1446 | 11.5115 |               0.9000 |      0.9000 |      0.0000 |        0.8900 |       0.0000 | Bacteria | Bacteroidota   | Bacteroidia         | Flavobacteriales | Flavobacteriaceae   | MAG-120531     | sp000173115      |

</div>

</div>

<div id="network" class="section level1">

# <span class="header-section-number">3</span> Redes de co-ocurrencia microbiana

Las as redes de co-ocurrencia nos permiten estudiar la comunidad
microbiana más allá de solamente su composición: detección de *keystone
species*, entender mejor la dinámica de la comunidad microbiana, y
analizar efecto de factores abióticos sobre la comunidad microbiana.

![](images/network.png) En este tutorial, vamos a calcular la red,
conocer sus características **[4](#features)**, calcular estadística
(*degree*, *centrality*, *transitivity*) **[5](#stats)**, estructura de
la red (detección y extracción de módulos/*clusters*)
**[6](#structure)**, y búsqueda de *keystone species*
**[7](#keystone)**.

![](images/domain.png) Este tutorial se basa fuertemente en el trabajo
de otros investigadores publicado en:

> Zachary Kurtz.
> [**github.com/zdk123/SpiecEasi**](https://github.com/zdk123/SpiecEasi#working-with-phyloseq)
> 
> Mehdi Layeghifard, David M. Hwang, and David S. Guttman. 2018.
> [**Constructing and Analyzing Microbiome Networks in
> R**](https://link.springer.com/protocol/10.1007%2F978-1-4939-8728-3_16).
> Microbiome Analysis, Methods and Protocols.
> doi.org/10.1007/978-1-4939-8728-3\_16
> 
> Karoline Faust. [**Microbial association network construction
> tutorial**](http://psbweb05.psb.ugent.be/conet/microbialnetworks/spieceasi.php)
> 
> [**ggnet2: network visualization with
> ggplot2**](https://briatte.github.io/ggnet/)
> 
> [**ggnetwork: network geometries for
> ggplot2**](https://briatte.github.io/ggnetwork/)
> 
> Katherine Ognyanova. [**Network visualization with
> R**](https://kateto.net/network-visualization)

<div id="spiec-easi" class="section level2">

## <span class="header-section-number">3.1</span> SPIEC-EASI

**SPIEC-EASI** (**SP**arse **I**nvers**E** **C**ovariance estimation for
**E**cological **A**ssociation **I**nference) es un método estadístico
para la inferencia de redes basado en la covariancia inversa entre las
taxas según sus valores de abundancia a través de las muestras. Para
conocer más acerca de SPIEC-EASI, revisa el siguiente artículo:

> Zachary D. Kurtz, Christian L. Müller, Emily R. Miraldi, Dan R.
> Littman, Martin J. Blaser, Richard A. Bonneau. 2015. [**Sparse and
> Compositionally Robust Inference of Microbial Ecological
> Networks**](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1004226).
> PLoS Computational Biology. doi.org/10.1371/journal.pcbi.1004226

  - Usamos la función `spiec.easi()` para inferir la red a partir del
    objeto phyloseq `comau69_3` y la guardamos en el objeto `se_mb`

![](images/important.png) **No necesitas normalizar la tabla de
abundancia (*otu table*)**, por ejemplo, transformando los valores de
cuentas a abundancia relativa. SPIEC-EASI se encarga de esto
transformando los valores de cuentas (i.e., número de secuencias
clasificadas) mediante el cálculo del *centered log-ratio* (CLR).

`se_mb` contiene una matriz llamada “*refit*”, la cual es una matriz de
[adyacencia](https://en.wikipedia.org/wiki/Adjacency_matrix)
[dispersa](https://en.wikipedia.org/wiki/Sparse_matrix) (*sparse
adjacency matrix*).

<div class="sourceCode">

``` sourceCode r
# Inferir la red usando SpiecEasi a partir de 'comau69_3'
# SpiecEasi cuenta con dos modelos de inferencia, que se definen con el argumento 'method': neighborhood selection ('mb') and inverse covariance selection ('glasso')
# Aquí, usamos method='mb' porque es mucho más rápido
# Úsa el argumento 'ncores' para indicar el número de procesadores disponible (si tienes más de uno)
se_mb <- spiec.easi(comau69_3, method='mb', 
                    lambda.min.ratio=1e-2, nlambda=20, 
                    pulsar.params=list(rep.num=50, ncores=3))

# Puedes exportar/guardar el objeto 'se_mb'
saveRDS(se_mb, "se_mb.RDS")
```

</div>

  - También, puedes descargar el objeto `se_mb`
    [**AQUÍ**](https://www.dropbox.com/s/vrt1viu3hnwop11/se_mb.RDS?dl=0)
    y cargarlo a la sesión actual de R.

<div class="sourceCode">

``` sourceCode r
# Read network
se_mb <- readRDS(file = "se_mb.RDS")
```

</div>

  - Usamos las funciones `getRefit()` y `adj2igraph()` del paquete
    SpiecEasi, para extraer la matriz *refit* del objeto `se_mb` y
    construir la red microbiana a partir de ella, respectivamente.

<div class="sourceCode">

``` sourceCode r
# Construir red a partir de la 'sparse adjacency matrix' o 'refit matrix'
# Add OTU names to rows and columns
# Create igraph objects
se_net <- adj2igraph(getRefit(se_mb), 
                     rmEmptyNodes = TRUE, diag = FALSE, 
                     vertex.attr = list(name = taxa_names(comau69_3))) # Usamos el ID de las taxas para nombrar los vértices o nodos de la red
```

</div>

  - El paquete phyloseq incluye la función `plot_network()` para
    visualizar la red.

<div class="sourceCode">

``` sourceCode r
# Graficar la red 'se_net'
plot_network(se_net, comau69_3, type = "taxa", color = "Phylum", shape = "Kingdom", label = NULL)
```

</div>

![](images/Phy_plot_network_1.jpg)

</div>

<div id="ggnet2" class="section level2">

## <span class="header-section-number">3.2</span> ggnet2

La función de phyloseq que usamos arriba para graficar la red, se basa
en la función `ggnet2` de `ggplot2` para la visualización de redes en R.
En este tutorial, vamos a usar **ggnet2** porque consideramos más
conveniente y fácil contar con la versatilidad y funciones de ggplot2
para visualizar y analizar la red.

  - Para usar `ggnet2` necesitamos un objeto de clase ‘network’ como
    *input*, el que obtenemos partir de la matriz de adyacencia de la
    red.

<div class="sourceCode">

``` sourceCode r
# Extraer matriz de adyacencia
net_class <- as_adjacency_matrix(se_net, type = "both")
# Generar objeto de clase 'network'
net_class <- network(as.matrix(net_class), 
                     vertex.attrnames = taxa_names(comau69_3), 
                     matrix.type = "adjacency", directed = F)
```

</div>

  - Visualizamos la red usando `ggnet2`

<div class="sourceCode">

``` sourceCode r
ggnet2(net_class)
```

</div>

![](images/ggnet2_network_1.jpg)

Seguramente notaste que no hay mucho que podamos deducir de esta
visualización. Esto es porque la red representa las posibles relaciones
entre todos los microorganismos detectados y clasificados en las
muestras que componen el estudio. **Inferir y graficar la red no es
suficiente sino que solo el comienzo**, lo que sigue es analizar las
características y componentes de la red para estudiar hipótesis que
busquen responder preguntas con respecto la comunidad microbiana.

</div>

</div>

<div id="features" class="section level1">

# <span class="header-section-number">4</span> Características de la red

En esta sección vamos a evaluar y visualizar las características de la
red.

  - Primero, vamos a crear una copia de la red, para poder volver atrás
    sin problema.

<div class="sourceCode">

``` sourceCode r
# Copiar el objeto 'se_net' a 'net'
net <- se_net
```

</div>

  - Características básicas de una red: **vértices o nodos (*nodes or
    vertex*), bordes (*edges*), nombre de los nodos, y número total de
    nodos y bordes**.

<div class="sourceCode">

``` sourceCode r
nodes <- V(net) # Nodos
edges <- E(net) # Bordes
node.names <- V(net)$name # Nombre de nodos
num.nodes <- vcount(net) # Número total de nodos
num.edges <- ecount(net) # Número total de bordes
# V() es por vértices o nodos
# E() es por edges
```

</div>

En una red de co-ocurrencia microbiana; los nodos representan una taxa y
los bordes o *edges* representan una relación entre las dos taxas que
conecta.

![](images/network_2.jpg)

<div id="relaciones-de-co-ocurrencia-positiva-y-negativa" class="section level2">

## <span class="header-section-number">4.1</span> Relaciones de co-ocurrencia positiva y negativa

La correlación entre dos taxas puede ser positiva o negativa:  
**Positiva**: indica una relación directa o indirecta entre ambas
taxas.  
**Negativa**: indica una interacción competitiva o que las taxas no
comparten nicho (*non-overlapping niches*).

  - Cuántos *edges* positivos y negativos fueron inferidos por
    SpiecEasi.

<div class="sourceCode">

``` sourceCode r
# Extraer los coeficientes de regresión del objeto 'se_mb'
betaMat <- as.matrix(symBeta(getOptBeta(se_mb)))

# Calcular el número de edges positivos y negativos en la red
positive <- length(betaMat[betaMat>0])/2 
negative <- length(betaMat[betaMat<0])/2 
total <- length(betaMat[betaMat!=0])/2
# Dividimos por 2 ya que el edge esta representado por dos entradas en la matriz
# Puedes mirar los números en el panel 'Environment' de RStudio
```

</div>

  - Ahora, vamos a asignarle color a los *edges* positivos y negativos y
    a visualizar la red.

<div class="sourceCode">

``` sourceCode r
# El primer paso es extraer los signos de los coeficientes de regresión de la matriz de coeficientes de regresión
tax_ids <- taxa_names(comau69_3)
edges <- E(net) # edges
edge_colors <- c()
for(e_index in 1:length(edges)){
  adj_nodes <- ends(net,edges[e_index])
  xindex <- which(tax_ids==adj_nodes[1])
  yindex <- which(tax_ids==adj_nodes[2])
  beta <- betaMat[xindex,yindex]
  if(beta>0){
    edge_colors=append(edge_colors,"forestgreen") # positive
  }else if(beta<0){
    edge_colors=append(edge_colors,"red") # negative
  }
}
E(net)$color <- edge_colors
```

</div>

  - Generamos el objeto de clase network y graficamos usando ggnet2.

<div class="sourceCode">

``` sourceCode r
# Extraer matriz de adyacencia
net_class <- as_adjacency_matrix(net, type = "both")
# Generar objeto de clase 'network'
net_class <- network(as.matrix(net_class), 
                     vertex.attrnames = taxa_names(comau69_3), 
                     matrix.type = "adjacency", directed = F)
```

</div>

  - Usamos el argumento `edge.color` de la función `ggnet2()` para
    colorear los *edges*.

<div class="sourceCode">

``` sourceCode r
# Graficar red
ggnet2(net_class, edge.color = E(net)$color)
```

</div>

![](images/ggnet2_NF_network_1.jpg)

  - Podemos hacer la visualización de la red más interesante agregando
    más información. Para ello, vamos a definir el nombre de cada nodo
    según su clasificación taxonómica a nivel de Phylum.

<div class="sourceCode">

``` sourceCode r
# Extraer tabla de taxonomía
tax_tbl <- as.data.frame(comau69_3@tax_table@.Data)
# Reemplazar el nombre de cada nodo por su Phylum
V(net)$name <- as.character(getTaxonomy(V(net)$name, tax_tbl, level = "phylum", useRownames = TRUE))
# Guardar la lista de Phylum por nodo en 'nodenames'
nodenames <- V(net)$name

# Extraer matriz de adyacencia
net_class <- as_adjacency_matrix(net, type = "both")
# Generar objeto de clase 'network'
net_class <- network(as.matrix(net_class), 
                     vertex.attrnames = taxa_names(comau69_3), 
                     matrix.type = "adjacency", directed = F)
```

</div>

<div class="sourceCode">

``` sourceCode r
# Graficar red
ggnet2(net_class, color = nodenames, edge.color = E(net)$color)
```

</div>

![](images/ggnet2_NF_network_2.jpg)

  - Finalmente, personalizamos la visualización asignando colores
    personalizados a los nodos según su Phylum.

<div class="sourceCode">

``` sourceCode r
# Definir paleta de colores por Phylum
colors1 <- c("Acidobacteriota" = "#263238", 
             "Actinobacteriota" = "#bf360c", 
             "Asgardarchaeota" = "#3690c0", 
             "Bacteroidota" = "#8c96c6", 
             "Binatota" = "#E91E63", 
             "Caldatribacteriota" = "#2196F3", 
             "Chloroflexota" = "#009688", 
             "Crenarchaeota" = "#FF9800", 
             "Cyanobacteria" = "#795548", 
             "Desulfobacterota_A" = "#91003f", 
             "Dadabacteria" = "#4a148c", 
             "Firmicutes" = "#673AB7", 
             "Firmicutes_A" = "#03A9F4", 
             "Firmicutes_B" = "#33691e", 
             "Fusobacteriota" = "#FF5722", 
             "Gemmatimonadota" = "#3F51B5", 
             "k__Bacteria" = "#CDDC39", 
             "Latescibacterota" = "#673AB7", 
             "k__Bacteria" = "#607D8B", 
             "Marinisomatota" = "#00BCD4", 
             "Myxococcota" = "#FFEB3B", 
             "Nanoarchaeota" = "#607D8B", 
             "Nitrospinota" = "#F44336", 
             "Nitrospirota" = "#c7e9b4", 
             "Patescibacteria" = "#4CAF50", 
             "Planctomycetota" = "#9C27B0", 
             "Poribacteria" = "#8c2d04", 
             "Proteobacteria" = "#FFC107", 
             "SAR324" = "#9E9E9E", 
             "Thermoplasmatota" = "#ffd180", 
             "Thermotogota" = "#e7298a", 
             "Verrucomicrobiota" = "#37474f")
```

</div>

<div class="sourceCode">

``` sourceCode r
ggnet2(net_class, color = nodenames, palette = colors1, edge.color = E(net)$color)
```

</div>

![](images/ggnet2_NF_network_3.jpg)

</div>

<div id="estabilidad-visual" class="section level2">

## <span class="header-section-number">4.2</span> Estabilidad visual

Cada vez que graficamos una red, las posiciones de los nodos son
re-calculadas. Para tener una representación visualmente estable y
comparable de la red, podemos usar coordinadas fijas para todos los
nodos y asignar el diseño como un atributo fijo a la red.

  - Fijar el diseño de la red.

<div class="sourceCode">

``` sourceCode r
# Las coordenadas deben estar en forma de una matriz n vs. m, donde n es el nombre de los nodos y m es las coordenadas x e y de cada nodo
# Asignar coordenadas al diseño de la red
net$layout <- array(1:40, dim = c(20, 2))
# Asignar el diseño como un atributo fijo de la red
net$layout <- layout.fruchterman.reingold(net)
```

</div>

Después de fijar el diseño de la red, solo hace falta agregar el
argumento `mode = net$layout` a la función `ggnet2()` cada vez que
queramos graficar la red y la distribución de los nodos se mantendrá
igual.

<div class="sourceCode">

``` sourceCode r
# Graficar red
ggnet2(net_class, mode = net$layout)
```

</div>

Usaremos esta estrategia en el resto del tutorial.

</div>

</div>

<div id="stats" class="section level1">

# <span class="header-section-number">5</span> Estadística de la red

En esta sección vamos a calcular *node degree*, *node centrality*, y
*transitivity* de la red.

  - Primero, creamos una copia de la red y fijamos el diseño.

<div class="sourceCode">

``` sourceCode r
# Copiar el objeto 'se_net' a 'net'
net <- se_net
# Asignar coordenadas al diseño de la red
net$layout <- array(1:40, dim = c(20, 2))
# Asignar el diseño como un atributo fijo de la red
net$layout <- layout.fruchterman.reingold(net)
```

</div>

<div id="degree" class="section level2">

## <span class="header-section-number">5.1</span> *Degree*

El valor de *degree* de un nodo representa el número de *edges*
conectados al nodo en cuestión, es decir, mientras más relaciones tenga
un nodo en particular con otros nodos en la red mayor *degree*.

La distribución de valores de *degree* de los nodos que componen una red
nos da una idea de la conectividad de los nodos en la red.

  - Usamos el paquete **[igraph](https://igraph.org)** para calcular los
    valores de *degree* y su distribución en la red.

<div class="sourceCode">

``` sourceCode r
# Calcular node degree
deg <- igraph::degree(net, mode = "all")
# Calcular degree distribution
deg.dist <- degree_distribution(net, mode = "all", cumulative = F)
```

</div>

  - Graficar distribución de los valores de *degree* de los nodos en la
    red.

<div class="sourceCode">

``` sourceCode r
# Graficar degree distribution
plot(deg.dist, xlab = "Nodes degree", ylab = "Probability")
lines(deg.dist)
```

</div>

![](images/ggnet2_NS_network_1.jpg)

</div>

<div id="node-centrality" class="section level2">

## <span class="header-section-number">5.2</span> *Node centrality*

La centralidad de los nodos en la red se mide de dos formas: *closeness*
y *betweenness*.

<div id="closeness" class="section level3">

### <span class="header-section-number">5.2.1</span> *Closeness*

*Closeness* se refiere a que tan central es cada nodo para la red
completa. Para medir *closeness* se recorre la red de forma aleatoria y
se cuantifica la frecuencia con la que se visita cada nodo. Nodos que
son visitados con mayor frecuencia tienen mayor valor de *closeness*.

  - Usamos la función `closeness()` del paquete igraph para calcular los
    valores de *closeness* de todos los nodos.

<div class="sourceCode">

``` sourceCode r
clos <- igraph::closeness(net, mode = "all")
```

</div>

</div>

<div id="betweenness" class="section level3">

### <span class="header-section-number">5.2.2</span> *Betweenness*

*Betweenness* también es una medida de centralidad de los nodos que
componen la red. El valor de *betweenness* de un nodo se calcula como el
número total de rutas más cortas desde todos los nodos a todos los otros
nodos que pasan a través del nodo en cuestión. Nodos que presentan un
valor de *betweenness* alto, son aquellos que conectan grupos de nodos
que soportan la red.

Un nodo puede tener un *degree* bajo y un *betweenness* alto, esto
representaría un nodo que tiene pocas conexiones, pero estas conexiones
conectan nodos altamente conectados con otros nodos.

  - Usamos la función `betweenness()` del paquete igraph para calcular
    los valores de *betweenness* de todos los nodos en la red.

<div class="sourceCode">

``` sourceCode r
betw <- igraph::betweenness(net, v = V(net))
# Si quieres calcular betweenness para uno o varios nodos en particular, usa el argumento 'v' para definir los nodos de interés
```

</div>

  - Podemos usar la función `centralityPlot()` del paquete qgraph para
    graficar los valores de *betweenness*, *closeness* y *degree* (*eje
    x*) de todos los nodos (*eje y*) en la red.

<div class="sourceCode">

``` sourceCode r
centralityPlot(net, include = c("Betweenness", "Closeness", "Degree")) + 
  theme(axis.text.y = element_blank())
```

</div>

![](images/ggnet2_NS_network_2.jpg)

</div>

</div>

<div id="transitivity" class="section level2">

## <span class="header-section-number">5.3</span> *Transitivity*

*Transitivity*, también llamado coeficiente de agrupamiento (*clustering
coefficient*), mide la probabilidad de que nodos adyacentes al nodo en
cuestión esten conectados entre sí.

  - Usamos la función `transitivity()` del paquete igraph para calcular
    *transitivity*.

<div class="sourceCode">

``` sourceCode r
# Usamos el argumento type = "global" para calcular el valor de transitivity total para toda la red
clustering_coeff_global <- transitivity(net, type = "global")
# Usamos el argumento type = "local" para calcular el valor de transitivity de cada nodo en la red
clustering_coeff_local <- transitivity(net, type = "local")
```

</div>

</div>

<div id="average-nearest-neighbor-degree-annd" class="section level2">

## <span class="header-section-number">5.4</span> *Average Nearest Neighbor Degree* (ANND)

ANND nos permite evaluar si la correlación entre los valores de *degree*
de nodos vecinos es positiva o negativa. Si es *positiva*; los nodos con
alto *degree* tienden a conectarse con otros nodos con alto *degree*.
Mientras que, si es *negativa*; los nodos con alto *degree* tienden a
conectarse con nodos con bajo *degree*.

Calcular ANND puede ser útil al momento de querer analizar cierto(s)
nodo(s) de interés y su relación con nodos adyacentes.

  - Usamos la función `knn()` del paquete igraph para calcular ANND.

<div class="sourceCode">

``` sourceCode r
# Para calcular el valor de ANND para todos los nodos en la red, usamos el argumento vids = V(net)
net.knn <- knn(net, vids = V(net))
head(net.knn$knn)
```

</div>

    ## TI_27683 TI_39035 TI_27681 TI_13593 TI_13597 TI_20829 
    ## 24.53333 24.22857 26.15385 22.76000 23.80769 25.32258

<div class="sourceCode">

``` sourceCode r
# Si quieres calcular ANND para uno o varios nodos en particular, usa el argumento 'vids' para definir los nodos de interés
```

</div>

</div>

</div>

<div id="structure" class="section level1">

# <span class="header-section-number">6</span> Estructura de la red

En esta sección vamos a evaluar la estructura de la red, nos referimos a
la detección de módulos o *clusters* dentro de la red y a la extracción
de estos para analizarlos como una red independiente.

  - Primero, creamos una copia de la red y fijamos el diseño.

<div class="sourceCode">

``` sourceCode r
# Copiar el objeto 'se_net' a 'net'
net <- se_net
# Asignar coordenadas al diseño de la red
net$layout <- array(1:40, dim = c(20, 2))
# Asignar el diseño como un atributo fijo de la red
net$layout <- layout.fruchterman.reingold(net)
```

</div>

<div id="deteccion-de-modulos" class="section level2">

## <span class="header-section-number">6.1</span> Detección de módulos

En una red de co-ocurrencia microbiana pueden existir grupos de nodos
que conformen un módulo o *cluster*, como una sub-red dentro de la red.
Un módulo o *cluster* se define como un conjunto de nodos que están
fuertemente relacionados entre sí, y a su vez, todos ellos se relacionan
en menor medida con nodos que no pertenecen al grupo.

It should be noted that igraph methods output an object containing
various information on the detected clusters, including but not limited
to the membership of each cluster (membership function below)

  - Usamos las funciones `walktrap.community()` y `membership()` del
    paquete igraph para, primero detectar posibles módulos dentro de la
    red, y segundo para consultar la membresía de cada nodo (*qué nodo
    pertenece a qué módulo*).

<div class="sourceCode">

``` sourceCode r
# Esta función intenta detectaar sub-redes densamente conectadas, usando 'random walks'
# 'random walks' se refiere a "recorrer" la red de forma aleatoria
# Se supone que "recorridos cortos" tienden a quedarse en la misma sub-red o módulo
wt <- walktrap.community(net)
# Consultar membresía de cada nodo
membership(wt) %>% head()
```

</div>

    ## TI_27683 TI_39035 TI_27681 TI_13593 TI_13597 TI_20829 
    ##        6        1        2        3        3        3

  - Usando la función `plot_dendrogram()` podemos visualizar los módulos
    o *clusters* detectados en un dendograma.

<div class="sourceCode">

``` sourceCode r
# Visualizar la estructura jerárquica de la comunidad microbiana en un dendograma
igraph::plot_dendrogram(wt)
```

</div>

![](images/NST_dendogram_1.jpg)

<div id="modularidad" class="section level3">

### <span class="header-section-number">6.1.1</span> Modularidad

Modularidad es una buena medida de la fuerza de división de una red en
módulos o *clusters*. Una **alta modularidad** indica que la red
presenta densas conexiones dentro de ciertos grupos de nodos (módulos),
y a su vez, conexiones dispersas entre grupos de nodos diferentes.

  - La modularidad de una red calculada con respecto a la membresía de
    los nodos que la componen, puede ser usada para estimar qué tan
    separados estan los módulos uno de otro.

<div class="sourceCode">

``` sourceCode r
# Calcular modularidad
modularity(net, membership(wt))
```

</div>

    ## [1] 0.4169191

</div>

<div id="visualizar-modulos" class="section level3">

### <span class="header-section-number">6.1.2</span> Visualizar módulos

  - Visualizar módulos o *clusters* en la red

<div class="sourceCode">

``` sourceCode r
# Plot
plot(wt, net)
```

</div>

![](images/igraph_NST_network_2.jpg)

Nuevamente, vamos a utilizar ggnet2 para visualizar la red y sus
estructura agregando más información para un análisis más exhaustivo de
la comunidad microbiana.

  - Generar objeto de clase network y visualizar la red definiendo
    diseño y coloreando los nodos según el módulo al que pertenecen.

<div class="sourceCode">

``` sourceCode r
# Extraer matriz de adyacencia
net_class <- as_adjacency_matrix(net, type = "both")
# Generar objeto de clase 'network'
net_class <- network(as.matrix(net_class), 
                     vertex.attrnames = taxa_names(comau69_3), 
                     matrix.type = "adjacency", directed = F)
```

</div>

<div class="sourceCode">

``` sourceCode r
ggnet2(net_class, mode = net$layout, color = wt$membership)
```

</div>

![](images/ggnet2_NST_network_3.jpg)

  - Ahora, vamos a usar la función `stat_ellipse()` de ggplot2 para
    dibujar una elipse, por módulo, alrededor del grupo de nodos
    miembros de cada módulo en particular.

<div class="sourceCode">

``` sourceCode r
ggnet2(net_class, mode = net$layout, color = wt$membership) + 
  stat_ellipse(aes(color = factor(wt$membership)), type = "norm")
```

</div>

![](images/ggnet2_NST_network_4.jpg)

  - Finalmente, vamos a enriquecer la visualización de la red, usando
    todas las habílidades de visualización de ggnet2 que hemos
    practicado hasta ahora.

<div class="sourceCode">

``` sourceCode r
# Extraer la clasificación taxonómica de cada nodo a nivel de Phylum
nodenames <- as.character(getTaxonomy(V(net)$name, tax_tbl, level = "phylum", useRownames = TRUE))
```

</div>

  - Graficamos la red de co-ocurrencia microbiana; coloreando los nodos
    según su taxonomía a nivel de Phylum (usando una paleta de colores
    personalizada), coloreando los *edges* según si representan una
    relación positiva o negativa, y definiendo los módulos o *clusters*
    dentro de la red usando elipses.

<div class="sourceCode">

``` sourceCode r
ggnet2(net_class, mode = net$layout, color = nodenames, palette = colors1, edge.color = edge_colors) + 
  stat_ellipse(aes(group = factor(wt$membership)), type = "norm")
```

</div>

![](images/ggnet2_NST_network_5.jpg)

</div>

</div>

<div id="sub-redes" class="section level2">

## <span class="header-section-number">6.2</span> Sub-redes

El paquete igraph incluye la función `induced_subgraph()` que nos
permite extraer o inducir sub-redes desde la red original. Por supuesto,
podemos usar esta función para extraer los módulos que detectamos arriba
y analizarlos uno a la vez. De hecho, cualquier selección de nodos puede
ser utilizada para extraer o inducir una sub-red.

Cabe señalar que todos los análisis aplicables a una red pueden ser
aplicados a una sub-red.

  - Primero, creamos un objeto con los nodos pertenecientes al módulo 1
    y/o 2, y luego, usamos este objeto para inducir la sub-red.

<div class="sourceCode">

``` sourceCode r
# Extraer nodos miembros del módulo 1
m1 <- V(net)[wt$membership == 1]
# Inducir sub-red 'm1': extraer módulo 1
m1_subnet <- induced_subgraph(net, m1)

# Extraer nodos miembros del módulo 2
m2 <- V(net)[wt$membership == 2]
# Inducir sub-red 'm1': extraer módulo 2
m2_subnet <- induced_subgraph(net, m2)
```

</div>

  - Ahora que hemos extraído el módulo 1 “m1” de la red, y lo tenemos en
    el objeto `m2_subnet` como una red aparte, podemos visualizarlo de
    forma independiente.

<div class="sourceCode">

``` sourceCode r
# Comenzamos fijando el diseño de la red m1
# Asignar coordenadas al diseño de la red
m1_subnet$layout <- array(1:40, dim = c(20, 2))
# Asignar el diseño como un atributo fijo de la red
m1_subnet$layout <- layout.fruchterman.reingold(m1_subnet)

# Creamos el objeto de clase network (input necesario para ggnet2)
# Extraer matriz de adyacencia
m1_class <- as_adjacency_matrix(m1_subnet, type = "both")
# Generar objeto de clase 'network'
m1_class <- network(as.matrix(m1_class), 
                     matrix.type = "adjacency", directed = F)
```

</div>

  - Graficamos la sub-red correspondiente al módulo 1.

<div class="sourceCode">

``` sourceCode r
ggnet2(m1_class, mode = m1_subnet$layout)
```

</div>

![](images/ggnet2_SubNet_network_1.jpg)

Tal y como lo hemos hecho antes; podemos **enriquecer la visualización
de la sub-red agregando más información acerca de los nodos y *edges*
del módulo 1**.

  - Extraemos la clasificación taxonómica a nivel de familia de los
    nodos miembros del módulo 1.

<div class="sourceCode">

``` sourceCode r
m1_nodenames <- as.character(getTaxonomy(V(m1_subnet)$name, tax_tbl, level = "family", useRownames = TRUE))
```

</div>

  - Graficamos el módulo 1, coloreando los nodos según a qué familia
    pertenecen.

<div class="sourceCode">

``` sourceCode r
ggnet2(m1_class, mode = m1_subnet$layout, color = m1_nodenames)
```

</div>

![](images/ggnet2_SubNet_network_2.jpg)

  - Identificamos las “familias” presentes en el módulo 1 y creamos una
    paleta de colores personalizada.

<div class="sourceCode">

``` sourceCode r
unique(m1_nodenames)
```

</div>

    ## [1] "Rhodobacteraceae"  "UBA11654"          "Flavobacteriaceae"
    ## [4] "NAC60-12"

<div class="sourceCode">

``` sourceCode r
colors2 <- c("Rhodobacteraceae" = "#BF0B3B", 
             "UBA11654" = "#1835D9", 
             "Flavobacteriaceae" = "#F2B90C", 
             "NAC60-12"  = "#238C2A")
```

</div>

  - Finalmente, graficamos el módulo 1 coloreando los nodos según la
    familia a la que pertenecen.

<div class="sourceCode">

``` sourceCode r
ggnet2(m1_class, mode = m1_subnet$layout, color = m1_nodenames, palette = colors2)
```

</div>

![](images/ggnet2_SubNet_network_3.jpg)

También podemos evaluar otras características de la sub-red, así:

<div class="sourceCode">

``` sourceCode r
vcount(m1_subnet) # vertices
```

</div>

    ## [1] 64

<div class="sourceCode">

``` sourceCode r
ecount(m1_subnet) # edges
```

</div>

    ## [1] 581

<div class="sourceCode">

``` sourceCode r
vcount(m2_subnet) # vertices
```

</div>

    ## [1] 276

<div class="sourceCode">

``` sourceCode r
ecount(m2_subnet) # edges
```

</div>

    ## [1] 2279

<div class="sourceCode">

``` sourceCode r
transitivity(m1_subnet)
```

</div>

    ## [1] 0.4706745

<div class="sourceCode">

``` sourceCode r
transitivity(m2_subnet)
```

</div>

    ## [1] 0.1461415

</div>

</div>

<div id="keystone" class="section level1">

# <span class="header-section-number">7</span> Búsqueda de *keystone species*

![](images/bacteria_2.png) Una de las aplicaciones más importantes de
inferir la red de co-ocurrencia microbiana es la búsqueda de; ***hub
species*** y ***keystone species***. Nodos identificados como especies
*hub* o *keystone* representan taxas potencialmente centrales y con un
rol importante dentro de la comunidad microbiana en estudio.

Aquellos nodos con los valores de *degree* más altos se identifican como
***hub species***, que representan taxas altamente conectadas dentro de
la comunidad microbiana.

Una *hub specie* **podría** representar una ***keystone specie***.
*Keystone species* se consideran muy importantes para la estructura y
funcionamiento de la comunidad microbiana, y su remoción podría causar
el colapso de la comunidad.

![](images/question.png) ¿Cómo podemos evaluar si una *hub specie* es
una *keystone specie*?

*Node Degree* ![](images/add.png) *Node Centrality*

  
Una *hub specie* es detectada por su alto *degree* en comparación a
todas las otras taxas/nodos en la comunidad microbiana/red. Luego, al
estimar *node centrality* calculando *betweenness* establecemos además
que la taxa/nodo es central dentro de la comunidad microbiana/red, ya
que conecta grupos de taxas/nodos que soportan a la comunidad/red.

![](images/important.png) Como mencionamos antes (sección [5](#stats));
un nodo puede tener un *degree* bajo y un *betweenness* alto, esto
representaría un nodo que tiene pocas conexiones, pero estas conexiones
conectan nodos altamente conectados con otros nodos. Por lo tanto,
podrían representar una *keystone specie*, ya que removerlos podría
causar el colapso de la comunidad.

![](images/important.png) También, podemos acumular evidencia para
definir un nodo como representante de una *keystone specie* dentro de la
comunidad microbiana, haciendo el experimento de remover el nodo de la
red y ver qué pasa (i.e., qué tanto afecta a la estructura de la red).

![](images/task.png) Sin embargo, **en este tutorial vamos a realizar la
búsqueda de *keystone species* mediante el cálculo de *degree* y
*betweenness*, seleccionando aquellos nodos que presenten los valores
más altos en comparación a todos los nodos en la red**.

<div id="node-degree" class="section level2">

## <span class="header-section-number">7.1</span> *Node degree*

  - Calculamos los valores de *degree* de todos los nodos en la red y
    ordenamos de mayor a menor.

<div class="sourceCode">

``` sourceCode r
# Calcular degree
deg <- igraph::degree(net)
# Ordenar nodos según degree de mayor a menor
deg_sort <- sort(deg, decreasing = TRUE)
head(deg_sort) # Mira las primeras 6 filas del objeto 'deg_sort'
```

</div>

    ## TI_27397 TI_27345 TI_27344 TI_27357 TI_27360 TI_27772 
    ##       58       58       53       51       51       49

  - Graficamos un histograma para visualizar los valores de *degree* de
    los nodos que componen la red.

<div class="sourceCode">

``` sourceCode r
# Transformar 'deg_sort' a un objeto de tipo 'data frame', necesario para graficar el histograma
deg_df <- as.data.frame(deg_sort)
```

</div>

<div class="sourceCode">

``` sourceCode r
# Graficar histograma
# También usamos la función `geom_vline()` del paquete ggplot2 para dibujar una línea discontinua para marcar la media o promedio de los valores de degree
ggplot(deg_df, aes(x = deg_sort)) + 
  geom_histogram(binwidth = 1) + 
  scale_x_continuous(breaks=c(0,10,20,30,40,50,60)) + 
  geom_vline(aes(xintercept=mean(deg_sort)),
             color="black", linetype="dashed", size=1) + 
  theme_minimal() + 
  labs(x = "Degree", y = "Node count")
```

</div>

![](images/KS_degree_histogram_1.jpg)

</div>

<div id="node-centrality-1" class="section level2">

## <span class="header-section-number">7.2</span> *Node centrality*

  - Como medida de centralidad, calculamos los valores de *betweenness*
    de todos los nodos en la red y ordenamos de mayor a menor.

<div class="sourceCode">

``` sourceCode r
# Calcular betweenness
bn <- igraph::betweenness(net)
# Ordenar nodos según betweenness de mayor a menor
bn_sort <- sort(bn, decreasing = TRUE)
head(bn_sort) # Mira las primeras 6 filas del objeto 'bn_sort'
```

</div>

    ## TI_27683 TI_27698 TI_38980 TI_29620 TI_23094 TI_27397 
    ## 3184.922 3026.017 2980.506 2889.191 2724.146 2723.078

  - Graficamos un histograma para visualizar los valores de
    *betweenness* de los nodos que componen la red.

<div class="sourceCode">

``` sourceCode r
# Transformar 'bn_sort' a un objeto de tipo 'data frame', necesario para graficar el histograma
bn_df <- as.data.frame(bn_sort)
```

</div>

<div class="sourceCode">

``` sourceCode r
# Graficar histograma
# También usamos la función `geom_vline()` del paquete ggplot2 para dibujar una línea discontinua para marcar la media o promedio de los valores de betweenness
ggplot(bn_df, aes(x = bn_sort)) + 
  geom_histogram(binwidth = 30) +  
  geom_vline(aes(xintercept=mean(bn_sort)), 
             color="black", linetype="dashed", size=1) + 
  theme_minimal() + 
  labs(x = "Betweenness", y = "Node count")
```

</div>

![](images/KS_betweenness_histogram_2.jpg)

</div>

<div id="keystone-species" class="section level2">

## <span class="header-section-number">7.3</span> *Keystone species*

Como mencionamos antes, vamos a seleccionar como *keystone species*
aquellos nodos que presenten los valores más altos en comparación a
todos los nodos en la red.

  - Comencemos por mirar ambos histogramas.

<div class="sourceCode">

``` sourceCode r
# Usamos la función 'grid.arrange' del paquete 'gridExtra' para visualizar ambos histogramas juntos
pdeg <- ggplot(deg_df, aes(x = deg_sort)) + 
  geom_histogram(binwidth = 1) + 
  scale_x_continuous(breaks=c(0,10,20,30,40,50,60)) + 
  geom_vline(aes(xintercept=mean(deg_sort)),
             color="black", linetype="dashed", size=1) + 
  theme_minimal() + 
  labs(x = "Degree", y = "Node count", title = "Network Nodes Degree")
pbn <- ggplot(bn_df, aes(x = bn_sort)) + 
  geom_histogram(binwidth = 30) +  
  geom_vline(aes(xintercept=mean(bn_sort)), 
             color="black", linetype="dashed", size=1) + 
  theme_minimal() + 
  labs(x = "Betweenness", y = "Node count", title = "Network Nodes Centrality: Betweenness")
grid.arrange(pdeg, pbn, ncol = 2)
```

</div>

![](images/KS_degbn_histogram_3.jpg)

Basándonos en la distribución de los valores de *degree* y
*betweenness*, vamos a definir como criterio:

> ***Degree* \> 30**
> 
> ***Betweenness* \> 1000**

  - Hacemos la selección siguiendo el criterio definido arriba.

<div class="sourceCode">

``` sourceCode r
# Editar la tabla de degree
head(deg_df)
```

</div>

    ##          deg_sort
    ## TI_27397       58
    ## TI_27345       58
    ## TI_27344       53
    ## TI_27357       51
    ## TI_27360       51
    ## TI_27772       49

<div class="sourceCode">

``` sourceCode r
deg_df$TaxID <- row.names(deg_df) 
head(deg_df)
```

</div>

    ##          deg_sort    TaxID
    ## TI_27397       58 TI_27397
    ## TI_27345       58 TI_27345
    ## TI_27344       53 TI_27344
    ## TI_27357       51 TI_27357
    ## TI_27360       51 TI_27360
    ## TI_27772       49 TI_27772

<div class="sourceCode">

``` sourceCode r
# Filtramos las taxas con degree > 30 y las guardamos en un nuevo data frame
deg_high_df <- dplyr::filter(deg_df, deg_sort > 30)
head(deg_high_df)
```

</div>

    ##   deg_sort    TaxID
    ## 1       58 TI_27397
    ## 2       58 TI_27345
    ## 3       53 TI_27344
    ## 4       51 TI_27357
    ## 5       51 TI_27360
    ## 6       49 TI_27772

<div class="sourceCode">

``` sourceCode r
# Editar la tabla de betweenness
head(bn_df)
```

</div>

    ##           bn_sort
    ## TI_27683 3184.922
    ## TI_27698 3026.017
    ## TI_38980 2980.506
    ## TI_29620 2889.191
    ## TI_23094 2724.146
    ## TI_27397 2723.078

<div class="sourceCode">

``` sourceCode r
bn_df$TaxID <- row.names(bn_df)
# Filtramos las taxas con betweenness > 1000 y las guardamos en un nuevo data frame
bn_high_df <- dplyr::filter(bn_df, bn_sort > 1000)
head(bn_high_df)
```

</div>

    ##    bn_sort    TaxID
    ## 1 3184.922 TI_27683
    ## 2 3026.017 TI_27698
    ## 3 2980.506 TI_38980
    ## 4 2889.191 TI_29620
    ## 5 2724.146 TI_23094
    ## 6 2723.078 TI_27397

<div class="sourceCode">

``` sourceCode r
# Unimos las tablas de degree y betweenness filtradas
keystone <- merge(deg_high_df, bn_high_df, all.x = FALSE)
head(keystone)
```

</div>

    ##      TaxID deg_sort  bn_sort
    ## 1 TI_12263       34 1719.243
    ## 2 TI_15981       38 1409.270
    ## 3 TI_19404       41 2595.900
    ## 4 TI_20829       31 1396.062
    ## 5 TI_22891       33 1214.696
    ## 6 TI_22895       34 1402.364

<div class="sourceCode">

``` sourceCode r
# Ordenamos 'keystone' según degree de mayor a menor
keystone <- keystone[order(keystone$deg_sort, decreasing = TRUE),]
# Definir los ID de las taxas como row names del data frame 'keystone'
row.names(keystone) <- keystone$TaxID
```

</div>

  - El objeto `keystone` contiene los 53 nodos identificados como
    *keystone species*.

<div class="sourceCode">

``` sourceCode r
# Mira el objeto 'keystone'
View(keystone)
```

</div>

|           | TaxID     | deg\_sort | bn\_sort |
| --------- | :-------- | --------: | -------: |
| TI\_27397 | TI\_27397 |        58 | 2723.078 |
| TI\_27772 | TI\_27772 |        49 | 1304.233 |
| TI\_27401 | TI\_27401 |        48 | 1346.002 |
| TI\_27698 | TI\_27698 |        48 | 3026.017 |
| TI\_27683 | TI\_27683 |        45 | 3184.922 |
| TI\_27771 | TI\_27771 |        45 | 1891.286 |
| TI\_19404 | TI\_19404 |        41 | 2595.900 |
| TI\_37462 | TI\_37462 |        41 | 1669.543 |
| TI\_27781 | TI\_27781 |        40 | 1355.041 |
| TI\_37729 | TI\_37729 |        40 | 1445.233 |

  - Ahora que ya tenemos nuestra selección de nodos representantes de
    *keystone species* en la red, vamos a visualizarlos en un gráfico de
    puntos según sus valores de *degree* y *betweenness*.

<div class="sourceCode">

``` sourceCode r
# Usamos ggplot2
ggplot(keystone, aes(x = bn_sort, y = deg_sort, label = TaxID)) + 
  scale_y_continuous(limits = c(30, 61), breaks = c(30,40,50,60)) + 
  scale_x_continuous(limits = c(1000, 3250), breaks = c(1000,1500,2000,2500,3000)) + 
  geom_point(alpha = 0.4, color = "#829FD9", size = 8) + 
  geom_text(size = 4) + 
  theme_minimal() + 
  labs(x = "Betweenness", y = "Degree", 
       title = "Nodes With Highest Degree And Betweenness: Keystone Nodes")
```

</div>

![](images/KS_KeystoneNodes_pointgraph_4.jpg)

  - Finalmente, vamos a visualizar la red de co-ocurrencia microbiana
    agregando una etiqueta (i.e., nombre del nodo/taxa) sobre los 53
    nodos identificados como *keystone species*.

<div class="sourceCode">

``` sourceCode r
# Graficar red
ggnet2(net_class, mode = net$layout, 
       color = nodenames, palette = colors1, 
       node.alpha = 0.9, 
       edge.color = edge_colors, 
       label = keystone$TaxID, label.size = 4) + 
  stat_ellipse(aes(group = factor(wt$membership)), type = "norm")
```

</div>

![](images/ggnet2_KS_network_5.jpg)

</div>

<div id="nodo-ti_27772" class="section level2">

## <span class="header-section-number">7.4</span> Nodo TI\_27772

![](images/task.png) A continuación vamos a poner en práctica varias de
las habilidades de análisis de redes que hemos aprendido en este
tutorial para estudiar el nodo `TI_27772`.

Mira la última visualización de la red e identifica el nodo `TI_27772`,
se trata de una *keystone specie* miembro de uno de los módulos de la
red.

  - Comencemos por identificar y extraer el módulo en el que se
    encuentra el nodo `TI_27772`.

<div class="sourceCode">

``` sourceCode r
# Consultar de cuál módulo es miembro en nodo TI_27772
TI_27772 <- V(net)[wt$membership == 
                     wt$membership[which(wt$names == "TI_27772")]] # which position
TI_27772
```

</div>

    ## + 64/650 vertices, named, from 1caee8a:
    ##  [1] TI_39035 TI_34536 TI_27771 TI_27772 TI_27767 TI_27760 TI_27781
    ##  [8] TI_27776 TI_27779 TI_27763 TI_27755 TI_27782 TI_27762 TI_27768
    ## [15] TI_27757 TI_27759 TI_27770 TI_27777 TI_27766 TI_27754 TI_27756
    ## [22] TI_27764 TI_27765 TI_27758 TI_27761 TI_27778 TI_27769 TI_27773
    ## [29] TI_33496 TI_33499 TI_33502 TI_33491 TI_33492 TI_33487 TI_33493
    ## [36] TI_33495 TI_33497 TI_33498 TI_33494 TI_33501 TI_33503 TI_33500
    ## [43] TI_33488 TI_38278 TI_38280 TI_22953 TI_22959 TI_22951 TI_22952
    ## [50] TI_22950 TI_22954 TI_22958 TI_22173 TI_22176 TI_33504 TI_13259
    ## [57] TI_13258 TI_18928 TI_36969 TI_18927 TI_13260 TI_31475 TI_13884
    ## [64] TI_13846

<div class="sourceCode">

``` sourceCode r
# Inducir la sub-red correspondiente al módulo en el que se encuentra el nodo TI_27772
TI_27772_subnet <- induced_subgraph(net, TI_27772)

# Fijar el diseño de la sub-red 'TI_27772_subnet'
# Asignar coordenadas al diseño de la red
TI_27772_subnet$layout <- array(1:40, dim = c(20, 2))
# Asignar el diseño como un atributo fijo de la red
TI_27772_subnet$layout <- layout.fruchterman.reingold(TI_27772_subnet)

# Extraer matriz de adyacencia
TI_27772_class <- as_adjacency_matrix(TI_27772_subnet, type = "both")
# Generar objeto de clase 'network'
TI_27772_class <- network(as.matrix(TI_27772_class), 
                          matrix.type = "adjacency", directed = F)
```

</div>

  - Graficamos la sub-red correspondiente al módulo del cuál el nodo
    `TI_27772` es miembro.

<div class="sourceCode">

``` sourceCode r
ggnet2(TI_27772_class, mode = TI_27772_subnet$layout)
```

</div>

![](images/ggnet2_KS_subnetwork_6.jpg)

  - Extraemos la clasificación taxonómica a nivel de familia de los
    nodos en la sub-red `TI_27772_subnet`.

<div class="sourceCode">

``` sourceCode r
TI_27772_nodenames <- as.character(getTaxonomy(V(TI_27772_subnet)$name, tax_tbl, level = "family", useRownames = TRUE))
```

</div>

  - Graficar la sub-red `TI_27772_subnet` coloreando los nodos según su
    clasificación taxonómica a nivel de familia.

<div class="sourceCode">

``` sourceCode r
ggnet2(TI_27772_class, mode = TI_27772_subnet$layout, color = TI_27772_nodenames)
```

</div>

![](images/ggnet2_KS_subnetwork_7.jpg)

  - Para agregar más información a la visualización de la sub-red
    `TI_27772_subnet`; definimos una paleta personalizada de colores
    para colorear los nodos según su clasificación taxonómica a nivel de
    familia, y coloreamos los *edges* según si representan una relación
    positiva o negativa.

<div class="sourceCode">

``` sourceCode r
# Identificar familias presentes en la red
unique(TI_27772_nodenames)
```

</div>

    ## [1] "Rhodobacteraceae"  "UBA11654"          "Flavobacteriaceae"
    ## [4] "NAC60-12"

<div class="sourceCode">

``` sourceCode r
# Personalizar paleta de colores
colors2 <- c("Rhodobacteraceae" = "#BF0B3B", 
             "UBA11654" = "#1835D9", 
             "Flavobacteriaceae" = "#F2B90C", 
             "NAC60-12"  = "#238C2A")
# Identificar y asignar color a los edges según si representan una relación positiva o negativa
edges1 <- E(TI_27772_subnet)
edge_colors <- c()
for(e_index in 1:length(edges1)){
  adj_nodes <- ends(TI_27772_subnet,edges1[e_index])
  xindex <- which(tax_ids==adj_nodes[1])
  yindex <- which(tax_ids==adj_nodes[2])
  beta <- betaMat[xindex,yindex]
  if(beta>0){
    edge_colors=append(edge_colors,"forestgreen") # positive
  }else if(beta<0){
    edge_colors=append(edge_colors,"red") # negative
  }
}
E(TI_27772_subnet)$color <- edge_colors
```

</div>

  - Finalmente, visualizamos la sub-red correspondiente al módulo que
    contiene el *keystone* nodo `TI_27772`.

<div class="sourceCode">

``` sourceCode r
ggnet2(TI_27772_class, mode = TI_27772_subnet$layout, 
       color = TI_27772_nodenames, palette = colors2, 
       node.alpha = 0.9, 
       edge.color = E(TI_27772_subnet)$color, 
       label = keystone$TaxID, label.size = 4)
```

</div>

![](images/ggnet2_KS_subnetwork_8.jpg)

-----

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

</div>

</div>

</div>

</div>

</div>

</div>

</div>

</div>

<div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

<div class="book-summary">

  - [Visualización y curación de
    MAGs](http://castrolab.org/isme/mags/mags.html)

  - 
  - [****0.1** Acerca del curso](#workshop)

  - [****1** MAGs (*Metagenome-assembled
    genomes*)](#mags-metagenome-assembled-genomes)

  - [****2** Datos de entrada](#datos-de-entrada)

  - [****3** *Binning*](#binning)

  - [****4** Visualización de *bins*](#visualizacion-de-bins)
    
      - [****4.1** Instalar y cargar las paquetes de
        R](#instalar-y-cargar-las-paquetes-de-r)
      - [****4.2** Cargar archivos de
        entrada](#cargar-archivos-de-entrada)
          - [****4.2.1** Obteniendo el contenido
            GC](#obteniendo-el-contenido-gc)
          - [****4.2.2** Obteniendo la
            cobertura](#obteniendo-la-cobertura)
          - [****4.2.3** Obteniendo la información de los
            *bins*](#obteniendo-la-informacion-de-los-bins)
          - [****4.2.4** Visualización de los
            *bins*](#visualizacion-de-los-bins)
          - [****4.2.5** Mejoramiento de los
            *bins*](#mejoramiento-de-los-bins)
          - [****4.2.6** Agregando información
            extra](#agregando-informacion-extra)
      - [****4.3** Obteniendo información
        taxonómica](#obteniendo-informacion-taxonomica)
      - [****4.4** Visualizar grupos
        taxonómicos](#visualizar-grupos-taxonomicos)
      - [****4.5** Usando marcadores para mejorar los
        *bins*](#usando-marcadores-para-mejorar-los-bins)

  - [****5** Abundancia de *bins* y comunidades
    microbianas](#abundancia-de-bins-y-comunidades-microbianas)

  - 
  - [CASTRO LAB](http://www.castrolab.org)

  - [ISME LA 2019](https://isme-la2019.org)

</div>

<div class="book-body">

<div class="body-inner">

<div class="book-header" role="navigation">

# **[Visualización y curación de genomas ensamblados desde metagenomas (MAGs)](./)

</div>

<div class="page-wrapper" tabindex="-1" role="main">

<div class="page-inner">

<div id="section-" class="section normal">

<div id="header">

*ISME Latin America, Septiembre 2019*

</div>

<div id="workshop" class="section level2">

## <span class="header-section-number">0.1</span> Acerca del curso

El tutorial a continuación fue creado especialmente para guiar el
trabajo práctico del [**curso pre-congreso ISME Latin
America 2019**](https://isme-la2019.org/curso-pre-congreso/): **Análisis
de datos bioinformáticos para metagenomas y amplicones usando R**. A
realizarse el próximo 9 y 10 de septiembre en la [Universidad Técnica
Federico Santa María](https://www.usm.cl), Valparaíso, Chile.

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

El curso cuenta con **6 unidades**. Ahora, usted se encuentra en la
unidad: **Visualización y curación de genomas ensamblados desde
metagenomas (MAGs)** ![](images/genome.png)

> **Otras unidades del curso son**:
> 
> [**Introducción a R: Manipulación de datos y
> visualización**](http://www.castrolab.org/isme/introR/introR.html)
> ![](images/r.png)
> 
> [**Análisis de secuencias de 16S con
> DADA2**](http://www.castrolab.org/isme/dada2/dada2.html)
> ![](images/bioinformatics.png)
> 
> [**Introducción a phyloseq y a análisis de
> diversidad**](http://www.castrolab.org/isme/biodiversity/biodiversity.html)
> ![](images/bacteria.png)
> 
> [**Búsqueda de genes de interés en datos de metagenómica
> *shotgun***](http://www.castrolab.org/isme/gene_search/gene_search.html)
> ![](images/gene_search.png)
> 
> [**Redes de co-ocurrencia de
> microorganismos**](http://www.castrolab.org/isme/microbial_networks/microbial_networks.html)
> ![](images/network.png)

-----

  - Profesor: **Dr. Eduardo Castro-Nallar** (<eduardo.castro@unab.cl>)

  - Ayudantes:
    
      - **Dr. Florence Gutzwiller** (<florence.gutzwiller@gmail.com>)
      - **M.Sc. Katterinne N. Mendez** (<mendez.katterinne@gmail.com>)

**[CASTRO LAB](http://www.castrolab.org)**

[Centro de Bioinformática y Biología Integrativa](http://www.cbib.cl) |
[Universidad Andrés Bello](https://www.unab.cl)

![](images/UNAB_CBIB_horizontal.png)

[Santiago, Chile](https://goo.gl/maps/BCe9hWcRZJKkhaDP8)

</div>

<div id="mags-metagenome-assembled-genomes" class="section level1">

# <span class="header-section-number">1</span> MAGs (*Metagenome-assembled genomes*)

La extracción de genomas microbianos directamente desde metagenomas
*shotgun* tiene muchas ventajas porque no depende de ninguna base de
datos, lo que permite la identificación de nuevos microorganismos. Sin
embargo, encontrar *reads* que vengan del mismo genoma en un metagenoma
complejo es complicado, debido a que la información es limitada con
respecto a qué características utilizar para separar *reads*.  
Para identificar genomas en metagenomas, varios programas han sido
desarrollados. Estos programas agrupan *contigs* de características
similares en *bins* (a partir de *contigs* que vienen de un ensamblaje
*de novo*). Los programas de *binning* en general aprovechan dos tipos
de información: **cobertura** (*coverage*) y **composición**.

**Cobertura** se refiere a cuántas *reads* mapean en contra de un
*contig* dado y es la característica más intuituva de entender porque
organismos diferentes deberían tener coberturas diferentes. *Contigs*
que vienen de los mismos microorganismos deberían tener más o menos la
misma abundancia. Naturalmente, existen limitaciones intrínsecas debido
a que la cobertura, y en consecuencia la abundancia de cada *contig*,
está sesgada por la secuenciación.

La **composición** se basa en el hecho de que la composición
nucleotídica de un microorganismo, el porcentaje de cada nucleótido (y
sus combinaciones) en el genoma es similar intra especie y difiere entre
especies. El porcentaje de GC en bacterias puede variar de menos del 20%
hasta más del 70%. Podemos evaluar composición de diferentes maneras: el
porcentaje GC, frecuencia de di-, tri- o tetra-nucleótidos, etc. La
frecuencia de tetrámeros, por ejemplo, evaluaría las veces que se
detectan combinaciones de cuatro nucleótidos en un contig o genoma. Una
limitación de este método es que aunque la composición es relativamente
estable en promedio en un genoma, esta también varía localmente lo que
junto a *contigs* de variadas longitudes pueden llegar a confundir a un
algortimo de *binning*.

Algunos programas utilizan una de estas características para separar
genomas de metagenomes, sin embargo programas más modernos utilizan
ambas para tratar de agrupar *contigs* de manera correcta y recuperar
genomas de alta calidad.

**La calidad de los metagenomas al igual que la profundidad tiene que
ser alta**. Además, la longitud de los *contigs* tiene un efecto
importante debido a que las características de **cobertura y composición
pueden ser mejor estimadas a partir de *contigs* largos**, y así
aproximar los valores para la especie microbiana en cuestión.

</div>

<div id="datos-de-entrada" class="section level1">

# <span class="header-section-number">2</span> Datos de entrada

En esta unidad vamos a usar datos preliminares de **comunidades
microbianas de la rizósfera de plantas Antárticas**. Un primer análisis
de estos datos ya ha sido publicado donde puedes encontrar más detalles
sobre las muestras y sobre cómo descargar el *raw data*.

> Molina-Montenegro, M.A., Ballesteros, G.I., Castro-Nallar, E.,
> Meneses, C., Gallardo-Cerda, J. and Torres-Díaz, C., 2019. [A first
> insight into the structure and function of rhizosphere microbiota in
> Antarctic plants using shotgun
> metagenomics](https://link.springer.com/article/10.1007/s00300-019-02556-7).
> Polar Biology, pp.1-11.

![](images/_DSC3922.jpg)

Solamente dos plantas vasculares nativas existen en la Antártica:
*Colobanthus quitensis* y *Deschampsia antarctica*. En ambas plantas se
ha demostrado que organismos asociados a la raíz tienen un impacto sobre
su habilidad para tolerar condiciones extremas, tales como baja
disponibilidad de agua y alta salinidad.

Ambas plantas ocurren en zonas que en verano están libres de hielo y
nieve, principalmente en la Península Antártica, sin embargo su
distribución no es idéntica. *D. antarctica* principalmente crece sola
en áreas de alta exposición al viento y al *spray* del océano, mientras
que *C. quitensis* aparentemente favorece lugares mejor protegidos donde
pueda tener acceso a agua dulce. Sin embargo, *C. quitensis* puede
también ser encontrada en lugares más expuestos siempre y cuando crezca
en asociación con *D. antarctica* (ver foto). Esto sugiere que las
raíces de *D. antarctica* podrían permitir *C. quitensis* tolerar de
mejor manera lugares expuestos.

<div class="figure">

![association](images/association.jpg)

association

</div>

Entonces, para estudiar la composición y estructura de las comunidades
microbianas de *C. quitensis* y *C. quitensis* en asociación con *D.
antarctica*, secuenciamos ADN de la rizósfera en ambos casos, con tres
réplicas para cada caso. En este tutorial, vamos a utilizar *contigs*
de cada muestra que ya han sido previamente agrupados en *bins*. Las
*reads* usadas para el ensamblaje fueron obtenidas a partir de
secuenciación en la plataforma Illumina MiSeq. En la siguiente sección
se describen los pasos realizados para procesar el *raw data* hasta
llegar a los datos de entrada de este tutorial.

</div>

<div id="binning" class="section level1">

# <span class="header-section-number">3</span> *Binning*

Como en todos los proyectos de secuenciación, el primer paso fue
realizar un control de calidad de las *reads*, cortar adaptadores, y
remover secuencias de baja calidad usando **PRINSEQ-lite** (version
0.20.4).

Configuramos los parámetros de acuerdo al largo de las reads y su
calidad: longitud mínima de 50 bases (`-min_len 50`), calidad promedio
mínima de 20 (`-min_qual_mean 20`), y una calidad promedio en ventanas
de 50 bp de 20 (`-trim_qual_window 20`; `-trim_qual_step 5`). Filtramos
*reads* con bases indeterminadas (`-ns_max_p 0`), y removemos solamente
duplicados exactos presentes dos o más veces (`-derep 1 -derep_min 2`),
ya que esperamos que la variabilidad sea alta y secuencias duplicadas
podrían ser artefactos. También removemos secuencias de baja complejidad
con un puntaje de 32 o menos (`-lc_threshold 32`). Finalmente, removemos
5 nucleótidos en el extremo 5’ y 20 en el 3’.

<div class="sourceCode">

``` sourceCode bash
for i in $list_sample
do
prinseq-lite.pl -verbose -fastq $rawdir/${i}_1.fastq -fastq2 $rawdir/${i}_2.fastq -min_len 50 -min_qual_mean 20 -ns_max_p 0 -derep 1 -derep_min 2 -lc_method dust -lc_threshold 32 -trim_left 5 -trim_right 20 -trim_qual_right 20 -trim_qual_window 20 -trim_qual_step 5 -out_format 3 -out_good $cleaneddir/${i} -out_bad null >> $cleaneddir/prinseq_${i}.log
done
```

</div>

Una vez limpias, las reads son concatenadas, *forwards* con *forwards* y
lo mismo con las *reverse* para así hacer un único co-ensamblaje usando
**metaSPAdes** (version v3.12.0). Las opciones `-t` y `-m` permiten
especificar el numero de hilos y la memoria disponible, respectivamente.

<div class="sourceCode">

``` sourceCode bash
metaspades.py -1 $filtereddir/concat_samples_1.fastq -2 $filtereddir/concat_samples_2.fastq -s $filtereddir/concat_samples_singletons.fastq -t 80 -m 1000 -o $assemblydir/concat_samples
```

</div>

**MEGAHIT** también puede ser usado para el ensamblaje, especialmente
con conjuntos de datos más grandes porque es menos demandante de memoria
RAM.

Una vez que el ensamblaje está listo, mapeamos de vuelta las reads en
contra de los contigs de cada muestra usando **Bowtie2** (version
2.3.4.2). De esta manera, para cada muestra tenemos un archivo de
alineamiento: BAM.

<div class="sourceCode">

``` sourceCode bash
  for i in $samples
do
bowtie2 -p 20 -x $assemblydir/contigs -1 $cleaneddir/${i}_1.fastq -2 $cleaneddir/${i}_2.fastq -U $cleaneddir/${i}_singleton.fastq |  samtools view -bh | samtools sort -o $bamdir/${i}.bam
done
```

</div>

Finalmente, teniendo los contigs ensamblados y los BAMs individuales de
cada muestra podemos comenzar con el *binning*. Para esto, usamos dos
programas, **MaxBin** (version 2.2.4) y **MetaBat** (version 2.12.1).
Ambos requieren una longitud de contig mayor a 1 kb. El output de ambos
programas se obtiene en formato FASTA, lo cual usaremos para las
visualizaciones más adelante en el tutorial.

MaxBin calcula la abundancia usando las *reads* para cada muestra (en
**reads\_list.txt**) y el ensamblaje.

<div class="sourceCode">

``` sourceCode bash
  for i in $samples
do
run_MaxBin.pl -verbose -thread 32 -min_contig_length 1000 -contig $assemblydir/contigs.fasta -out $bindir/maxbin_6samples -reads_list reads_list.txt
done
```

</div>

MetaBat toma como *input* los archivos BAM para calcular la abundancia
primero, y luego usa el *output* para el *binning*.

<div class="sourceCode">

``` sourceCode bash
  for i in $samples
do
jgi_summarize_bam_contig_depths --outputDepth $bamdir/depth.txt  $bamdir/*.bam
metabat2 -i $assemblydir/contigs.fasta -a $bamdir/depth.txt -o $bindir/metabat -t 20 
done
```

</div>

Finalmente, para poder agregar información taxonómica a cada contig para
fines de evaluación, necesitamos hacer una identificación con marcadores
genéticos. Para hacer esto usamos **AMPHORA2**, el cual encuentra genes
marcadores y utiliza un enfoque filogenético para asignarle taxonomía a
cada marcador.

<div class="sourceCode">

``` sourceCode bash
  for i in $samples
do
cd $amphora_dir

perl /home/user/AMPHORA2/Scripts/MarkerScanner.pl -Bacteria -DNA $contigs
perl /home/user/AMPHORA2/Scripts/MarkerAlignTrim.pl -WithReference -OutputFormat phylip
perl /home/user/AMPHORA2/Scripts/Phylotyping.pl -CPUs 2 > phylotype.result

done
```

</div>

Una vez que todo esto está listo, procedemos con la evaluación y
visualización de *contigs* y *bins*.

</div>

<div id="visualizacion-de-bins" class="section level1">

# <span class="header-section-number">4</span> Visualización de *bins*

Para visualizar la cohesión de los *bins*, usaremos las características
que hablamos más arriba que definen a los *bins*: **cobertura y
composición**. Comenzamos graficando las posiciones de cada *contig*
basándonos en cobertura y composición, y finalmente visualizamos los
diferentes *bins*.

La cobertura se expresa como número de reads mapeads por cada *contig* y
la composición según el porcentaje de GC de cada *contig*.

<div id="instalar-y-cargar-las-paquetes-de-r" class="section level2">

## <span class="header-section-number">4.1</span> Instalar y cargar las paquetes de R

Para este tutorial usaremos los paquetes `seqinr` para cargar los
archivos FASTA y obtener el contenido GC, y `plyr` para manipular las
tablas resultantes.

  - Primero instalamos los paquetes:

<div class="sourceCode">

``` sourceCode r
install.packages("seqinr")
install.packages("plyr")
install.packages("gplots")
```

</div>

  - Luego cargamos los paquetes:

<div class="sourceCode">

``` sourceCode r
library(seqinr)
library(plyr)
library(gplots)
```

</div>

</div>

<div id="cargar-archivos-de-entrada" class="section level2">

## <span class="header-section-number">4.2</span> Cargar archivos de entrada

Ahora que los paquetes están cargados, podemos cargar los datos de
entrada. Necesitas **descargar y descomprimir** el directorio de datos
desde este
[**link**](https://www.dropbox.com/s/vbbdrnswhwetgw1/mags_input_files.zip?dl=0)
y definir la ruta de directorios hasta los archivos de entrada.

<div class="sourceCode">

``` sourceCode r
base_path <- "path/to/base/"
```

</div>

<div class="sourceCode">

``` sourceCode r
base_path <- "./"
```

</div>

Primero que todo, definimos todos los directorios en los cuales los
datos están ubicados:

<div class="sourceCode">

``` sourceCode r
contig_directory <- paste( base_path, "input_files/assembly/", sep="")
stat_directoy <- paste( base_path, "input_files/bam/", sep="")
maxbin_directory <- paste( base_path, "input_files/bins/maxbin/", sep="")
metabat_directory <- paste( base_path, "input_files/bins/metabat/", sep="")
amphora_directory <- paste( base_path, "input_files/amphora/", sep="")
```

</div>

Luego, necesitamos la información de **cobertura y contenido GC para
cada *contig***.

<div id="obteniendo-el-contenido-gc" class="section level3">

### <span class="header-section-number">4.2.1</span> Obteniendo el contenido GC

El contenido GC puede ser calculado en R usando el paquete `seqinr` para
cada *contig*. Para hacer esto, necesitamos leer los contigs en R usando
la función `read.fasta`. Entonces cargamos los *contigs* a la sesión
actual de R para computar el GC. Usaremos solo contigs más largos que 1
kb.

  - Definimos la ruta a los *contigs* en formato FASTA:

<div class="sourceCode">

``` sourceCode r
contig_path <- paste(contig_directory , "contigs_1000.fasta", sep="")
contig_path
```

</div>

    ## [1] "~/Dropbox/CastroLab_database/workshops_data/mags_input_files/assembly/contigs_1000.fasta"

  - Ahora, cargamos el FASTA en un objeto llamado `contigs`:

<div class="sourceCode">

``` sourceCode r
contigs <- read.fasta(file = contig_path)
```

</div>

Ahora todos los contigs están en el objeto *contigs*. Necesitamos crear
una tabla que muestre el nombre del *contig* y su correspondiente
contenido GC. Para esto primero creamos una tabla vacía de las
dimensiones necesarias, y luego computamos el contenido GC *contig* por
*contig*. La tabla necesita dos columnas, una para el nombre del contig
y otra para el contenido GC, y tantas filas como *contigs*.

  - Vamos a calcular la longitud de un vector que contiene los nombres
    de los *contigs* y almacenaremos ese número en un objeto. Con esto
    creamos la tabla:

<div class="sourceCode">

``` sourceCode r
contig_len <- length(names(contigs))
gc_table <- as.data.frame(matrix(ncol=2, nrow=contig_len))
colnames(gc_table) <- c("contig","gc_content")
```

</div>

Para computar el contenido GC *contig* por *contig* y agregarlo a la
tabla, necesitamos usar un bucle (*loop*) de tipo for que leerá todas
las secuencias. De nuevo, usamos el objeto que contiene el número de
contigs (*contig\_len*) para determinar cuántas veces el bucle se
ejecutará:

<div class="sourceCode">

``` sourceCode r
for (i in c(1:contig_len))
{
gc_table[i,1] <- names(contigs)[i]
gc_table[i,2] <- GC(contigs[[i]])
}
```

</div>

Ahora tenemos una tabla con contenido GC para cada *contig*. Nos falta
la cobertura.

</div>

<div id="obteniendo-la-cobertura" class="section level3">

### <span class="header-section-number">4.2.2</span> Obteniendo la cobertura

Para obtener los valores de cobertura, necesitamos usar información de
`samtools` `idxstats` que está en el directorio llamado
`stat_directoy/`.

  - Primero, ya que hay un archivo por muestra, necesitamos obtener una
    lista con todos los archivos a leer:

<div class="sourceCode">

``` sourceCode r
stat_list <- list.files(stat_directoy, pattern = "\\.idxstat$")
stat_list
```

</div>

    ## [1] "G1-1.idxstat" "G1-2.idxstat" "G1-3.idxstat" "G2-1.idxstat"
    ## [5] "G2-2.idxstat" "G2-3.idxstat"

El archivo `.idzstat` viene en forma de tabla sin encabezado y contiene
los nombres de los *contigs*, la longitud del *contig*, y el número de
*reads* mapeadas y no mapeadas. El primer paso es leer la tabla y darle
nombres a las columnas. Luego, necesitamos normalizar el número de
*reads* mapeadas por la longitud del *contig* y así obtener el valor de
cobertura. Esto es porque *contigs* más largos van a tener más *reads*
mapeadas que *contigs* más cortos pero podrían tener la misma
abundancia.

  - Una vez que tenemos esto, hacemos una tabla que contenga el nombre
    del *contig* y el número de reads normalizado para cada muestra. De
    nuevo, usamos un bucle for para iterar sobre todos los archivos
    `.idxstat`:

<div class="sourceCode">

``` sourceCode r
for (i in c(1:length(stat_list)))
{
sample_stat <- read.table(paste(stat_directoy,stat_list[i], sep=""), header = F)
colnames(sample_stat) <- c("contig","length","mapped","unmapped")
sample_stat$count <- sample_stat$mapped / sample_stat$length
colnames(sample_stat)[5] <- strsplit(stat_list[i], "\\.")[[1]][1]
if (i == 1)
 {
  table_stat <- sample_stat[,c(1,5)]
 }
else
 {
  table_stat <- merge(table_stat, sample_stat[,c(1,5)])
 }
}
```

</div>

  - Revisemos que la tabla sea lo que buscábamos:

<div class="sourceCode">

``` sourceCode r
str(table_stat)
```

</div>

    ## 'data.frame':    1365347 obs. of  7 variables:
    ##  $ contig: Factor w/ 1365347 levels "*","NODE_1_length_200697_cov_10.033577",..: 1 2 3 4 5 6 7 8 9 10 ...
    ##  $ G1-1  : num  NaN 0.032761 0.031195 0.032399 0.000398 ...
    ##  $ G1-2  : num  NaN 0.03925 0.03598 0.03947 0.00053 ...
    ##  $ G1-3  : num  NaN 0.02878 0.027853 0.029398 0.000928 ...
    ##  $ G2-1  : num  NaN 9.97e-06 2.57e-05 3.57e-05 1.87e-02 ...
    ##  $ G2-2  : num  NaN 1.49e-05 5.14e-05 0.00 3.14e-02 ...
    ##  $ G2-3  : num  NaN 0 0 0 0.0172 ...

Como se puede ver, los nombres de las columnas de las muestras contienen
un `-`, que normalmente no son bien manejados por R, ya que cuando los
mencionamos en la consola R los interpreta como una sustracción.
Entonces necesitamos un paso adicional para poder reemplazar ese
caracter por algo que R maneje mejor, por ejemplo reempalzando los `-`
por `_`.

<div class="sourceCode">

``` sourceCode r
colnames(table_stat) <- gsub("-","_",colnames(table_stat))
```

</div>

Finalmente, sería ideal una tabla que contenga información de la tabla
de contenido GC, la tabla de cuentas o número de *reads*, y el número
total de *reads*.

  - Usando lo que aprendimos en la unidad [Introducción R, manipulación
    y visualización en
    R](http://www.castrolab.org/isme/introR/introR.html), intentemos
    crear esta tabla en un objeto llamado `table_all` que tenga una
    columna para el número total de *reads* llamado `all`.

  - Una vez que esto está OK, usamos `str()` para verificar que la tabla
    resultante es lo que esperábamos.

<div class="sourceCode">

``` sourceCode r
str(table_all)
```

</div>

    ## 'data.frame':    70180 obs. of  9 variables:
    ##  $ contig    : chr  "NODE_1_length_200697_cov_10.033577" "NODE_10_length_77801_cov_9.055193" "NODE_100_length_27995_cov_9.999749" "NODE_1000_length_7547_cov_5.887213" ...
    ##  $ gc_content: num  0.533 0.564 0.543 0.666 0.664 ...
    ##  $ G1_1      : num  0.032761 0.031195 0.032399 0.000398 0 ...
    ##  $ G1_2      : num  0.03925 0.03598 0.03947 0.00053 0 ...
    ##  $ G1_3      : num  0.02878 0.027853 0.029398 0.000928 0 ...
    ##  $ G2_1      : num  9.97e-06 2.57e-05 3.57e-05 1.87e-02 1.38e-02 ...
    ##  $ G2_2      : num  1.49e-05 5.14e-05 0.00 3.14e-02 1.51e-02 ...
    ##  $ G2_3      : num  0 0 0 0.0172 0.0088 ...
    ##  $ all       : num  0.1008 0.0951 0.1013 0.0692 0.0377 ...

Ahora tenemos toda la información para hacer el gráfico base que muestre
cada *contig* en función de su contenido GC y su cobertura.

  - Miremos el gráfico base.

<div class="sourceCode">

``` sourceCode r
plot(table_all$gc_content, table_all$all, pch=20, xlab="GC content", ylab="abundance")
```

</div>

![](mags_files/figure-html/unnamed-chunk-24-1.png)

Debido a la distribución de *reads*/cuentas, necesitamos hacer una
transformación para observar las diferencias en cobertura.

  - Utilizamos entonces una escala logarítmica para una mejor
    visualización:

<div class="sourceCode">

``` sourceCode r
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
```

</div>

![](mags_files/figure-html/unnamed-chunk-25-1.png)

Para visualizar los *bins*, vamos a colorear todos los contigs según el
*bin* al cuál correspondan. Para ser capaz de hacer esto, necesitamos
una tabla que contenga los nombres de los *contigs* y el *bin* al cual
están asociados en otra columna. Como utilizamos dos métodos de
*binning*, necesitaremos una columna para cada método.

</div>

<div id="obteniendo-la-informacion-de-los-bins" class="section level3">

### <span class="header-section-number">4.2.3</span> Obteniendo la información de los *bins*

Ya que los *bins* están en formato FASTA, los podemos usar para extraer
los nombres de los *contigs* para cada *bin*. Para esto, necesitamos
leer los archivos en R y guardarlos en un objeto, y guardar solamente
las líneas que corresponden a los nombres de los *contigs*.

Vamos a usar la funcción `readLines()` para leer el archivo y la función
`grep(pattern, object)` para seleccionar las líneas deseadas, basándose
en un patrón. La función va a retornar el número de líneas a
seleccionar, lo cual usaremos para seleccionar un subconjunto de líneas.

  - Comencemos con los bins de `MaxBin`:

<div class="sourceCode">

``` sourceCode r
bin <- readLines(paste(maxbin_directory, "maxbin_6samples.001.fasta", sep=""))
pattern="^>"
contig_nb <- grep(pattern, bin)
bin_contigs <- bin[contig_nb]
bin_contigs <- gsub(">","",bin_contigs)
assign("maxbin_6samples.001.fasta", bin_contigs)
```

</div>

De esta forma, deberíamos obtener un objeto con el nombre del *bin*
`maxbin_6samples.001.fasta`, que contiene una lista con todos los
*contigs* que incluye.

> **Basándose en lo que hicimos en la sección previa, modifica el código
> de tal forma que lo puedas correr para todos los *bins* en el
> directorio de `maxbin`.**

> **Una vez que lo has hecho para el directorio `maxbin`, haz lo mismo
> para el de `metabat`.**

Ahora estamos un paso más cerca para fabricar la tabla que necesitamos,
con los nombres de los *contigs* y su nombre de *bin* correspondiente en
dos columnas, una para cada programa.

  - Para hacer la tabla, primero creamos una tabla vacía, después
    agregamos los nombres de los *contigs*, y finalmente para cada
    *bin*, agregamos el nombre del *bin*.

<div class="sourceCode">

``` sourceCode r
contig_to_bin <- as.data.frame(matrix(ncol = 3, nrow = contig_len))
colnames(contig_to_bin) <- c("contig","maxbin","metabat")
contig_to_bin$contig <- names(contigs)

maxbin_list <- list.files(maxbin_directory)
metabat_list <- list.files(metabat_directory)

for (i in c(1:length(maxbin_list)))
{
bin <- get(maxbin_list[i])
contig_to_bin$maxbin[contig_to_bin$contig %in% bin] <- maxbin_list[i]
}

for (i in c(1:length(metabat_list)))
{
bin <- get(metabat_list[i])
contig_to_bin$metabat[contig_to_bin$contig %in% bin] <- metabat_list[i]
}

str(contig_to_bin)
```

</div>

    ## 'data.frame':    70180 obs. of  3 variables:
    ##  $ contig : chr  "NODE_1_length_200697_cov_10.033577" "NODE_2_length_102735_cov_9.657090" "NODE_3_length_99345_cov_9.186706" "NODE_4_length_95814_cov_9.273468" ...
    ##  $ maxbin : chr  "maxbin_6samples.002.fasta" "maxbin_6samples.045.fasta" "maxbin_6samples.045.fasta" "maxbin_6samples.045.fasta" ...
    ##  $ metabat: chr  "metabat.18.fa" "metabat.21.fa" "metabat.21.fa" "metabat.21.fa" ...

Debido a que esta tabla contiene 70180, no es muy útil explorar las
similitudes entre *bins* creados por distintos programas.

  - Antes de comenzar con los pasos de visualización, vamos a crear otra
    tabla que nos va a mostrar la cantidad de *contigs* que se
    superponen entre ambos programas:

<div class="sourceCode">

``` sourceCode r
overlap_table <- contig_to_bin[,c(2,3)]
overlap_table <- ddply(overlap_table,.(maxbin,metabat),nrow)
colnames(overlap_table)[3] <- "contigs_nb"

head(overlap_table)
```

</div>

    ##                      maxbin       metabat contigs_nb
    ## 1 maxbin_6samples.001.fasta metabat.12.fa         19
    ## 2 maxbin_6samples.001.fasta metabat.13.fa         34
    ## 3 maxbin_6samples.001.fasta metabat.19.fa        465
    ## 4 maxbin_6samples.001.fasta          <NA>        562
    ## 5 maxbin_6samples.002.fasta metabat.11.fa         38
    ## 6 maxbin_6samples.002.fasta metabat.18.fa         83

</div>

<div id="visualizacion-de-los-bins" class="section level3">

### <span class="header-section-number">4.2.4</span> Visualización de los *bins*

  - Vamos a comenzar con una visualización simple de los *bins*
    individuales en el gráfico principal:

<div class="sourceCode">

``` sourceCode r
bin <- contig_to_bin$contig[contig_to_bin$maxbin %in% maxbin_list[1]]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% bin ], log(table_all$all[table_all$contig %in% bin ]), col="yellow", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin 1"), 
        col=c("yellow"), 
        pch=20, merge=FALSE )
```

</div>

![](mags_files/figure-html/unnamed-chunk-31-1.png)

<div class="sourceCode">

``` sourceCode r
bin <- contig_to_bin$contig[contig_to_bin$metabat %in% metabat_list[1]]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% bin ], log(table_all$all[table_all$contig %in% bin ]), col="yellow", pch=20)
legend( x="bottomleft", 
        legend=c("metabat 1"), 
        col=c("yellow"), 
        pch=20, merge=FALSE )
```

</div>

![](mags_files/figure-html/unnamed-chunk-32-1.png)

> Puedes explorar los *bins* cambiando el nombre del *bin* según la
> lista con nombres. También se pueden cambiar los colores.

</div>

<div id="mejoramiento-de-los-bins" class="section level3">

### <span class="header-section-number">4.2.5</span> Mejoramiento de los *bins*

  - Vamos a comenzar con el primer *bin* de MaxBin
    `maxbin_6samples.001.fasta`.

<div class="sourceCode">

``` sourceCode r
bin <- contig_to_bin$contig[contig_to_bin$maxbin %in% maxbin_list[1]]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% bin ], log(table_all$all[table_all$contig %in% bin ]), col="yellow", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.001.fasta"), 
        col=c("yellow"), 
        pch=20, merge=FALSE )
```

</div>

![](mags_files/figure-html/unnamed-chunk-33-1.png)

Como podemos ver, graficamos la distribución de *contigs* basándose en
el contenido GC y en la cobertura y vemos que la mayoría de los
*contigs* forman grupos compactos mientras que otros tienen bajo
contenido GC y alta cobertura. Ya que esos *contigs* parecen *outliers*
con respecto al resto, podrían potencialmente no pertenecer al *bin*.
Vamos a crear un objeto que contenga solamente esos *contigs* para
seguir examinándolos.

  - Vamos a seleccionar los *contigs* que pertenecen al *bin*
    `maxbin_6samples.001.fasta` y que tienen un contenido GC de menos de
    0.6. Además agreguémos color a esos contigs para poder observarlo
    mejor:

<div class="sourceCode">

``` sourceCode r
contigs_low_gc <- table_all[table_all$contig %in% maxbin_6samples.001.fasta & table_all$gc_content < 0.6,1]

bin <- contig_to_bin$contig[contig_to_bin$maxbin %in% maxbin_list[1]]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% bin ], log(table_all$all[table_all$contig %in% bin ]), col="yellow", pch=20)
points(table_all$gc_content[table_all$contig %in% contigs_low_gc ], log(table_all$all[table_all$contig %in% contigs_low_gc ]), col="blue", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.001.fasta", "outliers (maxbin_6samples.001.fasta)"), 
        col=c("yellow","blue"), 
        pch=20, merge=FALSE )
```

</div>

![](mags_files/figure-html/unnamed-chunk-34-1.png)

  - Ahora, como podemos ver en la tabla `overlap_table`, el otro
    programa generó un *bin* que incluye muchos de los mismos *contigs*
    que `maxbin_6samples.001.fasta`, el cuál es `metabat.19.fa`:

<div class="sourceCode">

``` sourceCode r
overlap_table[overlap_table$maxbin %in% "maxbin_6samples.001.fasta",]
```

</div>

    ##                      maxbin       metabat contigs_nb
    ## 1 maxbin_6samples.001.fasta metabat.12.fa         19
    ## 2 maxbin_6samples.001.fasta metabat.13.fa         34
    ## 3 maxbin_6samples.001.fasta metabat.19.fa        465
    ## 4 maxbin_6samples.001.fasta          <NA>        562

  - Veamos cómo ambos *bins* se superponen:

<div class="sourceCode">

``` sourceCode r
bin1 <- contig_to_bin$contig[contig_to_bin$maxbin %in% "maxbin_6samples.001.fasta"]
bin2 <- contig_to_bin$contig[contig_to_bin$metabat %in% "metabat.19.fa"]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")

points(table_all$gc_content[table_all$contig %in% bin1 ], log(table_all$all[table_all$contig %in% bin1 ]), col="yellow", pch=20)

points(table_all$gc_content[table_all$contig %in% bin2 ], log(table_all$all[table_all$contig %in% bin2 ]), col="red", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.001.fasta", "metabat.19.fa"), 
        col=c("yellow","red"), 
        pch=20, merge=FALSE )
```

</div>

![](mags_files/figure-html/unnamed-chunk-36-1.png)

Podemos ver que el *bin* de MetaBat parece más compacto que el de
MaxBin. Sin embargo, hay información que no estamos usando aún en esta
evaluación. La abundancia o cobertura proviene de la suma de seis
muestras independientes. Esto significa que hay más información que es
muestra-específica que no se ve por la manera en que hemos graficado.
Esta información podría ser relevante para el proceso de *binning*.

  - Para revelar esto, dividamos la información en nuestro gráfico en
    seis gráficos independientes:

<div class="sourceCode">

``` sourceCode r
par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% bin1 ,2], log(table_all[table_all$contig %in% bin1,i]), col="yellow", pch=20)
points(table_all[table_all$contig %in% bin2 ,2], log(table_all[table_all$contig %in% bin2,i]), col="red", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.001.fasta", "metabat.19.fa"), 
        col=c("yellow","red"), 
        pch=20, merge=FALSE, cex = 1.3 )
}
```

</div>

![](images/plot_1.png)

Podemos ver algo nuevo aquí. Aunque los *bins* se ven mayoritariamente
compactos en el primer gráfico, en estos nuevos gráficos vemos que las
formas cambian drásticamente. Esto es porque las variaciones en
abundancia y/o en cobertura se enmascaran cuando se suman las
abundancias de otras muestras, especialmente cuando graficamos en escala
logarítmica.

En el bin `metabat.19.fa` (en rojo), podemos ver que en las primeras
tres muestras algunos *contigs* parecen tener más baja cobertura que los
demás, mientras que en las tres muestras de abajo el *bin* aparece
dividido en *contigs* de alta y baja cobertura.

  - Vamos a comenzar por enfocarnos en los *contigs* con baja cobertura
    en las primeras muestras. Tal como hicimos antes, vamos a generar un
    objeto con esos *contigs* y vamos a usar un color para destacarlos:

<div class="sourceCode">

``` sourceCode r
contigs_low_cov <- table_all[table_all$contig %in% metabat.19.fa & log(table_all$G1_1) < -4 ,1]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]) , cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% bin1 ,2], log(table_all[table_all$contig %in% bin1,i]), col="yellow", pch=20)
points(table_all[table_all$contig %in% bin2 ,2], log(table_all[table_all$contig %in% bin2,i]), col="red", pch=20)
points(table_all[table_all$contig %in% contigs_low_gc ,2], log(table_all[table_all$contig %in% contigs_low_gc ,i]), col="blue", pch=20)
points(table_all[table_all$contig %in%  contigs_low_cov ,2], log(table_all[table_all$contig %in% contigs_low_cov ,i]), col="green", pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.001.fasta", "outliers (maxbin_6samples.001.fasta)","metabat.19.fa","outliers (metabat.19.fa)"), 
        col=c("yellow","blue", "red", "green"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_2.png)

Ahora podemos ver que los *contigs* de baja cobertura en las primeras
tres muestras son los mismos que tienen más abundancias en las tres
últimas muestras. Como se comportan tan direfentemente al resto de los
contigs, es más seguro removerlos del *bin* para evitar contaminación.

Este pequeño ejercicio muestra la importancia de considerar la cobertura
por muestra para tomar decisiones respecto a un *bin*. Ahora, vamos a
remover los *outliers* azules y verdes, y combinar el resto en un nuevo
y más cohesionado *bin*:

<div class="sourceCode">

``` sourceCode r
remove <- unique(c(contigs_low_gc,contigs_low_cov))
new_bin <- unique(c(bin1,bin2))
new_bin <- new_bin[! new_bin %in% remove]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% new_bin ,2], log(table_all[table_all$contig %in% new_bin,i]), col="yellow", pch=20)

legend( x="bottomleft", 
        legend=c("new_bin"), 
        col=c("yellow"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_3.png)

Ahora que hemos mejorado nuestro primer *bin*, echemos un vistazo a otro
*bin*: `maxbin_6samples.002.fasta`

> **Revisa la tabla que muestra la superposición de *contigs* entre
> programas para ver con qué otro *bin* comparte *contigs*.**

> **Genera un gráfico que muestre ambos *bins* coloreados, con un
> gráfico para cada muestra.**

![](images/plot_4.png)

Podemos ver que el primer *bin*, `maxbin_6samples.002.fasta`, parece
dividido en dos, un *bin* arriba que se superpone con el segundo *bin*,
`metabat.18.fa`, y otro *bin*. Podemos también ver que muy pocos
*contigs* aparecen en las tres últimas muestras, lo que sugiere que la
abundancia de estos *contigs* es cercana a cero.

  - Basándonos en las superposiciones de *bins* y en la separación entre
    los dos *clusters* de *contigs*, vamos a separar el primer y segundo
    *bin* para estudiarlos más en detalle e individualmente.

<div class="sourceCode">

``` sourceCode r
new_bin2 <- table_all[table_all$contig %in% maxbin_6samples.002.fasta & log(table_all$G1_1) < -4 ,1]
new_bin3 <- maxbin_6samples.002.fasta[! maxbin_6samples.002.fasta %in% new_bin2]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% new_bin2 ,2], log(table_all[table_all$contig %in% new_bin2,i]), col="dodgerblue", pch=20)
points(table_all[table_all$contig %in% new_bin3 ,2], log(table_all[table_all$contig %in% new_bin3,i]), col="cadetblue1", pch=20)

points(table_all[table_all$contig %in% bin4 ,2], log(table_all[table_all$contig %in% bin4,i]), col="darkorchid1", pch=20)

legend( x="bottomleft", 
        legend=c("new_bin2", "new_bin3","metabat.18.fa"), 
        col=c("dodgerblue","cadetblue1","darkorchid1"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_5.png)

  - Ahora podemos unir `metabat.18.fa` con `new_bin3`:

<div class="sourceCode">

``` sourceCode r
new_bin3 <- unique(c(new_bin3,metabat.18.fa))

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% new_bin2 ,2], log(table_all[table_all$contig %in% new_bin2,i]), col="dodgerblue", pch=20)
points(table_all[table_all$contig %in% new_bin3 ,2], log(table_all[table_all$contig %in% new_bin3,i]), col="darkorchid1", pch=20)
legend( x="bottomleft", 
        legend=c("new_bin2", "new_bin3"), 
        col=c("dodgerblue","darkorchid1"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_6.png)

Ahora, necesitamos determinar qué haremos con los *contigs* que tienen
una abundancia distinta de cero en las tres últimas muestras.

  - Comencemos por crear un objeto con esos *contigs* en al menos una de
    las tres últimas muestras, para luego destacarlos con un color
    diferente:

<div class="sourceCode">

``` sourceCode r
contigs_non_zero <- table_all[log(table_all$G2_1) > -Inf | log(table_all$G2_2) > -Inf | log(table_all$G2_3) > -Inf  ,1]

contigs_non_zero_2 <- contigs_non_zero[contigs_non_zero %in% new_bin2]
contigs_non_zero_3 <- contigs_non_zero[contigs_non_zero %in% new_bin3]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)
points(table_all[table_all$contig %in% new_bin2 ,2], log(table_all[table_all$contig %in% new_bin2,i]), col="dodgerblue", pch=20)
points(table_all[table_all$contig %in% new_bin3 ,2], log(table_all[table_all$contig %in% new_bin3,i]), col="darkorchid1", pch=20)
points(table_all[table_all$contig %in% contigs_non_zero_2 ,2], log(table_all[table_all$contig %in% contigs_non_zero_2,i]), col="green", pch=20)
points(table_all[table_all$contig %in% contigs_non_zero_3 ,2], log(table_all[table_all$contig %in% contigs_non_zero_3,i]), col="red", pch=20)

legend( x="bottomleft", 
        legend=c("new_bin2", "new_bin3", "non_zero (new_bin2)", "non_zero (new_bin3)"), 
        col=c("dodgerblue","darkorchid1", "green","red"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_7.png)

Como se aprecia en el gráfico, los *contigs* con abundancia distinta a
cero en las tres últimas muestras están dentro del grupo de *contigs*
como se ve en las otras muestras.

En este tipo de situaciones, uno tiene que decidir si es más conservador
y dejar la menor cantidad de potenciales contaminantes (con el riesgo de
obtener un genoma incompleto), o tratar de obtener el genoma más
completo pero corriendo el riesgo de tomar algún *contig* que no
corresponda a ese genoma. Sin embargo, debemos tener en mente que estos
datos son preliminares, con baja cobertura. Además, los *bins*
seleccionados para explorar deben ser los de mejor calidad, con alta
completitud de genoma y virtualmente sin contaminación. Finalmente,
recuperar genomas de metagenomas o MAGs no es una tarea sencilla ni
automática, por lo tanto la calidad de los datos, la profundidad de
secuenciación, y la longitud de los contigs son factores muy relevantes.

</div>

<div id="agregando-informacion-extra" class="section level3">

### <span class="header-section-number">4.2.6</span> Agregando información extra

Aunque a veces trabajamos con MAGs para no tener que usar bases de
datos, estas bases de datos todavía nos pueden ser de ayuda para evaluar
la calidad de los *bins*, mejorar su composición, y agregar información
taxonómica si es posible.

Para poder usar este tipo de información, ejecutamos previamente el
programa `AMPHORA2`, un programa que busca marcadores filogenéticos de
procariontes para inferir taxonomía. Los resultados de este programa nos
ayudarán a evaluar si contigs con la misma información taxonómica
pertenecen al mismo *bin*. Esto complementa lo que hemos aprendido hasta
ahora con la visualización de cobertura y contenido GC.

</div>

</div>

<div id="obteniendo-informacion-taxonomica" class="section level2">

## <span class="header-section-number">4.3</span> Obteniendo información taxonómica

Vamos a leer los resultados de `AMPHORA2` desde su directorio. Estos
resultados están almacenados en una tabla con encabezado. Si comparamos
los nombres de los *contigs* de la tabla de `AMPHORA2` con las otras
tablas, vamos a ver que `AMPHORA2` agrega un número a cada entrada
porque puede haber más de un marcador por *contig*. \* Para poder usar
estos resultados, necesitamos hacer coincidir los nombres de los
*contigs* entre las tablas, removiendo lo que agrega `AMPHORA2`.

<div class="sourceCode">

``` sourceCode r
amphora_results <- read.table( paste(amphora_directory, "phylotype.result", sep=""), header = T , sep="\t" , fill=T)
amphora_results[,1] <- as.character(amphora_results[,1])
amphora_results[,1] <- gsub("(.*)_.*","\\1",amphora_results[,1])
```

</div>

  - Para confirmar si hay más de un marcador por *contig*, necesitamos
    comparar la longitud de la columna *contigs* en la tabla
    `amphora_results` en contra de la longitud de los elementos únicos
    en la misma columna:

<div class="sourceCode">

``` sourceCode r
length(amphora_results$Query)
```

</div>

    ## [1] 1524

<div class="sourceCode">

``` sourceCode r
length(unique(amphora_results$Query))
```

</div>

    ## [1] 1039

Vemos que las longitudes difieren, lo que indica que algunos contigs
tienen más de un marcador con más de una identificación. Sin embargo,
queremos una identificación por *contig* así que necesitamos resolver
esas instancias de *contigs* con más de un marcador.

  - Vamos a tomar cada uno de esos *contigs* desde la tabla
    `amphora_results` y vamos a transferir la identificación a otra
    tabla. Hay tres posibilidades: el *contig* tiene un único marcador
    por lo que se transfiere una sola identificación; el *contig* tiene
    más de un marcador pero todos los marcadores indican la misma
    taxonomía por lo que colapsamos las filas en la nueva tabla; y
    finalmente, los diferentes marcadores indican diferente taxonomía,
    en cual caso nos quedamos con el nivel taxonómico donde coinciden y
    agregamos NAs donde corresponda. Vamos a eliminar los valores de
    porcentaje para evitar errores.

<div class="sourceCode">

``` sourceCode r
amphora_names <- amphora_results
for (i in c(3:9))
{
amphora_names[,i] <- as.character(amphora_names[,i])
amphora_names[,i] <- vapply(strsplit(amphora_names[,i], "(", fixed = TRUE), "[", "", 1)
}

unique_contigs <- unique(amphora_names$Query)
unique_list <- vector()
  
table_markers_resolved <- as.data.frame(matrix(ncol=9, nrow=length(unique_contigs)))
colnames(table_markers_resolved) <- colnames(amphora_names)
for (i in c(1:length(unique_contigs)))
{
contig <- unique_contigs[i]
if(length(amphora_names[amphora_names$Query %in% contig,1]) == 1 )
 {
 table_markers_resolved[i,] <- amphora_names[amphora_names$Query %in% contig,]
 } else
 {
 tmp_table <- amphora_names[amphora_names$Query %in% contig,]
 table_markers_resolved$Query[i] <- contig
 table_markers_resolved$Marker[i] <- "multiple"
 for (j in c(3:9))
  {
   if ( length(unique(tmp_table[,j])) == 1)
   {
    table_markers_resolved[i,j] <- unique(tmp_table[,j])
   } else
   {
    table_markers_resolved[i,j] <- NA
   }
  }
 }
}
```

</div>

  - Ahora deberíamos haber obtenido una tabla con una entrada por
    *contig*. De nuevo, revisemos que esto sea así al comparar la
    longitud de las tablas:

<div class="sourceCode">

``` sourceCode r
length(table_markers_resolved$Query)
```

</div>

    ## [1] 1039

<div class="sourceCode">

``` sourceCode r
length(unique(table_markers_resolved$Query))
```

</div>

    ## [1] 1039

Ahora tenemos una tabla que muestra algunos *contigs* con su respectiva
identificación. Ahora generemos una tabla que tenga las identificaciones
taxonómicas pero por *bin*.

</div>

<div id="visualizar-grupos-taxonomicos" class="section level2">

## <span class="header-section-number">4.4</span> Visualizar grupos taxonómicos

De la misma forma en que visualizamos los *bins*, coloreando los
*contigs* que pertenecían a cierto *bin*, vamos a hacer los mismo pero
con los grupos taxonómicos.

  - Primero, vamos a crear un objeto con los nombres de los *contigs*
    asociados a un grupo taxonómico, para luego colorearlos en el
    gráfico base:

<div class="sourceCode">

``` sourceCode r
fam_verru <- table_markers_resolved$Query[which(table_markers_resolved$Family == "Verrucomicrobiaceae")]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% fam_verru ], log(table_all$all[table_all$contig %in% fam_verru ]), col="yellow", pch=20)
```

</div>

![](mags_files/figure-html/unnamed-chunk-55-1.png)

<div class="sourceCode">

``` sourceCode r
fam_conexi <- table_markers_resolved$Query[which(table_markers_resolved$Family == "Conexibacteraceae")]
plot(table_all$gc_content, log(table_all$all), pch=20, xlab="GC content", ylab="abundance (log)")
points(table_all$gc_content[table_all$contig %in% fam_conexi ], log(table_all$all[table_all$contig %in% fam_conexi ]), col="yellow", pch=20)
```

</div>

![](mags_files/figure-html/unnamed-chunk-55-2.png)

Podemos ver que mientras la mayoría de los *contigs* se agrupan en la
misma área del gráfico, estos no forman una agruoación tan compacta como
en el caso de los *bins*. Esto es esperado ya que una baja cantidad de
*contigs* contiene información taxonómica. Muchos *contigs* no tenían
ninguna clase de identificación taxonómica.

> **De esta misma manera, visualiza otros grupos taxonómicos, por
> ejemplo género o especie.**

</div>

<div id="usando-marcadores-para-mejorar-los-bins" class="section level2">

## <span class="header-section-number">4.5</span> Usando marcadores para mejorar los *bins*

Ahora, si visualizamos los *bins* y los marcadores al mismo tiempo,
podemos usar la información extra para tomar una desición con respecto a
cómo vamos a manejar los *bins*.

  - Como siempre, primero creamos una tabla que combine la información
    de los *bins* y de los marcadores:

<div class="sourceCode">

``` sourceCode r
bin_markers_table <- merge(contig_to_bin[,c(1:3)] , table_markers_resolved, by.x = "contig", by.y="Query")
```

</div>

  - Comencemos con el *bin* `maxbin_6samples.033.fasta`. Primero veamos
    si alguno de sus *contigs* tiene información taxonómica:

<div class="sourceCode">

``` sourceCode r
bin_markers_table[which(bin_markers_table$maxbin == "maxbin_6samples.033.fasta" ),]
```

</div>

    ##                                  contig                    maxbin
    ## 23  NODE_10864_length_2294_cov_1.762394 maxbin_6samples.033.fasta
    ## 48  NODE_12066_length_2182_cov_2.621533 maxbin_6samples.033.fasta
    ## 55  NODE_12125_length_2177_cov_2.284637 maxbin_6samples.033.fasta
    ## 74  NODE_12727_length_2125_cov_3.314976 maxbin_6samples.033.fasta
    ## 164 NODE_17079_length_1857_cov_1.734739 maxbin_6samples.033.fasta
    ## 206 NODE_18613_length_1784_cov_2.097166 maxbin_6samples.033.fasta
    ## 228 NODE_19672_length_1739_cov_2.425178 maxbin_6samples.033.fasta
    ## 249 NODE_20875_length_1694_cov_2.406345 maxbin_6samples.033.fasta
    ## 254 NODE_21149_length_1684_cov_2.442603 maxbin_6samples.033.fasta
    ## 388 NODE_30098_length_1437_cov_3.272069 maxbin_6samples.033.fasta
    ## 407 NODE_31205_length_1414_cov_2.531273 maxbin_6samples.033.fasta
    ## 411 NODE_31346_length_1411_cov_2.772124 maxbin_6samples.033.fasta
    ## 441 NODE_33183_length_1376_cov_2.800151 maxbin_6samples.033.fasta
    ## 442 NODE_33208_length_1376_cov_1.874338 maxbin_6samples.033.fasta
    ## 461 NODE_34434_length_1355_cov_2.738462 maxbin_6samples.033.fasta
    ## 501 NODE_36325_length_1325_cov_1.510236 maxbin_6samples.033.fasta
    ## 539 NODE_38482_length_1291_cov_1.766181 maxbin_6samples.033.fasta
    ## 566 NODE_39958_length_1270_cov_2.060082 maxbin_6samples.033.fasta
    ## 607 NODE_42441_length_1238_cov_1.911243 maxbin_6samples.033.fasta
    ## 641 NODE_44384_length_1214_cov_3.280414 maxbin_6samples.033.fasta
    ## 648 NODE_44978_length_1208_cov_1.472680 maxbin_6samples.033.fasta
    ## 669 NODE_46234_length_1193_cov_2.188049 maxbin_6samples.033.fasta
    ## 835 NODE_59282_length_1073_cov_1.355599 maxbin_6samples.033.fasta
    ## 873  NODE_6227_length_2980_cov_2.676581 maxbin_6samples.033.fasta
    ## 946 NODE_67665_length_1015_cov_1.400000 maxbin_6samples.033.fasta
    ## 967 NODE_69403_length_1004_cov_1.874605 maxbin_6samples.033.fasta
    ## 968 NODE_69483_length_1004_cov_1.237092 maxbin_6samples.033.fasta
    ## 992  NODE_7532_length_2725_cov_2.530712 maxbin_6samples.033.fasta
    ##           metabat   Marker Superkingdom          Phylum
    ## 23           <NA>        6     Bacteria Verrucomicrobia
    ## 48           <NA>       18     Bacteria Verrucomicrobia
    ## 55           <NA> multiple     Bacteria Verrucomicrobia
    ## 74           <NA>        3     Bacteria Verrucomicrobia
    ## 164          <NA> multiple     Bacteria Verrucomicrobia
    ## 206          <NA>        4     Bacteria Verrucomicrobia
    ## 228          <NA> multiple     Bacteria Verrucomicrobia
    ## 249          <NA>       13     Bacteria Verrucomicrobia
    ## 254          <NA>       28     Bacteria Verrucomicrobia
    ## 388          <NA> multiple     Bacteria  Proteobacteria
    ## 407          <NA>       27     Bacteria Verrucomicrobia
    ## 411          <NA> multiple     Bacteria Verrucomicrobia
    ## 441          <NA>       24     Bacteria Verrucomicrobia
    ## 442          <NA>        1     Bacteria Verrucomicrobia
    ## 461          <NA> multiple     Bacteria Verrucomicrobia
    ## 501          <NA> multiple     Bacteria Verrucomicrobia
    ## 539          <NA>       16     Bacteria  Proteobacteria
    ## 566          <NA> multiple     Bacteria            <NA>
    ## 607          <NA>       13     Bacteria Verrucomicrobia
    ## 641          <NA>       26     Bacteria Verrucomicrobia
    ## 648          <NA> multiple     Bacteria Verrucomicrobia
    ## 669          <NA>       29     Bacteria Verrucomicrobia
    ## 835          <NA>       31     Bacteria   Acidobacteria
    ## 873 metabat.15.fa        2     Bacteria Verrucomicrobia
    ## 946          <NA>       22     Bacteria   Acidobacteria
    ## 967          <NA>       12     Bacteria Verrucomicrobia
    ## 968          <NA>       31     Bacteria  Proteobacteria
    ## 992 metabat.15.fa        5     Bacteria Verrucomicrobia
    ##                   Class                   Order              Family
    ## 23     Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 48             Opitutae                    <NA>                <NA>
    ## 55     Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 74     Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 164                <NA>                    <NA>                <NA>
    ## 206    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 228                <NA>                    <NA>                <NA>
    ## 249 Methylacidiphilales    Methylacidiphilaceae   Methylacidiphilum
    ## 254    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 388  Betaproteobacteria                    <NA>                <NA>
    ## 407    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 411    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 441    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 442    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 461                <NA>                    <NA>                <NA>
    ## 501    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 539 Gammaproteobacteria         Xanthomonadales    Xanthomonadaceae
    ## 566                <NA>                    <NA>                <NA>
    ## 607 Methylacidiphilales    Methylacidiphilaceae   Methylacidiphilum
    ## 641            Opitutae                    <NA>                <NA>
    ## 648 Methylacidiphilales    Methylacidiphilaceae   Methylacidiphilum
    ## 669    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 835                <NA>                    <NA>                <NA>
    ## 873    Verrucomicrobiae      Verrucomicrobiales Verrucomicrobiaceae
    ## 946        Solibacteres          Solibacterales     Solibacteraceae
    ## 967            Opitutae                    <NA>                <NA>
    ## 968 Alphaproteobacteria Candidatus Pelagibacter                <NA>
    ## 992            Opitutae         Puniceicoccales    Puniceicoccaceae
    ##                            Genus                        Species
    ## 23                   Akkermansia        Akkermansia muciniphila
    ## 48                          <NA>                           <NA>
    ## 55                   Akkermansia        Akkermansia muciniphila
    ## 74                   Akkermansia        Akkermansia muciniphila
    ## 164                         <NA>                           <NA>
    ## 206                  Akkermansia        Akkermansia muciniphila
    ## 228                         <NA>                           <NA>
    ## 249 Methylacidiphilum infernorum                           <NA>
    ## 254                  Akkermansia        Akkermansia muciniphila
    ## 388                         <NA>                           <NA>
    ## 407                  Akkermansia        Akkermansia muciniphila
    ## 411                  Akkermansia        Akkermansia muciniphila
    ## 441                  Akkermansia        Akkermansia muciniphila
    ## 442                  Akkermansia        Akkermansia muciniphila
    ## 461                         <NA>                           <NA>
    ## 501                  Akkermansia        Akkermansia muciniphila
    ## 539            Pseudoxanthomonas   Pseudoxanthomonas suwonensis
    ## 566                         <NA>                           <NA>
    ## 607 Methylacidiphilum infernorum                           <NA>
    ## 641                         <NA>                           <NA>
    ## 648 Methylacidiphilum infernorum                           <NA>
    ## 669                  Akkermansia        Akkermansia muciniphila
    ## 835                         <NA>                           <NA>
    ## 873                  Akkermansia        Akkermansia muciniphila
    ## 946        Candidatus Solibacter Candidatus Solibacter usitatus
    ## 967                         <NA>                           <NA>
    ## 968                         <NA>                           <NA>
    ## 992             Coraliomargarita   Coraliomargarita akajimensis

Aparentemente la mayoría de los contigs apunta a la misma especie.

  - Grafiquemos el *bin* y la especie al mismo tiempo:

<div class="sourceCode">

``` sourceCode r
bin1 <- maxbin_6samples.033.fasta

sp <- "Akkermansia muciniphila"
cont_sp <- table_markers_resolved$Query[which(table_markers_resolved$Species %in% sp)]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)

points(table_all[table_all$contig %in% bin1 ,2], log(table_all[table_all$contig %in% bin1 ,i]), col="yellow", pch=20)
points(table_all[table_all$contig %in% cont_sp ,2], log(table_all[table_all$contig %in% cont_sp ,i]), col=rgb(1, 0, 0, 0.6), pch=20)

legend( x="bottomleft", 
        legend=c("maxbin_6samples.033.fasta", "Akkermansia muciniphila"), 
        col=c("yellow","red"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_8.png)

Aunque la mayoría de los *contigs* que corresponden a *Akkermansia
muciniphila* se superponen con el *bin*, algunos caen afuera lo que
sugiere que el *bin* podría no contener todos los *contigs* de esa
especie.

  - Veamos si hay otros *bins* con esa identificación de especie:

<div class="sourceCode">

``` sourceCode r
bin_markers_table[which(bin_markers_table$Species == "Akkermansia muciniphila" ),]
```

</div>

    ##                                   contig                    maxbin
    ## 23   NODE_10864_length_2294_cov_1.762394 maxbin_6samples.033.fasta
    ## 32   NODE_11152_length_2266_cov_2.471280 maxbin_6samples.044.fasta
    ## 33   NODE_11335_length_2248_cov_1.796626 maxbin_6samples.034.fasta
    ## 55   NODE_12125_length_2177_cov_2.284637 maxbin_6samples.033.fasta
    ## 74   NODE_12727_length_2125_cov_3.314976 maxbin_6samples.033.fasta
    ## 103  NODE_13948_length_2036_cov_2.008582 maxbin_6samples.044.fasta
    ## 118  NODE_14634_length_1992_cov_2.247806 maxbin_6samples.026.fasta
    ## 133  NODE_15249_length_1956_cov_2.124671 maxbin_6samples.044.fasta
    ## 172  NODE_17534_length_1833_cov_1.943195 maxbin_6samples.034.fasta
    ## 187  NODE_17965_length_1812_cov_1.739328 maxbin_6samples.044.fasta
    ## 203   NODE_1850_length_5429_cov_2.622069 maxbin_6samples.044.fasta
    ## 206  NODE_18613_length_1784_cov_2.097166 maxbin_6samples.033.fasta
    ## 231  NODE_19860_length_1731_cov_2.409905 maxbin_6samples.044.fasta
    ## 252  NODE_21129_length_1685_cov_1.929448 maxbin_6samples.013.fasta
    ## 254  NODE_21149_length_1684_cov_2.442603 maxbin_6samples.033.fasta
    ## 356   NODE_2750_length_4433_cov_2.674966 maxbin_6samples.044.fasta
    ## 379   NODE_2940_length_4301_cov_2.014837 maxbin_6samples.044.fasta
    ## 392  NODE_30350_length_1432_cov_2.161220 maxbin_6samples.034.fasta
    ## 407  NODE_31205_length_1414_cov_2.531273 maxbin_6samples.033.fasta
    ## 411  NODE_31346_length_1411_cov_2.772124 maxbin_6samples.033.fasta
    ## 441  NODE_33183_length_1376_cov_2.800151 maxbin_6samples.033.fasta
    ## 442  NODE_33208_length_1376_cov_1.874338 maxbin_6samples.033.fasta
    ## 444  NODE_33470_length_1371_cov_2.566109 maxbin_6samples.044.fasta
    ## 455  NODE_34114_length_1361_cov_1.979326 maxbin_6samples.034.fasta
    ## 465  NODE_34826_length_1349_cov_2.642195 maxbin_6samples.044.fasta
    ## 501  NODE_36325_length_1325_cov_1.510236 maxbin_6samples.033.fasta
    ## 521  NODE_37241_length_1310_cov_1.548207 maxbin_6samples.034.fasta
    ## 555  NODE_39341_length_1279_cov_2.033497 maxbin_6samples.034.fasta
    ## 642  NODE_44504_length_1213_cov_2.187392 maxbin_6samples.044.fasta
    ## 669  NODE_46234_length_1193_cov_2.188049 maxbin_6samples.033.fasta
    ## 763  NODE_53350_length_1121_cov_3.098499 maxbin_6samples.034.fasta
    ## 780  NODE_54854_length_1108_cov_2.436847 maxbin_6samples.044.fasta
    ## 866  NODE_61580_length_1056_cov_2.140859 maxbin_6samples.034.fasta
    ## 873   NODE_6227_length_2980_cov_2.676581 maxbin_6samples.033.fasta
    ## 928  NODE_66576_length_1022_cov_1.018614 maxbin_6samples.026.fasta
    ## 1003  NODE_8161_length_2624_cov_2.351109 maxbin_6samples.044.fasta
    ## 1022  NODE_9125_length_2494_cov_2.653137 maxbin_6samples.044.fasta
    ##            metabat   Marker Superkingdom          Phylum            Class
    ## 23            <NA>        6     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 32            <NA>       20     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 33            <NA>       20     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 55            <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 74            <NA>        3     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 103           <NA>        4     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 118           <NA>       27     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 133           <NA>        1     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 172           <NA>        4     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 187           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 203  metabat.15.fa        2     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 206           <NA>        4     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 231           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 252           <NA>       14     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 254           <NA>       28     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 356  metabat.15.fa        1     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 379  metabat.15.fa multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 392           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 407           <NA>       27     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 411           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 441           <NA>       24     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 442           <NA>        1     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 444           <NA>        7     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 455           <NA>        3     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 465           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 501           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 521           <NA>       22     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 555           <NA>        1     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 642           <NA>        6     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 669           <NA>       29     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 763           <NA>        2     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 780           <NA> multiple     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 866           <NA>        2     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 873  metabat.15.fa        2     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 928           <NA>       23     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 1003 metabat.15.fa        6     Bacteria Verrucomicrobia Verrucomicrobiae
    ## 1022          <NA>       24     Bacteria Verrucomicrobia Verrucomicrobiae
    ##                   Order              Family       Genus
    ## 23   Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 32   Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 33   Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 55   Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 74   Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 103  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 118  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 133  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 172  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 187  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 203  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 206  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 231  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 252  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 254  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 356  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 379  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 392  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 407  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 411  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 441  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 442  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 444  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 455  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 465  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 501  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 521  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 555  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 642  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 669  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 763  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 780  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 866  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 873  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 928  Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 1003 Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ## 1022 Verrucomicrobiales Verrucomicrobiaceae Akkermansia
    ##                      Species
    ## 23   Akkermansia muciniphila
    ## 32   Akkermansia muciniphila
    ## 33   Akkermansia muciniphila
    ## 55   Akkermansia muciniphila
    ## 74   Akkermansia muciniphila
    ## 103  Akkermansia muciniphila
    ## 118  Akkermansia muciniphila
    ## 133  Akkermansia muciniphila
    ## 172  Akkermansia muciniphila
    ## 187  Akkermansia muciniphila
    ## 203  Akkermansia muciniphila
    ## 206  Akkermansia muciniphila
    ## 231  Akkermansia muciniphila
    ## 252  Akkermansia muciniphila
    ## 254  Akkermansia muciniphila
    ## 356  Akkermansia muciniphila
    ## 379  Akkermansia muciniphila
    ## 392  Akkermansia muciniphila
    ## 407  Akkermansia muciniphila
    ## 411  Akkermansia muciniphila
    ## 441  Akkermansia muciniphila
    ## 442  Akkermansia muciniphila
    ## 444  Akkermansia muciniphila
    ## 455  Akkermansia muciniphila
    ## 465  Akkermansia muciniphila
    ## 501  Akkermansia muciniphila
    ## 521  Akkermansia muciniphila
    ## 555  Akkermansia muciniphila
    ## 642  Akkermansia muciniphila
    ## 669  Akkermansia muciniphila
    ## 763  Akkermansia muciniphila
    ## 780  Akkermansia muciniphila
    ## 866  Akkermansia muciniphila
    ## 873  Akkermansia muciniphila
    ## 928  Akkermansia muciniphila
    ## 1003 Akkermansia muciniphila
    ## 1022 Akkermansia muciniphila

Podemos ver tres *bins* en los cuales encontramos *contigs*
identificados como *Akkermansia muciniphila*:
`maxbin_6samples.033.fasta`, `maxbin_6samples.034.fasta`, y
`maxbin_6samples.044.fasta`.

  - Vamos a comenzar por graficar los tres *bins* y las especies:

<div class="sourceCode">

``` sourceCode r
bin1 <- maxbin_6samples.033.fasta
bin2 <- maxbin_6samples.034.fasta
bin3 <- maxbin_6samples.044.fasta

sp <- "Akkermansia muciniphila"
cont_sp <- table_markers_resolved$Query[which(table_markers_resolved$Species %in% sp)]

par(mfrow=c(2,3))
for (i in c(3:8))
{
plot(table_all[,2], log(table_all[,i]), pch=20, xlab="GC content", ylab="abundance (log)", main=colnames(table_all[i]), cex.lab=1.5, cex.main=2)

points(table_all[table_all$contig %in% bin1 ,2], log(table_all[table_all$contig %in% bin1 ,i]), col="yellow", pch=20)
points(table_all[table_all$contig %in% bin2 ,2], log(table_all[table_all$contig %in% bin2 ,i]), col=rgb(0, 0, 1, 0.5), pch=20)
points(table_all[table_all$contig %in% bin3 ,2], log(table_all[table_all$contig %in% bin3 ,i]), col=rgb(0, 1, 0, 0.5), pch=20)
points(table_all[table_all$contig %in% cont_sp ,2], log(table_all[table_all$contig %in% cont_sp ,i]), col=rgb(1, 0, 0, 0.6), pch=20)
legend( x="bottomleft", 
        legend=c("maxbin_6samples.033.fasta", "maxbin_6samples.034.fasta","maxbin_6samples.044.fasta","Akkermansia muciniphila"), 
        col=c("yellow","blue","green","red"), 
        pch=20, merge=FALSE , cex=1.3)
}
```

</div>

![](images/plot_9.png)

Como se observa, los *contigs* asociados con esta especie se superponen
en los tres *bins*, los cuales a su vez son muy cercanos entre sí.

  - Podemos combinar estos *contigs* y formar uno nuevo:

<div class="sourceCode">

``` sourceCode r
new_bin4 <- unique(c(maxbin_6samples.033.fasta,maxbin_6samples.034.fasta,maxbin_6samples.044.fasta))
```

</div>

> **Usando el mismo método, échale un vistazo al *bin*
> `maxbin_6samples.011.fasta` y evalúa si se podría combinar con otros
> *bins*.**

</div>

</div>

<div id="abundancia-de-bins-y-comunidades-microbianas" class="section level1">

# <span class="header-section-number">5</span> Abundancia de *bins* y comunidades microbianas

Ahora que hemos visualizado y curado un *bin*, podemos mirarlo de nuevo
pero en un contexto más biológico. Tenemos tres muestras que provienen
de *C. quitensis* (G1\_1, G1\_2, and G1\_3) y otras tres que provienen
de plantas de *C. quitensis* que crecían en asociación con *D.
antarctica* (G2\_1, G2\_2, and G2\_3).

Para observar la abundancia de esos *bins* en las diferentes
condiciones, vamos a generar un mapa de calor o *heatmap* que represente
su abundancia en todas las muestras.

  - Primero generamos una tabla que contenga la información que
    necesitamos, i.e., abundancia del *bin* curado a partir de la
    abundancia de sus *contigs*.

<div class="sourceCode">

``` sourceCode r
table_new_bin <- as.data.frame(matrix(nrow=4, ncol=7, NA))
colnames(table_new_bin) <- c("bin","G1_1","G1_2","G1_3","G2_1","G2_2","G2_3")

bin_list <- c("new_bin","new_bin2","new_bin3","new_bin4")

for (i in c(1:length(bin_list)))
{

table_new_bin[i,1] <- bin_list[i]
curr_bin <- get(bin_list[i])
table_new_bin[i,2] <- sum(table_all[table_all$contig %in% curr_bin ,3])
table_new_bin[i,3] <- sum(table_all[table_all$contig %in% curr_bin ,4])
table_new_bin[i,4] <- sum(table_all[table_all$contig %in% curr_bin ,5])
table_new_bin[i,5] <- sum(table_all[table_all$contig %in% curr_bin ,6])
table_new_bin[i,6] <- sum(table_all[table_all$contig %in% curr_bin ,7])
table_new_bin[i,7] <- sum(table_all[table_all$contig %in% curr_bin ,8])

}

heatmap.2(as.matrix(table_new_bin[,c(2:7)]), dendrogram="none", trace="none", scale="row",labRow = c("new_bin","new_bin2","new_bin3","new_bin4"), margins = c(5, 10), Rowv=FALSE, Colv=FALSE)
```

</div>

![](mags_files/figure-html/unnamed-chunk-65-1.png)

Primero, vemos que las réplicas biológicas se comportan muy similarmente
para todos los *bins*. De hecho, las muestras G1\_1, G1\_2, y G1\_3 que
corresponden a *C. quitensis* tienen niveles similares de abundancia, de
la misma forma que las siguientes tres muestras, G2\_1, G2\_2 and G2\_3
que corresponden a *C. quitensis* en asociación con *D. antarctica*.

De los cuatro *bins* evaluados, solo uno tiene una mayor abundancia en
*C. quitensis* en asociación con *D. antarctica*. Este es el `new_bin4`
que identificamos previamente como *Akkermansia muciniphila*.  
*A. muciniphila* es una bacteria más comúnmente asociada con el
microbioma intestinal humano. Sin embargo, su alta abundancia es
consistente en todas las muestras de *C. quitensis* en asociación con
*D. antarctica*, lo cual es consistente con una señal biológica. Si
fuera contaminación, esperaríamos que surja de manera independiente a
alguna señal biológica en muestras no relacionadas. Además,
investigadores han mostrado que existen muchas similitudes entre el
microbioma intestinal y el rizosférico ( [Ramírez-Puebla et
al., 2013](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3536091/#B86) ).
En particular, *A. muciniphila* es conocida por expresar proteínas que
degradan mucinas en el intestino que a su vez contienen proteínas
altamente glicosiladas ( [Derrien et
al., 2008](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2258631/) ). En
la rizósfera, algunas plantas son capaces de atraer microorganismos a
través del mucilago, que también contiene una gran cantidad de proteínas
glicosiladas. Una explicación para la presencia de *A. muciniphila* en
la rizósfera de *D. antarctica* es que esta tiene un rol en mejorar la
resistencia de la planta a las condiciones extremas propias de la
Antártica.

De aquí en adelante, uno podría seguir investigando si hay algo
interesante en este MAG de *A. muciniphila* en relación a su contenido
de genes, sus funciones, y sus relaciones con otros aislados.

![](images/IMG_0902.JPG)

-----

![](images/back.png) [**Ir a la página de inicio del
curso**](http://castrolab.org/isme/bienvenida_WorkshopISME.html)

</div>

</div>

</div>

</div>

</div>

</div>

</div>
